0000                          .ENGINE   mycomputer   
0000                             ; 
0000                TEC_1:    EQU   1   
0000                RC2014:   EQU   0   
0000                EXTENDED:   EQU   0   
0000                          IF   RC2014   
                                 ; Configuration for RC2014
                    ROMSTART:   EQU   $8000   
                    RAMSTART:   EQU   $8800   
                    LOADER:   EQU   0   
                    BITBANG:   EQU   0   
0000                          ENDIF      
0000                          IF   TEC_1   
0000                             ; Configuration for TEC-1
0000                LOADER:   EQU   0   
0000                BITBANG:   EQU   0   
0000                ROMSTART:   EQU   $0000   
0000                RAMSTART:   EQU   $0800   
0000                ROMSIZE:   EQU   $0800   
0000                RAMSIZE:   EQU   $0800   
0000                             ;TEC-1D SC 8k rom/ram
0000                             ; ROMSTART .equ $0000
0000                             ; RAMSTART .equ $2000
0000                             ; ROMSIZE  .equ 8192
0000                             ; RAMSIZE  .equ 8192
0000                          ENDIF      
0000                             ; ROM code
0000                             ; Targets:
0000                             ; TEC-1,TEC-1D,TEC-1F,Southern Cross,RC2014
0000                             ; Memory Map: 2k ROM/RAM, 8K ROM/RAM, RC2014
0000                             ; Serial: Bit Bang, 6850 ACIA
0000                             ; 
0000                          IF   TEC_1   
0000                          IF   BITBANG   
                                 ; 
                                 ; bit bang baud rate constants @ 4MHz
                    B300:     EQU   0220H   
                    B1200:    EQU   0080H   
                    B2400:    EQU   003FH   
                    B4800:    EQU   001BH   
                    B9600:    EQU   000BH   
                                 ; 
0000                          ELSE      ;6850
0000                             ; 
0000                             ; 
0000                             ; 6850 ACIA registers
0000                             ;----------------------
0000                CONTROL:   EQU   $80   ;(write) 
0000                STATUS:   EQU   $80   ;(read)
0000                TDR:      EQU   $81   ;(write)
0000                RDR:      EQU   $81   ;(read)
0000                             ; 
0000                             ; control register bits
0000                             ;----------------------
0000                             ; 
0000                             ;clock divisor
0000                             ; 
0000                MRESET:   EQU   $03   ;master reset the ACIA
0000                             ; DIV_0    .EQU  $00        ;CLOCK/1
0000                             ; DIV_16   .EQU  $01        ;CLOCK/16
0000                DIV_64:   EQU   $02   ;CLOCK/64
0000                             ; 
0000                             ; format select
0000                             ; 
0000                F7E2:     EQU   $00   ;7 data bits, EVEN parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7O2:     EQU   $04   ;7 data bits, ODD parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7E1:     EQU   $08   ;7 data bits, EVEN parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F7O1:     EQU   $0C   ;7 data bits, ODD parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F8N2:     EQU   $10   ;8 data bits, NO parity, 2 stop bits (1+8+0+2= 11 bits)
0000                F8N1:     EQU   $14   ;8 data bits, NO parity, 1 stop bit (1+8+0+1= 10 bits)
0000                F8E1:     EQU   $18   ;8 data bits, EVEN parity, 1 stop bit (1+8+1+1= 11 bits)
0000                F8O1:     EQU   $1C   ;8 data bits, ODD parity,1 stop bit (1+8+1+1= 11 bits)
0000                             ; 
0000                             ; transmitter control
0000                             ; 
0000                RTSLID:   EQU   $00   ;RTS LOW, transmit interrupt disabled
0000                RTSLIE:   EQU   $20   ;RTS LOW, transmit interrupt enabled
0000                RTSHID:   EQU   $40   ;RTS HIGH, transmit interrupt disabled
0000                RTSLIDB:   EQU   $60   ;RTS LOW, transmit interrupt disabled and "break" transmitted
0000                             ; 
0000                             ; receiver interrupt
0000                             ; 
0000                RIE:      EQU   $80   ;receiver interrupt enabled
0000                             ; 
0000                             ; status register bits
0000                             ;---------------------
0000                RDRF:     EQU   0   ;receive data register full
0000                TDRE:     EQU   1   ;transmit data register empty
0000                DCD:      EQU   2   ;data carrier detect
0000                CTS:      EQU   3   ;clear to send
0000                FE:       EQU   4   ;framing error
0000                OVRN:     EQU   5   ;overrun
0000                PE:       EQU   6   ;parity error
0000                IRQ:      EQU   7   ;interrupt request
0000                             ; 
0000                          ENDIF      
0000                          ENDIF      
0000                             ; 
0000                             ; I/O port addresses
0000                             ; 
0000                          IF   TEC_1   
0000                KEYBUF:   EQU   00H   ;MM74C923N KEYBOARD ENCODER
0000                SCAN:     EQU   01H   ;DISPLAY SCAN LATCH
0000                DISPLY:   EQU   02H   ;DISPLAY LATCH
0000                PORT3:    EQU   03H   ;ST3 (8X8), STROBE (RELAY BOARD) DATLATCH (DAT BOARD)
0000                PORT4:    EQU   04H   ;ST4 (8X8), LCD "E" (DAT BOARD)
0000                PORT5:    EQU   05H   
0000                PORT6:    EQU   06H   
0000                PORT7:    EQU   07H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ELSE      ;SC
                    IO0:      EQU   80H   ;IO PORT 0
                    IO1:      EQU   81H   ;IO PORT 1
                    IO2:      EQU   82H   ;IO PORT 2
                    IO3:      EQU   83H   ;IO PORT 3
                    DISPLY:   EQU   84H   ;DISPLAY LATCH
                    SCAN:     EQU   85H   ;DISPLAY SCAN LATCH
                    KEYBUF:   EQU   86H   ;KEYBOARD BUFFER
                    IO7:      EQU   87H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ENDIF      
0000                             ; 
0000                             ; ASCII codes
0000                ESC:      EQU   1BH   
0000                CR:       EQU   0DH   
0000                LF:       EQU   0AH   
0000                             ; 
0000                          .ORG   ROMSTART   
0000                             ;reset
0000                RSTVEC:      
0000   C3 8B 00               JP   RESET   
0003                             ;RST 1
0008                          .ORG   ROMSTART+$08   
0008   E5                     PUSH   HL   
0009   2A 38 0B               LD   HL,(RST08)   
000C   E9                     JP   (HL)   
000D                             ; 
000D                             ;RST 2
0010                          .ORG   ROMSTART+$10   
0010   E5                     PUSH   HL   
0011   2A 3A 0B               LD   HL,(RST10)   
0014   E9                     JP   (HL)   
0015                             ; 
0015                             ;RST 3
0018                          .ORG   ROMSTART+$18   
0018   E5                     PUSH   HL   
0019   2A 3C 0B               LD   HL,(RST18)   
001C   E9                     JP   (HL)   
001D                             ; 
001D                             ;RST 4
0020                          .ORG   ROMSTART+$20   
0020   E5                     PUSH   HL   
0021   2A 3E 0B               LD   HL,(RST20)   
0024   E9                     JP   (HL)   
0025                             ; 
0025                             ;RST 5
0028                          .ORG   ROMSTART+$28   
0028   E5                     PUSH   HL   
0029   2A 40 0B               LD   HL,(RST28)   
002C   E9                     JP   (HL)   
002D                             ; 
002D                             ;RST 6
0030                          .ORG   ROMSTART+$30   
0030   E5                     PUSH   HL   
0031   2A 42 0B               LD   HL,(RST30)   
0034   E9                     JP   (HL)   
0035                             ; 
0035                             ;RST 7 Interrupt
0038                          .ORG   ROMSTART+$38   
0038   E5                     PUSH   HL   
0039   2A 46 0B               LD   HL,(INTVEC)   
003C   E9                     JP   (HL)   
003D   ED 4D                  RETI      
003F                             ; 
0040                          .ORG   ROMSTART+$40   
0040                             ; 
0040                             ;hexadecimal to 7 segment display code table
0040                          IF   TEC_1   
0040                             ; 
0040                SEVENSEGMENT:      
0040   EB 28 CD AD            DB   0EBH,28H,0CDH,0ADH   ;0,1,2,3
0044   2E A7 E7 29            DB   2EH,0A7H,0E7H,29H   ;4,5,6,7
0048   EF 2F 6F E6            DB   0EFH,2FH,6FH,0E6H   ;8,9,A,B
004C   C3 EC C7 47            DB   0C3H,0ECH,0C7H,47H   ;C,D,E,F
0050                          ELSE      ;SC
                                 ; 
                    SEVENSEGMENT:      
                              DB   3FH,06H,5BH,4FH   ;0,1,2,3
                              DB   66H,6DH,7DH,07H   ;4,5,6,7
                              DB   7FH,6FH,77H,7CH   ;8,9,A,B
                              DB   39H,5EH,79H,71H   ;C,D,E,F
0050                          ENDIF      
0050                             ; 
0050                             ; 
0050                             ;---------------
0050                             ; BIT TIME DELAY
0050                             ;---------------
0050                             ;DELAY FOR ONE SERIAL BIT TIME
0050                             ;ENTRY : HL = DELAY TIME
0050                             ; NO REGISTERS MODIFIED
0050                             ; 
0050                PWRUP:       
0050   21 00 20               LD   hl,$2000   
0053                BITIME:      
0053   E5                     PUSH   HL   
0054   D5                     PUSH   DE   
0055   11 01 00               LD   DE,0001H   
0058                BITIM1:      
0058   ED 52                  SBC   HL,DE   
005A   D2 58 00               JP   NC,BITIM1   
005D   D1                     POP   DE   
005E   E1                     POP   HL   
005F                INTRET:      
005F   C9                     RET      
0060                             ; 
0060                             ;RST 8  Non Maskable Interrupt
0066                          .ORG   ROMSTART+$66   
0066   E5                     PUSH   HL   
0067   2A 48 0B               LD   HL,(NMIVEC)   
006A   E9                     JP   (HL)   
006B                             ; 
006B                             ; 
006B                          IF   BITBANG   
                                 ; 
                                 ;------------------------
                                 ; SERIAL TRANSMIT ROUTINE
                                 ;------------------------
                                 ;TRANSMIT BYTE SERIALLY ON DOUT
                                 ; 
                                 ; ENTRY : A = BYTE TO TRANSMIT
                                 ;  EXIT : NO REGISTERS MODIFIED
                                 ; 
                                 ; 
                    TXCHAR:      
                    TXDATA:      
                              PUSH   AF   
                              PUSH   BC   
                              PUSH   HL   
                              LD   HL,(BAUD)   
                              LD   C,A   
                                 ; 
                                 ; TRANSMIT START BIT
                                 ; 
                              XOR   A   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                                 ; 
                                 ; TRANSMIT DATA
                                 ; 
                              LD   B,08H   
                              RRC   C   
                    NXTBIT:      
                              RRC   C   ;SHIFT BITS TO D6,
                              LD   A,C   ;LSB FIRST AND OUTPUT
                              AND   40H   ;THEM FOR ONE BIT TIME.
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              DJNZ   NXTBIT   
                                 ; 
                                 ; SEND STOP BITS
                                 ; 
                              LD   A,40H   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              CALL   BITIME   
                              POP   HL   
                              POP   BC   
                              POP   AF   
                              RET      
                                 ;-----------------------
                                 ; SERIAL RECEIVE ROUTINE
                                 ;-----------------------
                                 ;RECEIVE SERIAL BYTE FROM DIN
                                 ; 
                                 ; ENTRY : NONE
                                 ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
                                 ; 
                                 ; REGISTERS MODIFIED A AND F
                                 ; 
                    RXCHAR:      
                    RXDATA:      
                              PUSH   BC   
                              PUSH   HL   
                                 ; 
                                 ; WAIT FOR START BIT 
                                 ; 
                    RXDAT1:   IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;NO START BIT
                                 ; 
                                 ; DETECTED START BIT
                                 ; 
                              LD   HL,(BAUD)   
                              SRL   H   
                              RR   L   ;DELAY FOR HALF BIT TIME
                              CALL   BITIME   
                              IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;START BIT NOT VALID
                                 ; 
                                 ; DETECTED VALID START BIT,READ IN DATA
                                 ; 
                              LD   B,08H   
                    RXDAT2:      
                              LD   HL,(BAUD)   
                              CALL   BITIME   ;DELAY ONE BIT TIME
                              IN   A,(KEYBUF)   
                              RL   A   
                              RR   C   ;SHIFT BIT INTO DATA REG
                              DJNZ   RXDAT2   
                              LD   A,C   
                              OR   A   ;CLEAR CARRY FLAG
                              POP   HL   
                              POP   BC   
                              RET      
                                 ; 
006B                          ELSE      ;6850
006B                             ; 
006B                             ; transmit a character in a
006B                             ;--------------------------
006B                TXDATA:      
006B                TXCHAR:      
006B   C5                     PUSH   bc   
006C   47                     LD   b,a   ;save the character  for later
006D                TXCHAR1:      
006D   DB 80                  IN   a,(STATUS)   ;get the ACIA status
006F   CB 4F                  BIT   1,a   
0071                             ;        bit   TDRE,a                ;is the TDRE bit high?
0071   28 FA                  JR   z,TxChar1   ;no, the TDR is not empty
0073   78                     LD   a,b   ;yes, get the character
0074   D3 81                  OUT   (TDR),a   ;and put it in the TDR
0076   C1                     POP   bc   
0077   C9                     RET      
0078                             ; 
0078                             ; receive  a character in a
0078                             ;---------------------------------
0078                RXDATA:      
0078                RXCHAR:      
0078   DB 80                  IN   a,(STATUS)   ;get the ACIA status
007A   CB 47                  BIT   0,a   
007C                             ;        bit   RDRF,a             ;is the RDRF bit high?
007C   28 FA                  JR   z,RxChar   ;no, the RDR is empty
007E   DB 81                  IN   a,(RDR)   ;yes, read the received char
0080   C9                     RET      
0081                          ENDIF      
0081                             ; 
0081                          IF   LOADER   
                                 ;   .ORG   ROMSTART + $0700
                                 ;-----------------------
                                 ; RECEIVE INTEL HEX FILE
                                 ;-----------------------
                    INTELH:      
                              LD   IX,BUF   
                                 ; 
                                 ; WAIT FOR RECORD MARK
                                 ; 
                    INTEL1:      
                              XOR   A   
                              LD   (IX+3),A   ;CLEAR CHECKSUM
                              CALL   RXDATA   ;WAIT FOR THE RECORD MARK
                              CP   ":"   ;TO BE TRANSMITTED
                              JR   NZ,INTEL1   ;NOT RECORD MARK
                                 ; 
                                 ; GET RECORD LENGTH
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+0),A   ;NUMBER OF DATA BYTES
                                 ; 
                                 ; GET ADDRESS FIELD
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+2),A   ;LOAD ADDRESS HIGH BYTE
                              CALL   GETBYT   
                              LD   (IX+1),A   ;LOAD ADDRESS LOW BYTE
                                 ; 
                                 ; GET RECORD TYPE
                                 ; 
                              CALL   GETBYT   
                              JR   NZ,INTEL4   ;END OF FILE RECORD
                                 ; 
                                 ; READ IN THE DATA
                                 ; 
                              LD   B,(IX+0)   ;NUMBER OF DATA BYTES
                              LD   H,(IX+2)   ;LOAD ADDRESS HIGH BYTE
                              LD   L,(IX+1)   ;LOAD ADDRESS LOW BYTE
                                 ; 
                    INTEL2:      
                              CALL   GETBYT   ;GET DATA BYTE
                              LD   (HL),A   ;STORE DATA BYTE
                              INC   HL   
                              DJNZ   INTEL2   ;LOAD MORE BYTES
                                 ; 
                                 ; GET CHECKSUM AND COMPARE
                                 ; 
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE RECORD CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              JR   Z,INTEL1   ;CHECKSUM OK,NEXT RECORD
                              RET      ;NZ=CHECKSUM ERROR
                                 ; 
                                 ; END OF FILE RECORD
                                 ; 
                    INTEL4:      
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE EOF CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              RET      ;NZ=CHECKSUM ERROR
                                 ;--------------------------
                                 ; GET BYTE FROM SERIAL PORT
                                 ;--------------------------
                    GETBYT:      
                              PUSH   BC   
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT1   
                              ADD   A,09H   
                    GETBT1:      
                              AND   0FH   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              LD   C,A   
                                 ; 
                                 ; GET LOW NYBBLE
                                 ; 
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT2   
                              ADD   A,09H   
                    GETBT2:   AND   0FH   
                              OR   C   
                              LD   B,A   
                              ADD   A,(IX+3)   
                              LD   (IX+3),A   ;ADD TO CHECKSUM
                              LD   A,B   
                              AND   A   ;CLEAR CARRY
                              POP   BC   
                              RET      
0081                          ENDIF      
0081                             ; 
0081                             ; in this example code just wait for an INTEL Hex file download
0081                             ;just going to send a char to let you know I'm here
0081                          IF   LOADER   
                                 ; 
                    LOAD:        
                              LD   a,"L"   ; L for load
                              CALL   TxChar   
                              CALL   INTELH   
                              JP   z,RAMSTART   ;assume the downloaded code starts here
                              LD   a,"0"   ;0 is false
                              CALL   TxChar   
                              JR   load   ;if at first you don't succeed...
0081                          ENDIF      
0081                             ; 
0081                GETCHAR:      
0081   2A 4A 0B               LD   HL,(GETCVEC)   
0084   E9                     JP   (HL)   
0085                             ; 
0085                PUTCHAR:      
0085   E5                     PUSH   HL   
0086   2A 4C 0B               LD   HL,(PUTCVEC)   
0089   E3                     EX   (SP),HL   
008A   C9                     RET      
008B                             ; 
008B                RESET:       
008B   31 00 0A               LD   SP,stack   
008E   21 5F 00               LD   HL,IntRet   
0091   22 38 0B               LD   (RST08),HL   
0094   22 3A 0B               LD   (RST10),HL   
0097   22 3C 0B               LD   (RST18),HL   
009A   22 3E 0B               LD   (RST20),HL   
009D   22 40 0B               LD   (RST28),HL   
00A0   22 42 0B               LD   (RST30),HL   
00A3   22 46 0B               LD   (INTVEC),HL   
00A6   22 48 0B               LD   (NMIVEC),HL   
00A9                             ; 
00A9   21 78 00               LD   HL,RXDATA   
00AC   22 4A 0B               LD   (GETCVEC),HL   
00AF   21 6B 00               LD   HL,TXDATA   
00B2   22 4C 0B               LD   (PUTCVEC),HL   
00B5                             ; 
00B5                          IF   TEC_1   
00B5                          IF   BITBANG = 0   
00B5                             ; 
00B5   3E 03                  LD   a,MRESET   
00B7   D3 80                  OUT   (CONTROL),a   ;reset the ACIA
00B9                             ; 
00B9                          ENDIF      
00B9                          ENDIF      
00B9                             ; 
00B9   CD 50 00               CALL   PWRUP   
00BC   ED 56                  IM   1   
00BE   FB                     EI      
00BF                             ; 
00BF                          IF   TEC_1   
00BF                          IF   BITBANG   
                                 ; 
                                 ;inline serial initialisation
                              LD   A,$40   
                              LD   C,SCAN   
                              OUT   (C),A   
                              LD   HL,B4800   
                              LD   (BAUD),HL   
                                 ; 
00BF                          ELSE      ;6850      
00BF                             ; 
00BF   3E 12                  LD   a,RTSLID+F8N2+DIV_64   
00C1   D3 80                  OUT   (CONTROL),a   ;initialise ACIA  8 bit word, No parity 2 stop divide by 64 for 115200 baud
00C3                             ; 
00C3                          ENDIF      
00C3                          ENDIF      
00C3                             ; 
00C3                             ; 
00C3                             ; 
00C3   C3 EF 01               JP   start   
00C6                             ; 
00C6                             ; *************************************************************************
00C6                             ; 
00C6                             ;       Mondo Minimal Interpreter for the z80
00C6                             ; 
00C6                             ;       Ken Boak, John Hardy and craig Jones.
00C6                             ; 
00C6                             ;       GNU GENERAL PUBLIc LIcENSE                   Version 3, 29 June 2007
00C6                             ; 
00C6                             ;       see the LIcENSE file in this repo for more information
00C6                             ; 
00C6                             ; *****************************************************************************
00C6                FALSE:    EQU   0   
00C6                TRUE:     EQU   -1   
00C6                UNLIMITED:   EQU   -2   ; for endless loops
00C6                CTRL_C:   EQU   3   ; end of text
00C6                CTRL_E:   EQU   5   ; edit
00C6                CTRL_H:   EQU   8   ; backspace
00C6                CTRL_J:   EQU   10   ; re-edit
00C6                CTRL_L:   EQU   12   ; list
00C6                CTRL_P:   EQU   16   ; print stack
00C6                BSLASH:   EQU   $5c   
00C6                .macro LITDAT,len
00C6                             ; 
00C6                 db len
00C6                .endm
00C6                 
00C6                .macro REPDAT,len,data
00C6                             ; 
00C6                 db (len | $80)
00C6                 db data
00C6                .endm
00C6                 
00C6                .macro ENDDAT,
00C6                             ; 
00C6                 db 0
00C6                .endm
00C6                 
00C6                             ; **************************************************************************
00C6                             ; Page 0  Initialisation
00C6                             ; **************************************************************************		
0180                          .ORG   ROMSTART + $180   ; 0+180 put Mondo code from here	
0180                             ; **************************************************************************
0180                             ; Macros must be written in Mondo and end with ;
0180                             ; this code must not span pages
0180                             ; **************************************************************************
0180                MACROS:      
0180                REEDIT_:      
0180   2F 7A 2F 55 45 3B      DB   "/z/UE;"   ; remembers last line edited
0186                EDIT_:       
0186   60 3F 60 2F 4B 2F 55 50 2F 55 45 3B 00 .CSTR   "`?`/K/UP/UE;"   
0193                LIST_:       
0193                             ; .cstr "/N26(/i65+/UE/k0>(/N))/UP;"
0193                PRINTSTACK_:      
0193   2F 55 53 2F 55 50 3B 00 .CSTR   "/US/UP;"   
019B                IOPCODES:      
019B                          ;*Macro unroll:  LITDAT 15
019B   0F                     DB   15   
019C   66                     DB   lsb(bang_)   ;    !
019D   00                     DB   lsb(dquote_)   ;    "
019E   44                     DB   lsb(hash_)   ;    #
019F   49                     DB   lsb(dollar_)   ;    $
01A0   4E                     DB   lsb(percent_)   ;    %
01A1   02                     DB   lsb(amper_)   ;    &
01A2   EE                     DB   lsb(quote_)   ;    '
01A3   DF                     DB   lsb(lparen_)   ;    (
01A4   E2                     DB   lsb(rparen_)   ;    )
01A5   F0                     DB   lsb(star_)   ;    *
01A6   1F                     DB   lsb(plus_)   ;    +
01A7   3B                     DB   lsb(comma_)   ;    ,
01A8   70                     DB   lsb(minus_)   ;    -
01A9   30                     DB   lsb(dot_)   ;    .
01AA   F2                     DB   lsb(slash_)   ;    /	;/MOD
01AB                          ;*Macro unroll:  REPDAT 10, lsb(num_)		; 10 x repeat lsb of add to the num routine
01AB   8A                     DB   (10 | $80)   ; 10 x repeat lsb of add to the num routine
01AC   E5                     DB   lsb(num_)   
01AD                          ;*Macro unroll:  LITDAT 7
01AD   07                     DB   7   
01AE   E8                     DB   lsb(colon_)   ;    :
01AF   55                     DB   lsb(semi_)   ;    ;
01B0   9C                     DB   lsb(lt_)   ;    <
01B1   85                     DB   lsb(eq_)   ;    =
01B2   98                     DB   lsb(gt_)   ;    >
01B3   00                     DB   lsb(question_)   ;    ?   ( -- val )  read a char from input
01B4   D2                     DB   lsb(at_)   ;    @
01B5                          ;*Macro unroll:  REPDAT 26, lsb(call_)	; call a command A, B ....z
01B5   9A                     DB   (26 | $80)   ; call a command A, B ....z
01B6   26                     DB   lsb(call_)   
01B7                          ;*Macro unroll:  LITDAT 6
01B7   06                     DB   6   
01B8   C9                     DB   lsb(lbrack_)   ;    [
01B9   41                     DB   lsb(bslash_)   ;    \
01BA   EB                     DB   lsb(rbrack_)   ;    ]
01BB   16                     DB   lsb(caret_)   ;    ^
01BC   00                     DB   lsb(underscore_)   ;    _
01BD   BA                     DB   lsb(grave_)   ;    `   ; for printing `hello`
01BE                          ;*Macro unroll:  REPDAT 26, lsb(var_)	; a b c .....z
01BE   9A                     DB   (26 | $80)   ; a b c .....z
01BF   A5                     DB   lsb(var_)   
01C0                          ;*Macro unroll:  LITDAT 4
01C0   04                     DB   4   
01C1   00                     DB   lsb(lbrace_)   ;    {
01C2   0D                     DB   lsb(pipe_)   ;    |
01C3   00                     DB   lsb(rbrace_)   ;    }
01C4   5C                     DB   lsb(tilde_)   ;    ~ ( a b c -- b c a ) rotate
01C5                IALTCODES:      
01C5                          ;*Macro unroll:  LITDAT 24
01C5   18                     DB   24   
01C6   06                     DB   lsb(aNop_)   ;A
01C7   08                     DB   lsb(bmode_)   ;B      toggle byte mode
01C8   06                     DB   lsb(aNop_)   ;C
01C9   06                     DB   lsb(aNop_)   ;D
01CA   14                     DB   lsb(emit_)   ;E      emit a char
01CB   06                     DB   lsb(aNop_)   ;F      false
01CC   2C                     DB   lsb(go_)   ;G      execute Mondo code
01CD   06                     DB   lsb(aNop_)   ;H      toggle hex mode
01CE   41                     DB   lsb(inPort_)   ;I      input from port
01CF   06                     DB   lsb(aNop_)   ;J      loop variable
01D0   23                     DB   lsb(key_)   ;K      input char
01D1   5A                     DB   lsb(shl_)   ;L
01D2   06                     DB   lsb(aNop_)   ;M
01D3   4C                     DB   lsb(newln_)   ;N      prints a newline to output
01D4   51                     DB   lsb(outPort_)   ;O      output to port
01D5   06                     DB   lsb(aNop_)   ;P      print Mondo prompt
01D6   06                     DB   lsb(aNop_)   ;Q
01D7   69                     DB   lsb(shr_)   ;R
01D8   00                     DB   lsb(arrSize_)   ;S      array size
01D9   06                     DB   lsb(aNop_)   ;T      true
01DA   7B                     DB   lsb(utility_)   ;U
01DB   06                     DB   lsb(aNop_)   ;V
01DC   C2                     DB   lsb(while_)   ;W      word mode
01DD   1B                     DB   lsb(exec_)   ;X      execute machine code
01DE                          ;*Macro unroll:  REPDAT 3, lsb(aNop_)
01DE   83                     DB   (3 | $80)   
01DF   06                     DB   lsb(aNop_)   
01E0                             ;Y
01E0                             ;Z
01E0                          ;*Macro unroll:  ENDDAT
01E0   00                     DB   0   
01E1                BACKSPACE:      
01E1   79                     LD   a,c   
01E2   B0                     OR   b   
01E3   28 29                  JR   z,interpret2   
01E5   0B                     DEC   bc   
01E6   CD B5 03               CALL   printStr   
01E9   08 20 08 00            .CSTR   "\b \b"   
01ED   18 1F                  JR   interpret2   
01EF                START:       
01EF   31 00 0A               LD   SP,DSTACK   ; start of Mondo
01F2   CD B7 02               CALL   init   ; setups
01F5   CD B5 03               CALL   printStr   ; prog count to stack, put code line 235 on stack then call print
01F8   4D 6F 6E 64 6F 20 30 2E 31 0D 0A 00 .CSTR   "Mondo 0.1\r\n"   
0204                INTERPRET:      
0204   CD A5 03               CALL   prompt   
0207   01 00 00               LD   bc,0   ; load bc with offset into TIb, decide char into tib or execute or control
020A   ED 43 96 0B            LD   (vTIBPtr),bc   
020E                INTERPRET2:      ; calc nesting (a macro might have changed it)
020E   1E 00                  LD   e,0   ; initilize nesting value
0210   C5                     PUSH   bc   ; save offset into TIb,
0211                             ; bc is also the count of chars in TIB
0211   21 00 08               LD   hl,TIB   ; hl is start of TIB
0214   18 06                  JR   interpret4   
0216                INTERPRET3:      
0216   7E                     LD   a,(hl)   ; A = char in TIB
0217   23                     INC   hl   ; inc pointer into TIB
0218   0B                     DEC   bc   ; dec count of chars in TIB
0219   CD 79 03               CALL   nesting   ; update nesting value
021C                INTERPRET4:      
021C   79                     LD   a,c   ; is count zero?
021D   B0                     OR   B   
021E   20 F6                  JR   nz,interpret3   ; if not loop
0220   C1                     POP   bc   ; restore offset into TIB
0221                WAITCHAR:      
0221   CD 81 00               CALL   getchar   ; loop around waiting for character from serial port
0224   FE 20                  CP   $20   ; compare to space
0226   30 39                  JR   nc,waitchar1   ; if >= space, if below 20 set cary flag
0228   FE 00                  CP   $0   ; is it end of string? null end of string
022A   28 59                  JR   z,waitchar4   
022C   FE 0D                  CP   "\r"   ; carriage return? ascii 13
022E   28 3F                  JR   z,waitchar3   ; if anything else its macro/control
0230   FE 08                  CP   cTRL_H   
0232   28 AD                  JR   z,backSpace   
0234   16 01                  LD   d,msb(macros)   
0236   FE 05                  CP   cTRL_E   
0238   1E 86                  LD   e,lsb(edit_)   
023A   28 14                  JR   z,macro   
023C   FE 0A                  CP   cTRL_J   
023E   1E 80                  LD   e,lsb(reedit_)   
0240   28 0E                  JR   z,macro   
0242   FE 0C                  CP   cTRL_L   
0244   1E 93                  LD   e,lsb(list_)   
0246   28 08                  JR   z,macro   
0248   FE 10                  CP   cTRL_P   
024A   1E 93                  LD   e,lsb(printStack_)   
024C   28 02                  JR   z,macro   
024E   18 BE                  JR   interpret2   
0250                MACRO:       
0250   ED 43 96 0B            LD   (vTIBPtr),bc   
0254   D5                     PUSH   de   
0255   CD E0 03               CALL   ENTER   ;Mondo go operation and jump to it
0258   2F 47 00               .CSTR   "/G"   
025B   ED 4B 96 0B            LD   bc,(vTIBPtr)   
025F   18 AD                  JR   interpret2   
0261                WAITCHAR1:      
0261   21 00 08               LD   hl,TIB   
0264   09                     ADD   hl,bc   
0265   77                     LD   (hl),A   ; store the character in textbuf
0266   03                     INC   bc   
0267   CD 85 00               CALL   putchar   ; echo character to screen
026A   CD 79 03               CALL   nesting   
026D   18 B2                  JR   waitchar   ; wait for next character
026F                WAITCHAR3:      
026F   21 00 08               LD   hl,TIB   
0272   09                     ADD   hl,bc   
0273   36 0D                  LD   (hl),"\r"   ; store the crlf in textbuf
0275   23                     INC   hl   
0276   36 0A                  LD   (hl),"\n"   
0278   23                     INC   hl   ; ????
0279   03                     INC   bc   
027A   03                     INC   bc   
027B   CD AE 03               CALL   crlf   ; echo character to screen
027E   7B                     LD   a,E   ; if zero nesting append and ETX after \r
027F   B7                     OR   A   
0280   20 9F                  JR   nz,waitchar   
0282   36 03                  LD   (hl),$03   ; store end of text ETX in text buffer
0284   03                     INC   bc   
0285                WAITCHAR4:      
0285   ED 43 96 0B            LD   (vTIBPtr),bc   
0289   01 00 08               LD   bc,TIB   ; Instructions stored on heap at address HERe, we pressed enter
028C   0B                     DEC   bc   
028D                NEXT:        ; 
028D   03                     INC   bc   ;       Increment the IP
028E   0A                     LD   a,(bc)   ;       Get the next character and dispatch
028F   B7                     OR   a   ; is it NUL?
0290   28 0F                  JR   z,exit   
0292   FE 03                  CP   cTRL_c   
0294   28 15                  JR   z,etx   
0296   D6 21                  SUB   "!"   
0298   38 F3                  JR   c,NexT   
029A   6F                     LD   L,A   ;       Index into table
029B   26 0A                  LD   H,msb(opcodes)   ;       Start address of jump table
029D   6E                     LD   L,(hl)   ;       get low jump address
029E   26 04                  LD   H,msb(page4)   ;       Load H with the 1st page address
02A0   E9                     JP   (hl)   ;       Jump to routine
02A1                EXIT:        
02A1   03                     INC   bc   ; store offests into a table of bytes, smaller
02A2   50 59                  LD   de,bc   
02A4   CD D0 03               CALL   rpop   ; Restore Instruction pointer
02A7   44 4D                  LD   bc,hl   
02A9   EB                     EX   de,hl   
02AA   E9                     JP   (hl)   
02AB                ETX:         
02AB   21 00 F6               LD   hl,-DSTACK   ; check if stack pointer is underwater
02AE   39                     ADD   hl,SP   
02AF   30 03                  JR   nc,etx1   
02B1   31 00 0A               LD   SP,DSTACK   
02B4                ETX1:        
02B4   C3 04 02               JP   interpret   
02B7                INIT:        
02B7   DD 21 80 09            LD   ix,RSTACK   
02BB   FD 21 8D 02            LD   iy,NexT   ; iy provides a faster jump to NexT
02BF   21 82 0B               LD   hl,altVars   ; init altVars to 0
02C2   06 34                  LD   b,26 * 2   
02C4                INIT1:       
02C4   36 00                  LD   (hl),0   
02C6   23                     INC   hl   
02C7   10 FB                  DJNZ   init1   
02C9   21 FF FF               LD   hl,TRUE   ; hl = TRUE
02CC   22 A8 0B               LD   (vTrue),hl   
02CF   2B                     DEC   hl   ; hl = Unlimited
02D0   22 AA 0B               LD   (vUnlimited),hl   
02D3   21 00 0A               LD   hl,DSTACK   
02D6   22 A6 0B               LD   (vS0),hl   
02D9   21 41 00               LD   hl,65   
02DC   22 B4 0B               LD   (vLastDef),hl   
02DF   21 1E 0C               LD   hl,hEAP   
02E2   22 90 0B               LD   (vHeapPtr),hl   
02E5   21 B6 0B               LD   hl,VARS   ; init namespaces to 0 using LDIR
02E8   54 5D                  LD   de,hl   
02EA   13                     INC   de   
02EB   36 00                  LD   (hl),0   
02ED   01 68 00               LD   bc,VARS_SIZE   
02F0   ED B0                  LDIR      
02F2                INITOPS:      
02F2   21 9B 01               LD   hl,iOpcodes   
02F5   11 00 0A               LD   de,opcodes   
02F8   01 00 01               LD   bc,256   
02FB                INITOPS1:      
02FB   7E                     LD   a,(hl)   
02FC   23                     INC   hl   
02FD   CB 27                  SLA   A   
02FF   C8                     RET   z   
0300   38 09                  JR   c,initOps2   
0302   CB 3F                  SRL   A   
0304   4F                     LD   c,A   
0305   06 00                  LD   b,0   
0307   ED B0                  LDIR      
0309   18 F0                  JR   initOps1   
030B                INITOPS2:      
030B   CB 3F                  SRL   A   
030D   47                     LD   b,A   
030E   7E                     LD   a,(hl)   
030F   23                     INC   hl   
0310                INITOPS2A:      
0310   12                     LD   (de),A   
0311   13                     INC   de   
0312   10 FC                  DJNZ   initOps2a   
0314   18 E5                  JR   initOps1   
0316                LOOKUP:      
0316   D6 41                  SUB   "A"   
0318   18 02                  JR   lookup2   
031A                LOOKUP1:      
031A   D6 47                  SUB   "a" - 26   
031C                LOOKUP2:      
031C   87                     ADD   A,A   
031D   21 B6 0B               LD   hl,VARS   
0320   85                     ADD   A,l   
0321   6F                     LD   l,a   
0322   3E 00                  LD   a,0   
0324   8C                     ADC   a,h   
0325   67                     LD   h,a   
0326   AF                     XOR   a   
0327   B3                     OR   E   ; sets z flag if A-z
0328   C9                     RET      
0329                PRINTHEX:      
0329                             ; Display hl as a 16-bit number in hex.
0329   C5                     PUSH   bc   ; preserve the IP
032A   7C                     LD   a,h   
032B   CD 34 03               CALL   printhex2   
032E   7D                     LD   a,l   
032F   CD 34 03               CALL   printhex2   
0332   C1                     POP   bc   
0333   C9                     RET      
0334                PRINTHEX2:      
0334   4F                     LD   c,A   
0335   1F                     RRA      
0336   1F                     RRA      
0337   1F                     RRA      
0338   1F                     RRA      
0339   CD 3D 03               CALL   printhex3   
033C   79                     LD   a,c   
033D                PRINTHEX3:      
033D   E6 0F                  AND   0x0F   
033F   C6 90                  ADD   A,0x90   
0341   27                     DAA      
0342   CE 40                  ADC   A,0x40   
0344   27                     DAA      
0345   C3 85 00               JP   putchar   
0348                EDITDEF:      ; lookup up def based on number
0348   E1                     POP   hl   ; pop ret address
0349   E3                     EX   (SP),hl   ; swap with TOS
034A   7D                     LD   a,l   
034B   08                     EX   AF,AF'   
034C   7D                     LD   a,l   
034D   CD 16 03               CALL   lookup   
0350   5E                     LD   e,(hl)   
0351   23                     INC   hl   
0352   56                     LD   d,(hl)   
0353   7A                     LD   a,D   
0354   B3                     OR   E   
0355   21 00 08               LD   hl,TIB   
0358   28 14                  JR   z,editDef3   
035A   3E 3A                  LD   a,":"   
035C   CD DB 03               CALL   writechar   
035F   08                     EX   AF,AF'   
0360   CD DB 03               CALL   writechar   
0363   18 01                  JR   editDef2   
0365                EDITDEF1:      
0365   13                     INC   de   
0366                EDITDEF2:      
0366   1A                     LD   a,(de)   
0367   CD DB 03               CALL   writechar   
036A   FE 3B                  CP   ";"   
036C   20 F7                  JR   nz,editDef1   
036E                EDITDEF3:      
036E   11 00 08               LD   de,TIB   
0371   B7                     OR   A   
0372   ED 52                  SBC   hl,de   
0374   22 96 0B               LD   (vTIBPtr),hl   
0377   FD E9                  JP   (iy)   
0379                             ; **************************************************************************
0379                             ; calculate nesting value
0379                             ; A is char to be tested,
0379                             ; E is the nesting value (initially 0)
0379                             ; E is increased by ( and [
0379                             ; E is decreased by ) and ]
0379                             ; E has its bit 7 toggled by `
0379                             ; limited to 127 levels
0379                             ; **************************************************************************
0379                NESTING:      
0379   FE 60                  CP   "`"   
037B   20 05                  JR   nz,nesting1   
037D   3E 80                  LD   a,$80   
037F   AB                     XOR   e   
0380   5F                     LD   e,a   
0381   C9                     RET      
0382                NESTING1:      
0382   FE 3A                  CP   ":"   
0384   28 0C                  JR   z,nesting2   
0386   FE 5B                  CP   "["   
0388   28 08                  JR   z,nesting2   
038A   FE 7B                  CP   "{"   
038C   28 04                  JR   z,nesting2   
038E   FE 28                  CP   "("   
0390   20 02                  JR   nz,nesting3   
0392                NESTING2:      
0392   1C                     INC   E   
0393   C9                     RET      
0394                NESTING3:      
0394   FE 3B                  CP   ";"   
0396   28 0B                  JR   z,nesting4   
0398   FE 5D                  CP   "]"   
039A   28 07                  JR   z,nesting4   
039C   FE 7D                  CP   "}"   
039E   28 03                  JR   z,nesting4   
03A0   FE 29                  CP   ")"   
03A2   C0                     RET   nz   
03A3                NESTING4:      
03A3   1D                     DEC   E   
03A4   C9                     RET      
03A5                PROMPT:      
03A5   CD B5 03               CALL   printStr   
03A8   0D 0A 3E 20 00         .CSTR   "\r\n> "   
03AD   C9                     RET      
03AE                CRLF:        
03AE   CD B5 03               CALL   printStr   
03B1   0D 0A 00               .CSTR   "\r\n"   
03B4   C9                     RET      
03B5                PRINTSTR:      
03B5   E3                     EX   (SP),hl   ; swap			
03B6   CD C0 03               CALL   putStr   
03B9   23                     INC   hl   ; inc past null
03BA   E3                     EX   (SP),hl   ; put it back	
03BB   C9                     RET      
03BC                PUTSTR0:      
03BC   CD 85 00               CALL   putchar   
03BF   23                     INC   hl   
03C0                PUTSTR:      
03C0   7E                     LD   a,(hl)   
03C1   B7                     OR   A   
03C2   20 F8                  JR   nz,putStr0   
03C4   C9                     RET      
03C5                RPUSH:       
03C5   DD 2B                  DEC   ix   
03C7   DD 74 00               LD   (ix+0),h   
03CA   DD 2B                  DEC   ix   
03CC   DD 75 00               LD   (ix+0),l   
03CF   C9                     RET      
03D0                RPOP:        
03D0   DD 6E 00               LD   L,(ix+0)   
03D3   DD 23                  INC   ix   
03D5   DD 66 00               LD   H,(ix+0)   
03D8   DD 23                  INC   ix   
03DA                RPOP2:       
03DA   C9                     RET      
03DB                WRITECHAR:      
03DB   77                     LD   (hl),A   
03DC   23                     INC   hl   
03DD   C3 85 00               JP   putchar   
03E0                ENTER:       
03E0   60 69                  LD   hl,bc   
03E2   CD C5 03               CALL   rpush   ; save Instruction Pointer
03E5   C1                     POP   bc   
03E6   0B                     DEC   bc   
03E7   FD E9                  JP   (iy)   
03E9                LOOPVAR:      
03E9   7B                     LD   a,e   
03EA   DD 85                  ADD   a,ixl   
03EC   6F                     LD   l,a   
03ED   3E 00                  LD   a,0   
03EF   DD 8C                  ADC   a,ixh   
03F1   67                     LD   h,a   
03F2   C3 A9 04               JP   var1   
03F5                             ; **********************************************************************			
03F5                             ; Page 4 primitive routines
03F5                             ; **********************************************************************
03F5                          ALIGN   $100   
0400                PAGE4:       
0400                DQUOTE_:      
0400                QUESTION_:      
0400                LBRACE_:      
0400                RBRACE_:      
0400                UNDERSCORE_:      
0400   FD E9                  JP   (iy)   
0402                AMPER_:      
0402                AND_:        
0402   D1                     POP   de   ;     bitwise and the top 2 elements of the stack
0403   E1                     POP   hl   ; 
0404   7B                     LD   A,E   ; 
0405   A5                     AND   L   ; 
0406   6F                     LD   L,A   ; 
0407   7A                     LD   A,D   ; 
0408   A4                     AND   H   ; 
0409                AND1:        
0409   67                     LD   H,A   ; 
040A   E5                     PUSH   hl   ; 
040B   FD E9                  JP   (iy)   ; 
040D                PIPE_:       
040D                OR_:         
040D   D1                     POP   de   ; bitwise or the top 2 elements of the stack
040E   E1                     POP   hl   
040F   7B                     LD   A,E   
0410   B5                     OR   L   
0411   6F                     LD   L,A   
0412   7A                     LD   A,D   
0413   B4                     OR   H   
0414   18 F3                  JR   and1   
0416                CARET_:      
0416                XOR_:        
0416   D1                     POP   de   ; bitwise xor the top 2 elements of the stack
0417   E1                     POP   hl   
0418   7B                     LD   A,E   
0419   AD                     XOR   L   
041A   6F                     LD   L,A   
041B   7A                     LD   A,D   
041C   AC                     XOR   H   
041D   18 EA                  JR   and1   
041F                PLUS_:       ; add the top 2 members of the stack
041F                ADD_:        
041F   D1                     POP   de   
0420   E1                     POP   hl   
0421   19                     ADD   hl,de   
0422   E5                     PUSH   hl   
0423   C3 ED 07               JP   carry   
0426                CALL_:       
0426   0A                     LD   a,(bc)   
0427   CD 16 03               CALL   lookup   
042A   5E                     LD   e,(hl)   
042B   23                     INC   hl   
042C   56                     LD   d,(hl)   
042D   C3 2D 06               JP   go1   
0430                DOT_:        
0430   E1                     POP   hl   
0431   CD 2F 07               CALL   printDec   
0434                DOT2:        
0434   3E 20                  LD   a," "   
0436   CD 85 00               CALL   putchar   
0439   FD E9                  JP   (iy)   
043B                COMMA_:      ; print hexadecimal
043B                HDOT_:       
043B   E1                     POP   hl   
043C   CD 29 03               CALL   printhex   
043F   18 F3                  JR   dot2   
0441                BSLASH_:      
0441                DROP_:       
0441   E1                     POP   hl   
0442   FD E9                  JP   (iy)   
0444                HASH_:       
0444                DUP_:        
0444   E1                     POP   hl   ; Duplicate the top member of the stack
0445   E5                     PUSH   hl   
0446   E5                     PUSH   hl   
0447   FD E9                  JP   (iy)   
0449                             ; $ swap                        ; a b -- b a Swap the top 2 elements of the stack
0449                DOLLAR_:      
0449                SWAP_:       
0449   E1                     POP   hl   
044A   E3                     EX   (SP),hl   
044B   E5                     PUSH   hl   
044C   FD E9                  JP   (iy)   
044E                PERCENT_:      
044E                OVER_:       
044E   E1                     POP   hl   ; Duplicate 2nd element of the stack
044F   D1                     POP   de   
0450   D5                     PUSH   de   
0451   E5                     PUSH   hl   
0452   D5                     PUSH   de   ; and push it to top of stack
0453   FD E9                  JP   (iy)   
0455                SEMI_:       
0455                RET_:        
0455   CD D0 03               CALL   rpop   ; Restore Instruction pointer
0458   44 4D                  LD   bc,hl   
045A   FD E9                  JP   (iy)   
045C                TILDE_:      
045C                NOT:         
045C   E1                     POP   hl   
045D   7D                     LD   a,l   
045E   2F                     CPL      
045F   6F                     LD   l,a   
0460   7C                     LD   a,h   
0461   2F                     CPL      
0462   67                     LD   h,a   
0463   E5                     PUSH   hl   
0464   FD E9                  JP   (iy)   
0466                BANG_:       ; Store the value at the address placed on the top of the stack
0466                STORE_:      
0466                ASSIGN:      
0466   D1                     POP   de   ; discard last accessed value
0467   D1                     POP   de   ; de = new value
0468                ASSIGN0:      
0468   2A A0 0B               LD   hl,(vPointer)   ; hl = pointer
046B                ASSIGN1:      
046B   73                     LD   (hl),e   ; ignore byte mode to allow assigning to vByteMode
046C   23                     INC   hl   
046D   72                     LD   (hl),d   
046E   FD E9                  JP   (iy)   
0470                MINUS_:      ; Subtract the value 2nd on stack from top of stack
0470                SUB_:        
0470   03                     INC   bc   ; check if sign of a number
0471   0A                     LD   a,(bc)   
0472   0B                     DEC   bc   
0473   FE 30                  CP   "0"   
0475   38 05                  JR   c,sub1   
0477   FE 3A                  CP   "9"+1   
0479   DA FF 06               JP   c,num   
047C                SUB1:        
047C   D1                     POP   de   ; 
047D   E1                     POP   hl   ;      Entry point for INVert
047E                SUB2:        
047E   A7                     AND   A   ;      Entry point for NEGate
047F   ED 52                  SBC   hl,de   ; 
0481   E5                     PUSH   hl   ; 
0482   C3 ED 07               JP   carry   
0485                             ; 5
0485                EQ_:         
0485   E1                     POP   hl   
0486   D1                     POP   de   
0487   B7                     OR   a   ; reset the carry flag
0488   ED 52                  SBC   hl,de   ; only equality sets hl=0 here
048A   28 06                  JR   z,true_   
048C                FALSE_:      
048C   21 00 00               LD   hl,FALSE   
048F   E5                     PUSH   hl   
0490   FD E9                  JP   (iy)   
0492                TRUE_:       
0492   21 FF FF               LD   hl,TRUE   
0495   E5                     PUSH   hl   
0496   FD E9                  JP   (iy)   
0498                GT_:         
0498   E1                     POP   hl   
0499   D1                     POP   de   
049A   18 02                  JR   lt1_   
049C                LT_:         
049C   D1                     POP   de   
049D   E1                     POP   hl   
049E                LT1_:        
049E   B7                     OR   a   ; reset the carry flag
049F   ED 52                  SBC   hl,de   ; only equality sets hl=0 here
04A1   38 EF                  JR   c,true_   
04A3   18 E7                  JR   false_   
04A5                VAR_:        
04A5   0A                     LD   a,(bc)   
04A6   CD 1A 03               CALL   lookup1   
04A9                VAR1:        
04A9   22 A0 0B               LD   (vPointer),hl   
04AC   16 00                  LD   d,0   
04AE   5E                     LD   e,(hl)   
04AF   3A 84 0B               LD   a,(vByteMode)   
04B2   3C                     INC   a   ; is it byte?
04B3   28 02                  JR   z,var2   
04B5   23                     INC   hl   
04B6   56                     LD   d,(hl)   
04B7                VAR2:        
04B7   D5                     PUSH   de   
04B8   FD E9                  JP   (iy)   
04BA                GRAVE_:      
04BA                STR:         
04BA   03                     INC   bc   
04BB                STR1:        
04BB   0A                     LD   a,(bc)   
04BC   03                     INC   bc   
04BD   FE 60                  CP   "`"   ; ` is the string terminator
04BF   28 05                  JR   z,str2   
04C1   CD 85 00               CALL   putchar   
04C4   18 F5                  JR   str1   
04C6                STR2:        
04C6   0B                     DEC   bc   
04C7   FD E9                  JP   (iy)   
04C9                LBRACK_:      
04C9                ARRDEF:      
04C9   21 00 00               LD   hl,0   
04CC   39                     ADD   hl,sp   ; save
04CD   CD C5 03               CALL   rpush   
04D0   FD E9                  JP   (iy)   
04D2                AT_:         
04D2                ARRACCESS:      
04D2   E1                     POP   hl   ; hl = index
04D3   D1                     POP   de   ; de = array
04D4   3A 84 0B               LD   a,(vByteMode)   ; a = data width
04D7   3C                     INC   a   
04D8   28 01                  JR   z,arrAccess1   
04DA                ARRACCESS0:      
04DA   29                     ADD   hl,hl   ; if data width = 2 then double
04DB                ARRACCESS1:      
04DB   19                     ADD   hl,de   ; add addr
04DC   C3 A9 04               JP   var1   
04DF                LPAREN_:      
04DF   C3 77 07               JP   begin   
04E2                RPAREN_:      
04E2   C3 B1 07               JP   again   
04E5                NUM_:        
04E5   C3 FF 06               JP   num   
04E8                COLON_:      
04E8   C3 D2 06               JP   def   
04EB                RBRACK_:      
04EB   C3 B4 05               JP   arrEnd   
04EE                QUOTE_:      ; Discard the top member of the stack
04EE   18 41                  JR   hex   
04F0                STAR_:       
04F0   18 5C                  JR   mul   
04F2                SLASH_:      
04F2                             ; jr div
04F2                             ;*******************************************************************
04F2                             ; Page 5 primitive routines
04F2                             ;*******************************************************************
04F2                             ;falls through
04F2                SLASH:       
04F2   03                     INC   bc   
04F3   0A                     LD   a,(bc)   
04F4   FE 2F                  CP   "/"   
04F6   CA F7 07               JP   z,comment   
04F9   FE 61                  CP   "a"   
04FB   38 1D                  JR   c,alt1   
04FD   FE 7B                  CP   "z"+1   
04FF   30 2D                  JR   nc,alt2   
0501   FE 69                  CP   "i"   
0503   1E 00                  LD   e,0   
0505   CA E9 03               JP   z,loopVar   
0508   FE 6A                  CP   "j"   
050A   1E 08                  LD   e,8   
050C   CA E9 03               JP   z,loopVar   
050F   D6 61                  SUB   "a"   
0511   87                     ADD   A,A   
0512   21 82 0B               LD   hl,altVars   
0515   85                     ADD   a,l   
0516   6F                     LD   l,a   
0517   C3 A9 04               JP   var1   
051A                ALT1:        
051A   FE 41                  CP   "A"   
051C   38 10                  JR   c,alt2   
051E   FE 5B                  CP   "Z"+1   
0520   30 0C                  JR   nc,alt2   
0522   21 5E 0A               LD   hl,altcodes   
0525   D6 41                  SUB   "A"   
0527   85                     ADD   a,l   
0528   6F                     LD   l,a   
0529   7E                     LD   a,(hl)   ;       get low jump address
052A   26 06                  LD   h,msb(page6)   
052C   6F                     LD   L,A   
052D   E9                     JP   (hl)   ;       Jump to routine
052E                ALT2:        
052E   0B                     DEC   bc   
052F   18 3D                  JR   div   
0531                HEX:         
0531   21 00 00               LD   hl,0   ; clear hl to accept the number
0534                HEX1:        
0534   03                     INC   bc   
0535   0A                     LD   a,(bc)   ; Get the character which is a numeral
0536   CB 77                  BIT   6,A   ; is it uppercase alpha?
0538   28 02                  JR   z,hex2   ; no a decimal
053A   D6 07                  SUB   7   ; sub 7  to make $A - $F
053C                HEX2:        
053C   D6 30                  SUB   $30   ; Form decimal digit
053E   DA 21 07               JP   c,num2   
0541   FE 10                  CP   $0F+1   
0543   D2 21 07               JP   nc,num2   
0546   29                     ADD   hl,hl   ; 2X ; Multiply digit(s) in hl by 16
0547   29                     ADD   hl,hl   ; 4X
0548   29                     ADD   hl,hl   ; 8X
0549   29                     ADD   hl,hl   ; 16X
054A   85                     ADD   A,l   ; add into bottom of hl
054B   6F                     LD   L,A   
054C   18 E6                  JR   hex1   
054E                MUL:         
054E   D1                     POP   de   ; de = 2nd factor
054F   E1                     POP   hl   
0550   C5                     PUSH   bc   ; Preserve the IP
0551   44                     LD   b,h   ; bc = 2nd value
0552   4D                     LD   c,l   
0553   21 00 00               LD   hl,0   
0556   3E 10                  LD   A,16   
0558                MUL2:        
0558   29                     ADD   hl,hl   
0559   CB 13                  RL   e   
055B   CB 12                  RL   d   
055D   30 04                  JR   nc,$+6   
055F   09                     ADD   hl,bc   
0560   30 01                  JR   nc,$+3   
0562   13                     INC   de   
0563   3D                     DEC   A   
0564   20 F2                  JR   nz,mul2   
0566   C1                     POP   bc   ; Restore the IP
0567   E5                     PUSH   hl   ; Put the product on the stack - stack bug fixed 2/12/21
0568   ED 53 A4 0B            LD   (vRemain),de   
056C   FD E9                  JP   (iy)   
056E                DIV:         
056E   60 69                  LD   hl,bc   ; hl = IP
0570   C1                     POP   bc   ; bc = denominator
0571   E3                     EX   (sp),hl   ; save IP, hl = numerator
0572   7C                     LD   a,h   
0573   A8                     XOR   b   
0574   F5                     PUSH   af   
0575   A8                     XOR   b   
0576   F2 7F 05               JP   p,absbc   
0579                             ;abshl
0579   AF                     XOR   a   
057A   95                     SUB   l   
057B   6F                     LD   l,a   
057C   9F                     SBC   a,a   
057D   94                     SUB   h   
057E   67                     LD   h,a   
057F                ABSBC:       
057F   A8                     XOR   b   
0580   F2 89 05               JP   p,$+9   
0583   AF                     XOR   a   
0584   91                     SUB   c   
0585   4F                     LD   c,a   
0586   9F                     SBC   a,a   
0587   90                     SUB   b   
0588   47                     LD   b,a   
0589   29                     ADD   hl,hl   
058A   3E 0F                  LD   a,15   
058C   11 00 00               LD   de,0   
058F   EB                     EX   de,hl   
0590   18 04                  JR   jumpin   
0592                LOOP1:       
0592   09                     ADD   hl,bc   ;--
0593                LOOP2:       
0593   3D                     DEC   a   ;4
0594   28 0D                  JR   z,EndSDiv   ;12|7
0596                JUMPIN:      
0596   CB 23                  SLA   e   ;8
0598   CB 12                  RL   d   ;8
059A   ED 6A                  ADC   hl,hl   ;15
059C   ED 42                  SBC   hl,bc   ;15
059E   38 F2                  JR   c,loop1   ;23-2b
05A0   1C                     INC   e   ;--
05A1   18 F0                  JR   Loop2   ;--
05A3                ENDSDIV:      
05A3   F1                     POP   af   
05A4   F2 AD 05               JP   p,div10   
05A7   AF                     XOR   a   
05A8   93                     SUB   e   
05A9   5F                     LD   e,a   
05AA   9F                     SBC   a,a   
05AB   92                     SUB   d   
05AC   57                     LD   d,a   
05AD                DIV10:       
05AD   C1                     POP   bc   
05AE   D5                     PUSH   de   ; quotient
05AF   22 A4 0B               LD   (vRemain),hl   ; remainder
05B2   FD E9                  JP   (iy)   
05B4                ARREND:      
05B4   ED 43 34 0B            LD   (vTemp1),bc   ; save IP
05B8   CD D0 03               CALL   rpop   
05BB   22 36 0B               LD   (vTemp2),hl   ; save old SP
05BE   54 5D                  LD   de,hl   ; de = hl = old SP
05C0   B7                     OR   a   
05C1   ED 72                  SBC   hl,sp   ; hl = array count (items on stack)
05C3   CB 3C                  SRL   h   ; num items = num bytes / 2
05C5   CB 1D                  RR   l   
05C7   44 4D                  LD   bc,hl   ; bc = count
05C9   2A 90 0B               LD   hl,(vHeapPtr)   ; hl = array[-4]
05CC   71                     LD   (hl),c   ; write num items in length word
05CD   23                     INC   hl   
05CE   70                     LD   (hl),b   
05CF   23                     INC   hl   ; hl = array[0], bc = count
05D0                             ; de = old SP, hl = array[0], bc = count
05D0   18 11                  JR   arrayEnd2   
05D2                ARRAYEND1:      
05D2   0B                     DEC   bc   ; dec items count
05D3   1B                     DEC   de   
05D4   1B                     DEC   de   
05D5   1A                     LD   a,(de)   ; a = lsb of stack item
05D6   77                     LD   (hl),a   ; write lsb of array item
05D7   23                     INC   hl   ; move to msb of array item
05D8   3A 84 0B               LD   a,(vByteMode)   ; vByteMode=1?
05DB   3C                     INC   a   
05DC   28 05                  JR   z,arrayEnd2   
05DE   13                     INC   de   
05DF   1A                     LD   a,(de)   ; a = msb of stack item
05E0   1B                     DEC   de   
05E1   77                     LD   (hl),a   ; write msb of array item
05E2   23                     INC   hl   ; move to next word in array
05E3                ARRAYEND2:      
05E3   79                     LD   a,c   ; if not zero loop
05E4   B0                     OR   b   
05E5   20 EB                  JR   nz,arrayEnd1   
05E7   EB                     EX   de,hl   ; de = end of array
05E8   2A 36 0B               LD   hl,(vTemp2)   
05EB   F9                     LD   sp,hl   ; SP = old SP
05EC   2A 90 0B               LD   hl,(vHeapPtr)   ; de = array[-2]
05EF   23                     INC   hl   
05F0   23                     INC   hl   
05F1   E5                     PUSH   hl   ; return array[0]
05F2   ED 53 90 0B            LD   (vHeapPtr),de   ; move heap* to end of array
05F6   ED 4B 34 0B            LD   bc,(vTemp1)   ; restore IP
05FA   FD E9                  JP   (iy)   
05FC                             ; **************************************************************************
05FC                             ; Page 6 Alt primitives
05FC                             ; **************************************************************************
05FC                          ALIGN   $100   
0600                PAGE6:       
0600                ARRSIZE_:      
0600                ARRSIZE:      
0600   E1                     POP   hl   
0601   2B                     DEC   hl   ; msb size
0602   56                     LD   d,(hl)   
0603   2B                     DEC   hl   ; lsb size
0604   5E                     LD   e,(hl)   
0605   D5                     PUSH   de   
0606                ANOP_:       
0606   FD E9                  JP   (iy)   
0608                BMODE_:      
0608   3A 84 0B               LD   a,(vByteMode)   
060B   2F                     CPL      
060C   32 84 0B               LD   (vByteMode),a   
060F   32 85 0B               LD   (vByteMode+1),a   
0612   FD E9                  JP   (iy)   
0614                EMIT_:       
0614   E1                     POP   hl   
0615   7D                     LD   a,l   
0616   CD 85 00               CALL   putchar   
0619   FD E9                  JP   (iy)   
061B                EXEC_:       
061B   CD 20 06               CALL   exec1   
061E   FD E9                  JP   (iy)   
0620                EXEC1:       
0620   E1                     POP   hl   
0621   E3                     EX   (SP),hl   
0622   E9                     JP   (hl)   
0623                KEY_:        
0623   CD 81 00               CALL   getchar   
0626   26 00                  LD   H,0   
0628   6F                     LD   L,A   
0629   E5                     PUSH   hl   
062A   FD E9                  JP   (iy)   
062C                GO_:         ;\^
062C   D1                     POP   de   
062D                GO1:         
062D   7A                     LD   a,D   ; skip if destination address is null
062E   B3                     OR   E   
062F   28 0E                  JR   z,go3   
0631   60 69                  LD   hl,bc   
0633   03                     INC   bc   ; read next char from source
0634   0A                     LD   a,(bc)   ; if ; to tail call optimise
0635   FE 3B                  CP   ";"   ; by jumping to rather than calling destination
0637   28 03                  JR   z,go2   
0639   CD C5 03               CALL   rpush   ; save Instruction Pointer
063C                GO2:         
063C   42 4B                  LD   bc,de   
063E   0B                     DEC   bc   
063F                GO3:         
063F   FD E9                  JP   (iy)   
0641                INPORT_:      ; \<
0641   E1                     POP   hl   
0642   79                     LD   a,c   
0643   4D                     LD   c,l   
0644   ED 68                  IN   L,(c)   
0646   26 00                  LD   H,0   
0648   4F                     LD   c,A   
0649   E5                     PUSH   hl   
064A   FD E9                  JP   (iy)   
064C                NEWLN_:      
064C   CD AE 03               CALL   crlf   
064F   FD E9                  JP   (iy)   
0651                OUTPORT_:      
0651   E1                     POP   hl   
0652   59                     LD   e,c   
0653   4D                     LD   c,l   
0654   E1                     POP   hl   
0655   ED 69                  OUT   (c),l   
0657   4B                     LD   c,E   
0658   FD E9                  JP   (iy)   
065A                             ; shiftLeft
065A                             ; value count
065A                SHL_:        
065A                SHIFTLEFT:      
065A   D1                     POP   de   ; de = count
065B   E1                     POP   hl   ; hl = value
065C   C5                     PUSH   bc   ; save IP
065D   7B                     LD   a,e   
065E   B7                     OR   a   
065F   28 04                  JR   z,shiftLeft2   
0661   43                     LD   b,e   
0662                SHIFTLEFT1:      
0662   29                     ADD   hl,hl   ; left shift hl
0663   10 FD                  DJNZ   shiftLeft1   
0665                SHIFTLEFT2:      
0665   C1                     POP   bc   
0666   E5                     PUSH   hl   ; restore IP
0667   FD E9                  JP   (iy)   
0669                SHR_:        
0669   D1                     POP   de   ; de = count
066A   E1                     POP   hl   ; hl = value
066B   C5                     PUSH   bc   ; save IP
066C   7B                     LD   a,e   
066D   B7                     OR   a   
066E   28 07                  JR   z,shiftRight2   
0670   43                     LD   b,e   
0671                SHIFTRIGHT1:      
0671   CB 3C                  SRL   h   
0673   CB 1D                  RR   l   
0675   10 FA                  DJNZ   shiftRight1   
0677                SHIFTRIGHT2:      
0677   C1                     POP   bc   
0678   E5                     PUSH   hl   ; restore IP
0679   FD E9                  JP   (iy)   
067B                             ;/D -> /UD depth            depth
067B                             ;/L -> /UE edit def         editDef
067B                             ;/P -> /UP prompt           prompt
067B                             ;/T -> /US print stack      printStk
067B                UTILITY_:      
067B                UTILITY:      
067B   03                     INC   bc   
067C   0A                     LD   a,(bc)   
067D   FE 44                  CP   "D"   
067F   20 12                  JR   nz,utility1   
0681                             ; depth:
0681   21 00 00               LD   hl,0   
0684   39                     ADD   hl,SP   
0685   EB                     EX   de,hl   
0686   21 00 0A               LD   hl,DSTACK   
0689   B7                     OR   A   
068A   ED 52                  SBC   hl,de   
068C   CB 3C                  SRL   h   
068E   CB 1D                  RR   l   
0690   E5                     PUSH   hl   
0691   FD E9                  JP   (iy)   ; 
0693                UTILITY1:      
0693   FE 45                  CP   "E"   
0695   C3 48 03               JP   editDef   
0698   FE 50                  CP   "P"   
069A   20 09                  JR   nz,utility2   
069C   CD A5 03               CALL   prompt   
069F   FD E9                  JP   (iy)   
06A1   FE 53                  CP   "S"   
06A3   20 1B                  JR   nz,utility3   
06A5                UTILITY2:      
06A5                             ; printStk:
06A5   CD E0 03               CALL   ENTER   
06A8   60 3D 3E 20 60 2F 73 32 2D 2F 55 44 31 2D 28 23 2C 32 2D 29 5C 2F 4E 00 .CSTR   "`=> `/s2-/UD1-(#,2-)\\/N"   
06C0                UTILITY3:      
06C0   FD E9                  JP   (iy)   
06C2                WHILE_:      
06C2                WHILE:       
06C2   E1                     POP   hl   
06C3   7D                     LD   a,l   
06C4   B4                     OR   h   
06C5   20 09                  JR   nz,while2   
06C7   DD 4E 06               LD   c,(ix+6)   ; IP = )
06CA   DD 46 07               LD   b,(ix+7)   
06CD                             ; inc bc                      ; IP = one after )
06CD   C3 E6 07               JP   loopEnd4   
06D0                WHILE2:      
06D0   FD E9                  JP   (iy)   
06D2                             ;*******************************************************************
06D2                             ; Page 5 primitive routines continued
06D2                             ;*******************************************************************
06D2                DEF:         ; create a colon definition
06D2   03                     INC   bc   
06D3   0A                     LD   A,(bc)   ; Get the next character
06D4   FE 3A                  CP   ":"   ; is it anonymouse
06D6   20 08                  JR   nz,def0   
06D8   03                     INC   bc   
06D9   ED 5B 90 0B            LD   de,(vHeapPtr)   ; return start of definition
06DD   D5                     PUSH   de   
06DE   18 0E                  JR   def1   
06E0                DEF0:        
06E0   32 B4 0B               LD   (vLastDef),A   
06E3   CD 16 03               CALL   lookup   
06E6   ED 5B 90 0B            LD   de,(vHeapPtr)   ; start of defintion
06EA   73                     LD   (hl),E   ; Save low byte of address in cFA
06EB   23                     INC   hl   
06EC   72                     LD   (hl),D   ; Save high byte of address in cFA+1
06ED   03                     INC   bc   
06EE                DEF1:        ; Skip to end of definition
06EE   0A                     LD   a,(bc)   ; Get the next character
06EF   03                     INC   bc   ; Point to next character
06F0   12                     LD   (de),A   
06F1   13                     INC   de   
06F2   FE 3B                  CP   ";"   ; Is it a semicolon
06F4   28 02                  JR   z,def2   ; end the definition
06F6   18 F6                  JR   def1   ; get the next element
06F8                DEF2:        
06F8   0B                     DEC   bc   
06F9                DEF3:        
06F9   ED 53 90 0B            LD   (vHeapPtr),de   ; bump heap ptr to after definiton
06FD   FD E9                  JP   (iy)   
06FF                NUM:         
06FF   21 00 00               LD   hl,$0000   ; clear hl to accept the number
0702   0A                     LD   a,(bc)   ; Get numeral or -
0703   FE 2D                  CP   "-"   
0705   20 01                  JR   nz,num0   
0707   03                     INC   bc   ; move to next char, no flags affected
0708                NUM0:        
0708   08                     EX   af,af'   ; save zero flag = 0 for later
0709                NUM1:        
0709   0A                     LD   a,(bc)   ; read digit
070A   D6 30                  SUB   "0"   ; less than 0?
070C   38 13                  JR   c,num2   ; not a digit, exit loop
070E   FE 0A                  CP   10   ; greater that 9?
0710   30 0F                  JR   nc,num2   ; not a digit, exit loop
0712   03                     INC   bc   ; inc IP
0713   54 5D                  LD   de,hl   ; multiply hl * 10
0715   29                     ADD   hl,hl   
0716   29                     ADD   hl,hl   
0717   19                     ADD   hl,de   
0718   29                     ADD   hl,hl   
0719   85                     ADD   a,l   ; add digit in a to hl
071A   6F                     LD   l,a   
071B   3E 00                  LD   a,0   
071D   8C                     ADC   a,h   
071E   67                     LD   h,a   
071F   18 E8                  JR   num1   
0721                NUM2:        
0721   0B                     DEC   bc   
0722   08                     EX   af,af'   ; restore zero flag
0723   20 07                  JR   nz,num3   
0725   EB                     EX   de,hl   ; negate the value of hl
0726   21 00 00               LD   hl,0   
0729   B7                     OR   a   ; jump to sub2
072A   ED 52                  SBC   hl,de   
072C                NUM3:        
072C   E5                     PUSH   hl   ; Put the number on the stack
072D   FD E9                  JP   (iy)   ; and process the next character
072F                             ;*******************************************************************
072F                             ; Subroutines
072F                             ;*******************************************************************
072F                             ; hl = value
072F                PRINTDEC:      
072F   CB 7C                  BIT   7,h   
0731   28 0B                  JR   z,printDec2   
0733   3E 2D                  LD   a,"-"   
0735   CD 85 00               CALL   putchar   
0738   AF                     XOR   a   
0739   95                     SUB   l   
073A   6F                     LD   l,a   
073B   9F                     SBC   a,a   
073C   94                     SUB   h   
073D   67                     LD   h,a   
073E                PRINTDEC2:      
073E   C5                     PUSH   bc   
073F   0E 00                  LD   c,0   ; leading zeros flag = false
0741   11 F0 D8               LD   de,-10000   
0744   CD 60 07               CALL   printDec4   
0747   11 18 FC               LD   de,-1000   
074A   CD 60 07               CALL   printDec4   
074D   11 9C FF               LD   de,-100   
0750   CD 60 07               CALL   printDec4   
0753   1E F6                  LD   e,-10   
0755   CD 60 07               CALL   printDec4   
0758   0C                     INC   c   ; flag = true for at least digit
0759   1E FF                  LD   e,-1   
075B   CD 60 07               CALL   printDec4   
075E   C1                     POP   bc   
075F   C9                     RET      
0760                PRINTDEC4:      
0760   06 2F                  LD   b,"0"-1   
0762                PRINTDEC5:      
0762   04                     INC   b   
0763   19                     ADD   hl,de   
0764   38 FC                  JR   c,printDec5   
0766   ED 52                  SBC   hl,de   
0768   3E 30                  LD   a,"0"   
076A   B8                     CP   b   
076B   20 05                  JR   nz,printDec6   
076D   AF                     XOR   a   
076E   B1                     OR   c   
076F   C8                     RET   z   
0770   18 01                  JR   printDec7   
0772                PRINTDEC6:      
0772   0C                     INC   c   
0773                PRINTDEC7:      
0773   78                     LD   a,b   
0774   C3 85 00               JP   putchar   
0777                             ; (val -- )
0777                BEGIN:       
0777                LOOPSTART:      
0777   ED 43 34 0B            LD   (vTemp1),bc   ; save start
077B   1E 01                  LD   e,1   ; skip to loop end, nesting = 1
077D                LOOPSTART1:      
077D   03                     INC   bc   
077E   0A                     LD   a,(bc)   
077F   CD 79 03               CALL   nesting   ; affects zero flag
0782   20 F9                  JR   nz,loopStart1   
0784   D1                     POP   de   ; de = limit
0785   7B                     LD   a,e   ; is it zero?
0786   B2                     OR   d   
0787   20 07                  JR   nz,loopStart2   
0789   1B                     DEC   de   ; de = TRUE
078A   ED 53 8A 0B            LD   (vElse),de   
078E   18 1F                  JR   loopStart4   ; yes continue after skip
0790                LOOPSTART2:      
0790   3E 02                  LD   a,2   ; is it TRUE
0792   83                     ADD   a,e   
0793   82                     ADD   a,d   
0794   20 03                  JR   nz,loopStart3   
0796   11 01 00               LD   de,1   ; yes make it 1
0799                LOOPSTART3:      
0799   60 69                  LD   hl,bc   
079B   CD C5 03               CALL   rpush   ; rpush loop end
079E   0B                     DEC   bc   ; IP points to ")"
079F   2A 34 0B               LD   hl,(vTemp1)   ; restore start
07A2   CD C5 03               CALL   rpush   ; rpush start
07A5   EB                     EX   de,hl   ; hl = limit
07A6   CD C5 03               CALL   rpush   ; rpush limit
07A9   21 FF FF               LD   hl,-1   ; hl = count = -1
07AC   CD C5 03               CALL   rpush   ; rpush count
07AF                LOOPSTART4:      
07AF   FD E9                  JP   (iy)   
07B1                AGAIN:       
07B1                LOOPEND:      
07B1   DD 5E 02               LD   e,(ix+2)   ; de = limit
07B4   DD 56 03               LD   d,(ix+3)   
07B7   7B                     LD   a,e   ; a = lsb(limit)
07B8   B2                     OR   d   ; if limit 0 exit loop
07B9   28 2B                  JR   z,loopEnd4   
07BB   13                     INC   de   ; is limit -2
07BC   13                     INC   de   
07BD   7B                     LD   a,e   ; a = lsb(limit)
07BE   B2                     OR   d   ; if limit 0 exit loop
07BF   28 09                  JR   z,loopEnd2   ; yes, loop again
07C1   1B                     DEC   de   
07C2   1B                     DEC   de   
07C3   1B                     DEC   de   
07C4   DD 73 02               LD   (ix+2),e   
07C7   DD 72 03               LD   (ix+3),d   
07CA                LOOPEND2:      
07CA   DD 5E 00               LD   e,(ix+0)   ; inc counter
07CD   DD 56 01               LD   d,(ix+1)   
07D0   13                     INC   de   
07D1   DD 73 00               LD   (ix+0),e   
07D4   DD 72 01               LD   (ix+1),d   
07D7                LOOPEND3:      
07D7   11 00 00               LD   de,FALSE   ; if clause ran then vElse = FALSE
07DA   ED 53 8A 0B            LD   (vElse),de   
07DE   DD 4E 04               LD   c,(ix+4)   ; IP = start
07E1   DD 46 05               LD   b,(ix+5)   
07E4   FD E9                  JP   (iy)   
07E6                LOOPEND4:      
07E6   11 08 00               LD   de,2*4   ; rpop frame
07E9   DD 19                  ADD   ix,de   
07EB   FD E9                  JP   (iy)   
07ED                CARRY:       
07ED   21 00 00               LD   hl,0   
07F0   CB 15                  RL   l   
07F2   22 86 0B               LD   (vcarry),hl   
07F5   FD E9                  JP   (iy)   
07F7                COMMENT:      
07F7   03                     INC   bc   ; point to next char
07F8   0A                     LD   a,(bc)   
07F9   FE 0D                  CP   "\r"   ; terminate at cr
07FB   20 FA                  JR   nz,comment   
07FD   0B                     DEC   bc   
07FE   FD E9                  JP   (iy)   
0800                             ; 0 1 count
0800                             ; 2 3 limit
0800                             ; 4 5 start
0800                             ; 6 7 end
0800                DSIZE:    EQU   $80   
0800                RSIZE:    EQU   $80   
0800                TIBSIZE:   EQU   $100   ; 256 bytes , along line!
0800                VARS_SIZE:   EQU   26*2*2   ; A..Z, a..z words
0800                          .ORG   RAMSTART   
0800                TIB:      DS   TIBSIZE   
0900                          DS   RSIZE   
0980                RSTACK:      
0980                          DS   DSIZE   
0A00                DSTACK:      
0A00                STACK:       
0A00                          ALIGN   $100   
0A00                OPCODES:      
0A00                          DS   $80-32-1-1   
0A5E                ALTCODES:      
0A5E                          DS   $80-32-1-5   
0AB8                          ALIGN   $100   
0B00                MINTVARS:      
0B00                          DS   $30   
0B30                VLOOPSP:   DS   2   ; 
0B32                TBPTR:    DS   2   ; reserved for tests
0B34                VTEMP1:   DS   2   ; 
0B36                VTEMP2:   DS   2   ; 
0B38                RST08:    DS   2   
0B3A                RST10:    DS   2   
0B3C                RST18:    DS   2   
0B3E                RST20:    DS   2   
0B40                RST28:    DS   2   
0B42                RST30:    DS   2   ; 
0B44                BAUD:     DS   2   ; 
0B46                INTVEC:   DS   2   ; 
0B48                NMIVEC:   DS   2   ; 
0B4A                GETCVEC:   DS   2   ; 
0B4C                PUTCVEC:   DS   2   ; 
0B4E                          DS   26*2   
0B82                ALTVARS:      
0B82                          DS   2   ; a
0B84                VBYTEMODE:   DS   2   ; b
0B86                VCARRY:   DS   2   ; c
0B88                          DS   2   ; d
0B8A                VELSE:    DS   2   ; e
0B8C                VFALSE:   DS   2   ; f
0B8E                          DS   2   ; g
0B90                VHEAPPTR:   DS   2   ; h
0B92                          DS   2   ; i
0B94                          DS   2   ; j
0B96                VTIBPTR:   DS   2   ; k
0B98                          DS   2   ; l
0B9A                          DS   2   ; m
0B9C                          DS   2   ; n
0B9E                          DS   2   ; o
0BA0                VPOINTER:   DS   2   ; p
0BA2                          DS   2   ; q
0BA4                VREMAIN:   DS   2   ; r
0BA6                VS0:      DS   2   ; s
0BA8                VTRUE:    DS   2   ; t
0BAA                VUNLIMITED:   DS   2   ; u
0BAC                          DS   2   ; v
0BAE                          DS   2   ; w
0BB0                          DS   2   ; x
0BB2                          DS   2   ; y
0BB4                VLASTDEF:   DS   2   ; z
0BB6                VARS:     DS   VARS_SIZE   
0C1E                HEAP:        


TEC_1:              0001 DEFINED AT LINE 1 IN constants.asm
RC2014:             0000 DEFINED AT LINE 2 IN constants.asm
EXTENDED:           0000 DEFINED AT LINE 4 IN constants.asm
LOADER:             0000 DEFINED AT LINE 20 IN constants.asm
BITBANG:            0000 DEFINED AT LINE 21 IN constants.asm
ROMSTART:           0000 DEFINED AT LINE 23 IN constants.asm
                    > USED AT LINE 100 IN IOSerial.asm
                    > USED AT LINE 105 IN IOSerial.asm
                    > USED AT LINE 111 IN IOSerial.asm
                    > USED AT LINE 117 IN IOSerial.asm
                    > USED AT LINE 123 IN IOSerial.asm
                    > USED AT LINE 129 IN IOSerial.asm
                    > USED AT LINE 135 IN IOSerial.asm
                    > USED AT LINE 141 IN IOSerial.asm
                    > USED AT LINE 147 IN IOSerial.asm
                    > USED AT LINE 189 IN IOSerial.asm
                    > USED AT LINE 43 IN MAIN.asm
RAMSTART:           0800 DEFINED AT LINE 24 IN constants.asm
                    > USED AT LINE 7 IN ram.asm
ROMSIZE:            0800 DEFINED AT LINE 25 IN constants.asm
RAMSIZE:            0800 DEFINED AT LINE 26 IN constants.asm
CONTROL:            0080 DEFINED AT LINE 22 IN IOSerial.asm
                    > USED AT LINE 465 IN IOSerial.asm
                    > USED AT LINE 487 IN IOSerial.asm
STATUS:             0080 DEFINED AT LINE 23 IN IOSerial.asm
                    > USED AT LINE 298 IN IOSerial.asm
                    > USED AT LINE 311 IN IOSerial.asm
TDR:                0081 DEFINED AT LINE 24 IN IOSerial.asm
                    > USED AT LINE 303 IN IOSerial.asm
RDR:                0081 DEFINED AT LINE 25 IN IOSerial.asm
                    > USED AT LINE 315 IN IOSerial.asm
MRESET:             0003 DEFINED AT LINE 32 IN IOSerial.asm
                    > USED AT LINE 464 IN IOSerial.asm
DIV_64:             0002 DEFINED AT LINE 35 IN IOSerial.asm
                    > USED AT LINE 486 IN IOSerial.asm
F7E2:               0000 DEFINED AT LINE 39 IN IOSerial.asm
F7O2:               0004 DEFINED AT LINE 40 IN IOSerial.asm
F7E1:               0008 DEFINED AT LINE 41 IN IOSerial.asm
F7O1:               000C DEFINED AT LINE 42 IN IOSerial.asm
F8N2:               0010 DEFINED AT LINE 43 IN IOSerial.asm
                    > USED AT LINE 486 IN IOSerial.asm
F8N1:               0014 DEFINED AT LINE 44 IN IOSerial.asm
F8E1:               0018 DEFINED AT LINE 45 IN IOSerial.asm
F8O1:               001C DEFINED AT LINE 46 IN IOSerial.asm
RTSLID:             0000 DEFINED AT LINE 50 IN IOSerial.asm
                    > USED AT LINE 486 IN IOSerial.asm
RTSLIE:             0020 DEFINED AT LINE 51 IN IOSerial.asm
RTSHID:             0040 DEFINED AT LINE 52 IN IOSerial.asm
RTSLIDB:            0060 DEFINED AT LINE 53 IN IOSerial.asm
RIE:                0080 DEFINED AT LINE 57 IN IOSerial.asm
RDRF:               0000 DEFINED AT LINE 61 IN IOSerial.asm
TDRE:               0001 DEFINED AT LINE 62 IN IOSerial.asm
DCD:                0002 DEFINED AT LINE 63 IN IOSerial.asm
CTS:                0003 DEFINED AT LINE 64 IN IOSerial.asm
FE:                 0004 DEFINED AT LINE 65 IN IOSerial.asm
OVRN:               0005 DEFINED AT LINE 66 IN IOSerial.asm
PE:                 0006 DEFINED AT LINE 67 IN IOSerial.asm
IRQ:                0007 DEFINED AT LINE 68 IN IOSerial.asm
KEYBUF:             0000 DEFINED AT LINE 76 IN IOSerial.asm
SCAN:               0001 DEFINED AT LINE 77 IN IOSerial.asm
DISPLY:             0002 DEFINED AT LINE 78 IN IOSerial.asm
PORT3:              0003 DEFINED AT LINE 79 IN IOSerial.asm
PORT4:              0004 DEFINED AT LINE 80 IN IOSerial.asm
PORT5:              0005 DEFINED AT LINE 81 IN IOSerial.asm
PORT6:              0006 DEFINED AT LINE 82 IN IOSerial.asm
PORT7:              0007 DEFINED AT LINE 83 IN IOSerial.asm
ESC:                001B DEFINED AT LINE 96 IN IOSerial.asm
CR:                 000D DEFINED AT LINE 97 IN IOSerial.asm
LF:                 000A DEFINED AT LINE 98 IN IOSerial.asm
RSTVEC:             0000 DEFINED AT LINE 102 IN IOSerial.asm
SEVENSEGMENT:       0040 DEFINED AT LINE 152 IN IOSerial.asm
PWRUP:              0050 DEFINED AT LINE 174 IN IOSerial.asm
                    > USED AT LINE 470 IN IOSerial.asm
BITIME:             0053 DEFINED AT LINE 176 IN IOSerial.asm
BITIM1:             0058 DEFINED AT LINE 180 IN IOSerial.asm
                    > USED AT LINE 182 IN IOSerial.asm
INTRET:             005F DEFINED AT LINE 185 IN IOSerial.asm
                    > USED AT LINE 446 IN IOSerial.asm
TXDATA:             006B DEFINED AT LINE 293 IN IOSerial.asm
                    > USED AT LINE 458 IN IOSerial.asm
TXCHAR:             006B DEFINED AT LINE 294 IN IOSerial.asm
TXCHAR1:            006D DEFINED AT LINE 297 IN IOSerial.asm
                    > USED AT LINE 301 IN IOSerial.asm
RXDATA:             0078 DEFINED AT LINE 309 IN IOSerial.asm
                    > USED AT LINE 456 IN IOSerial.asm
RXCHAR:             0078 DEFINED AT LINE 310 IN IOSerial.asm
                    > USED AT LINE 314 IN IOSerial.asm
GETCHAR:            0081 DEFINED AT LINE 434 IN IOSerial.asm
                    > USED AT LINE 184 IN MAIN.asm
                    > USED AT LINE 999 IN MAIN.asm
PUTCHAR:            0085 DEFINED AT LINE 438 IN IOSerial.asm
                    > USED AT LINE 221 IN MAIN.asm
                    > USED AT LINE 372 IN MAIN.asm
                    > USED AT LINE 467 IN MAIN.asm
                    > USED AT LINE 493 IN MAIN.asm
                    > USED AT LINE 582 IN MAIN.asm
                    > USED AT LINE 723 IN MAIN.asm
                    > USED AT LINE 987 IN MAIN.asm
                    > USED AT LINE 1214 IN MAIN.asm
                    > USED AT LINE 1255 IN MAIN.asm
RESET:              008B DEFINED AT LINE 444 IN IOSerial.asm
                    > USED AT LINE 103 IN IOSerial.asm
FALSE:              0000 DEFINED AT LINE 12 IN MAIN.asm
                    > USED AT LINE 676 IN MAIN.asm
                    > USED AT LINE 1317 IN MAIN.asm
TRUE:               00-1 DEFINED AT LINE 13 IN MAIN.asm
                    > USED AT LINE 287 IN MAIN.asm
                    > USED AT LINE 681 IN MAIN.asm
UNLIMITED:          00-2 DEFINED AT LINE 14 IN MAIN.asm
CTRL_C:             0003 DEFINED AT LINE 16 IN MAIN.asm
                    > USED AT LINE 251 IN MAIN.asm
CTRL_E:             0005 DEFINED AT LINE 17 IN MAIN.asm
                    > USED AT LINE 194 IN MAIN.asm
CTRL_H:             0008 DEFINED AT LINE 18 IN MAIN.asm
                    > USED AT LINE 191 IN MAIN.asm
CTRL_J:             000A DEFINED AT LINE 19 IN MAIN.asm
                    > USED AT LINE 197 IN MAIN.asm
CTRL_L:             000C DEFINED AT LINE 20 IN MAIN.asm
                    > USED AT LINE 200 IN MAIN.asm
CTRL_P:             0010 DEFINED AT LINE 21 IN MAIN.asm
                    > USED AT LINE 203 IN MAIN.asm
BSLASH:             005C DEFINED AT LINE 23 IN MAIN.asm
MACROS:             0180 DEFINED AT LINE 49 IN MAIN.asm
REEDIT_:            0180 DEFINED AT LINE 51 IN MAIN.asm
EDIT_:              0186 DEFINED AT LINE 54 IN MAIN.asm
LIST_:              0193 DEFINED AT LINE 57 IN MAIN.asm
PRINTSTACK_:        0193 DEFINED AT LINE 60 IN MAIN.asm
IOPCODES:           019B DEFINED AT LINE 63 IN MAIN.asm
                    > USED AT LINE 305 IN MAIN.asm
IALTCODES:          01C5 DEFINED AT LINE 110 IN MAIN.asm
BACKSPACE:          01E1 DEFINED AT LINE 143 IN MAIN.asm
                    > USED AT LINE 192 IN MAIN.asm
START:              01EF DEFINED AT LINE 152 IN MAIN.asm
                    > USED AT LINE 6
INTERPRET:          0204 DEFINED AT LINE 158 IN MAIN.asm
                    > USED AT LINE 275 IN MAIN.asm
INTERPRET2:         020E DEFINED AT LINE 164 IN MAIN.asm
                    > USED AT LINE 146 IN MAIN.asm
                    > USED AT LINE 150 IN MAIN.asm
                    > USED AT LINE 206 IN MAIN.asm
                    > USED AT LINE 214 IN MAIN.asm
INTERPRET3:         0216 DEFINED AT LINE 171 IN MAIN.asm
                    > USED AT LINE 180 IN MAIN.asm
INTERPRET4:         021C DEFINED AT LINE 177 IN MAIN.asm
                    > USED AT LINE 169 IN MAIN.asm
WAITCHAR:           0221 DEFINED AT LINE 183 IN MAIN.asm
                    > USED AT LINE 223 IN MAIN.asm
                    > USED AT LINE 237 IN MAIN.asm
MACRO:              0250 DEFINED AT LINE 208 IN MAIN.asm
                    > USED AT LINE 196 IN MAIN.asm
                    > USED AT LINE 199 IN MAIN.asm
                    > USED AT LINE 202 IN MAIN.asm
                    > USED AT LINE 205 IN MAIN.asm
WAITCHAR1:          0261 DEFINED AT LINE 216 IN MAIN.asm
                    > USED AT LINE 186 IN MAIN.asm
WAITCHAR3:          026F DEFINED AT LINE 225 IN MAIN.asm
                    > USED AT LINE 190 IN MAIN.asm
WAITCHAR4:          0285 DEFINED AT LINE 241 IN MAIN.asm
                    > USED AT LINE 188 IN MAIN.asm
NEXT:               028D DEFINED AT LINE 246 IN MAIN.asm
                    > USED AT LINE 254 IN MAIN.asm
                    > USED AT LINE 279 IN MAIN.asm
EXIT:               02A1 DEFINED AT LINE 261 IN MAIN.asm
                    > USED AT LINE 250 IN MAIN.asm
ETX:                02AB DEFINED AT LINE 269 IN MAIN.asm
                    > USED AT LINE 252 IN MAIN.asm
ETX1:               02B4 DEFINED AT LINE 274 IN MAIN.asm
                    > USED AT LINE 272 IN MAIN.asm
INIT:               02B7 DEFINED AT LINE 277 IN MAIN.asm
                    > USED AT LINE 154 IN MAIN.asm
INIT1:              02C4 DEFINED AT LINE 283 IN MAIN.asm
                    > USED AT LINE 286 IN MAIN.asm
INITOPS:            02F2 DEFINED AT LINE 304 IN MAIN.asm
INITOPS1:           02FB DEFINED AT LINE 309 IN MAIN.asm
                    > USED AT LINE 319 IN MAIN.asm
                    > USED AT LINE 330 IN MAIN.asm
INITOPS2:           030B DEFINED AT LINE 321 IN MAIN.asm
                    > USED AT LINE 314 IN MAIN.asm
INITOPS2A:          0310 DEFINED AT LINE 326 IN MAIN.asm
                    > USED AT LINE 329 IN MAIN.asm
LOOKUP:             0316 DEFINED AT LINE 332 IN MAIN.asm
                    > USED AT LINE 380 IN MAIN.asm
                    > USED AT LINE 571 IN MAIN.asm
                    > USED AT LINE 1147 IN MAIN.asm
LOOKUP1:            031A DEFINED AT LINE 335 IN MAIN.asm
                    > USED AT LINE 700 IN MAIN.asm
LOOKUP2:            031C DEFINED AT LINE 337 IN MAIN.asm
                    > USED AT LINE 334 IN MAIN.asm
PRINTHEX:           0329 DEFINED AT LINE 349 IN MAIN.asm
                    > USED AT LINE 588 IN MAIN.asm
PRINTHEX2:          0334 DEFINED AT LINE 358 IN MAIN.asm
                    > USED AT LINE 353 IN MAIN.asm
                    > USED AT LINE 355 IN MAIN.asm
PRINTHEX3:          033D DEFINED AT LINE 366 IN MAIN.asm
                    > USED AT LINE 364 IN MAIN.asm
EDITDEF:            0348 DEFINED AT LINE 374 IN MAIN.asm
                    > USED AT LINE 1105 IN MAIN.asm
EDITDEF1:           0365 DEFINED AT LINE 393 IN MAIN.asm
                    > USED AT LINE 399 IN MAIN.asm
EDITDEF2:           0366 DEFINED AT LINE 395 IN MAIN.asm
                    > USED AT LINE 392 IN MAIN.asm
EDITDEF3:           036E DEFINED AT LINE 400 IN MAIN.asm
                    > USED AT LINE 387 IN MAIN.asm
NESTING:            0379 DEFINED AT LINE 417 IN MAIN.asm
                    > USED AT LINE 175 IN MAIN.asm
                    > USED AT LINE 222 IN MAIN.asm
                    > USED AT LINE 1265 IN MAIN.asm
NESTING1:           0382 DEFINED AT LINE 424 IN MAIN.asm
                    > USED AT LINE 419 IN MAIN.asm
NESTING2:           0392 DEFINED AT LINE 433 IN MAIN.asm
                    > USED AT LINE 426 IN MAIN.asm
                    > USED AT LINE 428 IN MAIN.asm
                    > USED AT LINE 430 IN MAIN.asm
NESTING3:           0394 DEFINED AT LINE 436 IN MAIN.asm
                    > USED AT LINE 432 IN MAIN.asm
NESTING4:           03A3 DEFINED AT LINE 445 IN MAIN.asm
                    > USED AT LINE 438 IN MAIN.asm
                    > USED AT LINE 440 IN MAIN.asm
                    > USED AT LINE 442 IN MAIN.asm
PROMPT:             03A5 DEFINED AT LINE 449 IN MAIN.asm
                    > USED AT LINE 159 IN MAIN.asm
                    > USED AT LINE 1108 IN MAIN.asm
CRLF:               03AE DEFINED AT LINE 454 IN MAIN.asm
                    > USED AT LINE 234 IN MAIN.asm
                    > USED AT LINE 1034 IN MAIN.asm
PRINTSTR:           03B5 DEFINED AT LINE 459 IN MAIN.asm
                    > USED AT LINE 148 IN MAIN.asm
                    > USED AT LINE 155 IN MAIN.asm
                    > USED AT LINE 450 IN MAIN.asm
                    > USED AT LINE 455 IN MAIN.asm
PUTSTR0:            03BC DEFINED AT LINE 466 IN MAIN.asm
                    > USED AT LINE 472 IN MAIN.asm
PUTSTR:             03C0 DEFINED AT LINE 469 IN MAIN.asm
                    > USED AT LINE 461 IN MAIN.asm
RPUSH:              03C5 DEFINED AT LINE 475 IN MAIN.asm
                    > USED AT LINE 497 IN MAIN.asm
                    > USED AT LINE 733 IN MAIN.asm
                    > USED AT LINE 1016 IN MAIN.asm
                    > USED AT LINE 1282 IN MAIN.asm
                    > USED AT LINE 1285 IN MAIN.asm
                    > USED AT LINE 1287 IN MAIN.asm
                    > USED AT LINE 1289 IN MAIN.asm
RPOP:               03D0 DEFINED AT LINE 482 IN MAIN.asm
                    > USED AT LINE 264 IN MAIN.asm
                    > USED AT LINE 622 IN MAIN.asm
                    > USED AT LINE 914 IN MAIN.asm
RPOP2:              03DA DEFINED AT LINE 487 IN MAIN.asm
WRITECHAR:          03DB DEFINED AT LINE 490 IN MAIN.asm
                    > USED AT LINE 389 IN MAIN.asm
                    > USED AT LINE 391 IN MAIN.asm
                    > USED AT LINE 397 IN MAIN.asm
ENTER:              03E0 DEFINED AT LINE 495 IN MAIN.asm
                    > USED AT LINE 211 IN MAIN.asm
                    > USED AT LINE 1114 IN MAIN.asm
LOOPVAR:            03E9 DEFINED AT LINE 502 IN MAIN.asm
                    > USED AT LINE 783 IN MAIN.asm
                    > USED AT LINE 786 IN MAIN.asm
PAGE4:              0400 DEFINED AT LINE 515 IN MAIN.asm
DQUOTE_:            0400 DEFINED AT LINE 517 IN MAIN.asm
QUESTION_:          0400 DEFINED AT LINE 518 IN MAIN.asm
LBRACE_:            0400 DEFINED AT LINE 519 IN MAIN.asm
RBRACE_:            0400 DEFINED AT LINE 520 IN MAIN.asm
UNDERSCORE_:        0400 DEFINED AT LINE 521 IN MAIN.asm
AMPER_:             0402 DEFINED AT LINE 524 IN MAIN.asm
AND_:               0402 DEFINED AT LINE 525 IN MAIN.asm
AND1:               0409 DEFINED AT LINE 533 IN MAIN.asm
                    > USED AT LINE 548 IN MAIN.asm
                    > USED AT LINE 559 IN MAIN.asm
PIPE_:              040D DEFINED AT LINE 539 IN MAIN.asm
OR_:                040D DEFINED AT LINE 540 IN MAIN.asm
CARET_:             0416 DEFINED AT LINE 550 IN MAIN.asm
XOR_:               0416 DEFINED AT LINE 551 IN MAIN.asm
PLUS_:              041F DEFINED AT LINE 561 IN MAIN.asm
ADD_:               041F DEFINED AT LINE 562 IN MAIN.asm
CALL_:              0426 DEFINED AT LINE 569 IN MAIN.asm
DOT_:               0430 DEFINED AT LINE 577 IN MAIN.asm
DOT2:               0434 DEFINED AT LINE 580 IN MAIN.asm
                    > USED AT LINE 589 IN MAIN.asm
COMMA_:             043B DEFINED AT LINE 585 IN MAIN.asm
HDOT_:              043B DEFINED AT LINE 586 IN MAIN.asm
BSLASH_:            0441 DEFINED AT LINE 591 IN MAIN.asm
DROP_:              0441 DEFINED AT LINE 592 IN MAIN.asm
HASH_:              0444 DEFINED AT LINE 596 IN MAIN.asm
DUP_:               0444 DEFINED AT LINE 597 IN MAIN.asm
DOLLAR_:            0449 DEFINED AT LINE 604 IN MAIN.asm
SWAP_:              0449 DEFINED AT LINE 605 IN MAIN.asm
PERCENT_:           044E DEFINED AT LINE 611 IN MAIN.asm
OVER_:              044E DEFINED AT LINE 612 IN MAIN.asm
SEMI_:              0455 DEFINED AT LINE 620 IN MAIN.asm
RET_:               0455 DEFINED AT LINE 621 IN MAIN.asm
TILDE_:             045C DEFINED AT LINE 626 IN MAIN.asm
NOT:                045C DEFINED AT LINE 627 IN MAIN.asm
BANG_:              0466 DEFINED AT LINE 638 IN MAIN.asm
STORE_:             0466 DEFINED AT LINE 639 IN MAIN.asm
ASSIGN:             0466 DEFINED AT LINE 640 IN MAIN.asm
ASSIGN0:            0468 DEFINED AT LINE 643 IN MAIN.asm
ASSIGN1:            046B DEFINED AT LINE 645 IN MAIN.asm
MINUS_:             0470 DEFINED AT LINE 651 IN MAIN.asm
SUB_:               0470 DEFINED AT LINE 652 IN MAIN.asm
SUB1:               047C DEFINED AT LINE 660 IN MAIN.asm
                    > USED AT LINE 657 IN MAIN.asm
SUB2:               047E DEFINED AT LINE 663 IN MAIN.asm
EQ_:                0485 DEFINED AT LINE 669 IN MAIN.asm
FALSE_:             048C DEFINED AT LINE 675 IN MAIN.asm
                    > USED AT LINE 696 IN MAIN.asm
TRUE_:              0492 DEFINED AT LINE 680 IN MAIN.asm
                    > USED AT LINE 674 IN MAIN.asm
                    > USED AT LINE 695 IN MAIN.asm
GT_:                0498 DEFINED AT LINE 685 IN MAIN.asm
LT_:                049C DEFINED AT LINE 689 IN MAIN.asm
LT1_:               049E DEFINED AT LINE 692 IN MAIN.asm
                    > USED AT LINE 688 IN MAIN.asm
VAR_:               04A5 DEFINED AT LINE 698 IN MAIN.asm
VAR1:               04A9 DEFINED AT LINE 701 IN MAIN.asm
                    > USED AT LINE 509 IN MAIN.asm
                    > USED AT LINE 747 IN MAIN.asm
                    > USED AT LINE 792 IN MAIN.asm
VAR2:               04B7 DEFINED AT LINE 710 IN MAIN.asm
                    > USED AT LINE 707 IN MAIN.asm
GRAVE_:             04BA DEFINED AT LINE 714 IN MAIN.asm
STR:                04BA DEFINED AT LINE 715 IN MAIN.asm
STR1:               04BB DEFINED AT LINE 718 IN MAIN.asm
                    > USED AT LINE 724 IN MAIN.asm
STR2:               04C6 DEFINED AT LINE 725 IN MAIN.asm
                    > USED AT LINE 722 IN MAIN.asm
LBRACK_:            04C9 DEFINED AT LINE 729 IN MAIN.asm
ARRDEF:             04C9 DEFINED AT LINE 730 IN MAIN.asm
AT_:                04D2 DEFINED AT LINE 736 IN MAIN.asm
ARRACCESS:          04D2 DEFINED AT LINE 737 IN MAIN.asm
ARRACCESS0:         04DA DEFINED AT LINE 743 IN MAIN.asm
ARRACCESS1:         04DB DEFINED AT LINE 745 IN MAIN.asm
                    > USED AT LINE 742 IN MAIN.asm
LPAREN_:            04DF DEFINED AT LINE 749 IN MAIN.asm
RPAREN_:            04E2 DEFINED AT LINE 751 IN MAIN.asm
NUM_:               04E5 DEFINED AT LINE 754 IN MAIN.asm
COLON_:             04E8 DEFINED AT LINE 756 IN MAIN.asm
RBRACK_:            04EB DEFINED AT LINE 758 IN MAIN.asm
QUOTE_:             04EE DEFINED AT LINE 761 IN MAIN.asm
STAR_:              04F0 DEFINED AT LINE 763 IN MAIN.asm
SLASH_:             04F2 DEFINED AT LINE 765 IN MAIN.asm
SLASH:              04F2 DEFINED AT LINE 772 IN MAIN.asm
ALT1:               051A DEFINED AT LINE 793 IN MAIN.asm
                    > USED AT LINE 778 IN MAIN.asm
ALT2:               052E DEFINED AT LINE 806 IN MAIN.asm
                    > USED AT LINE 780 IN MAIN.asm
                    > USED AT LINE 795 IN MAIN.asm
                    > USED AT LINE 797 IN MAIN.asm
HEX:                0531 DEFINED AT LINE 810 IN MAIN.asm
                    > USED AT LINE 762 IN MAIN.asm
HEX1:               0534 DEFINED AT LINE 812 IN MAIN.asm
                    > USED AT LINE 829 IN MAIN.asm
HEX2:               053C DEFINED AT LINE 818 IN MAIN.asm
                    > USED AT LINE 816 IN MAIN.asm
MUL:                054E DEFINED AT LINE 831 IN MAIN.asm
                    > USED AT LINE 764 IN MAIN.asm
MUL2:               0558 DEFINED AT LINE 839 IN MAIN.asm
                    > USED AT LINE 848 IN MAIN.asm
DIV:                056E DEFINED AT LINE 854 IN MAIN.asm
                    > USED AT LINE 808 IN MAIN.asm
ABSBC:              057F DEFINED AT LINE 870 IN MAIN.asm
                    > USED AT LINE 862 IN MAIN.asm
LOOP1:              0592 DEFINED AT LINE 884 IN MAIN.asm
                    > USED AT LINE 894 IN MAIN.asm
LOOP2:              0593 DEFINED AT LINE 886 IN MAIN.asm
                    > USED AT LINE 896 IN MAIN.asm
JUMPIN:             0596 DEFINED AT LINE 889 IN MAIN.asm
                    > USED AT LINE 883 IN MAIN.asm
ENDSDIV:            05A3 DEFINED AT LINE 897 IN MAIN.asm
                    > USED AT LINE 888 IN MAIN.asm
DIV10:              05AD DEFINED AT LINE 906 IN MAIN.asm
                    > USED AT LINE 899 IN MAIN.asm
ARREND:             05B4 DEFINED AT LINE 912 IN MAIN.asm
                    > USED AT LINE 759 IN MAIN.asm
ARRAYEND1:          05D2 DEFINED AT LINE 929 IN MAIN.asm
                    > USED AT LINE 947 IN MAIN.asm
ARRAYEND2:          05E3 DEFINED AT LINE 944 IN MAIN.asm
                    > USED AT LINE 928 IN MAIN.asm
                    > USED AT LINE 938 IN MAIN.asm
PAGE6:              0600 DEFINED AT LINE 963 IN MAIN.asm
ARRSIZE_:           0600 DEFINED AT LINE 966 IN MAIN.asm
ARRSIZE:            0600 DEFINED AT LINE 967 IN MAIN.asm
ANOP_:              0606 DEFINED AT LINE 974 IN MAIN.asm
BMODE_:             0608 DEFINED AT LINE 977 IN MAIN.asm
EMIT_:              0614 DEFINED AT LINE 984 IN MAIN.asm
EXEC_:              061B DEFINED AT LINE 990 IN MAIN.asm
EXEC1:              0620 DEFINED AT LINE 993 IN MAIN.asm
                    > USED AT LINE 991 IN MAIN.asm
KEY_:               0623 DEFINED AT LINE 998 IN MAIN.asm
GO_:                062C DEFINED AT LINE 1005 IN MAIN.asm
GO1:                062D DEFINED AT LINE 1007 IN MAIN.asm
                    > USED AT LINE 575 IN MAIN.asm
GO2:                063C DEFINED AT LINE 1017 IN MAIN.asm
                    > USED AT LINE 1015 IN MAIN.asm
GO3:                063F DEFINED AT LINE 1020 IN MAIN.asm
                    > USED AT LINE 1010 IN MAIN.asm
INPORT_:            0641 DEFINED AT LINE 1023 IN MAIN.asm
NEWLN_:             064C DEFINED AT LINE 1033 IN MAIN.asm
OUTPORT_:           0651 DEFINED AT LINE 1037 IN MAIN.asm
SHL_:               065A DEFINED AT LINE 1048 IN MAIN.asm
SHIFTLEFT:          065A DEFINED AT LINE 1049 IN MAIN.asm
SHIFTLEFT1:         0662 DEFINED AT LINE 1057 IN MAIN.asm
                    > USED AT LINE 1059 IN MAIN.asm
SHIFTLEFT2:         0665 DEFINED AT LINE 1060 IN MAIN.asm
                    > USED AT LINE 1055 IN MAIN.asm
SHR_:               0669 DEFINED AT LINE 1065 IN MAIN.asm
SHIFTRIGHT1:        0671 DEFINED AT LINE 1073 IN MAIN.asm
                    > USED AT LINE 1076 IN MAIN.asm
SHIFTRIGHT2:        0677 DEFINED AT LINE 1077 IN MAIN.asm
                    > USED AT LINE 1071 IN MAIN.asm
UTILITY_:           067B DEFINED AT LINE 1086 IN MAIN.asm
UTILITY:            067B DEFINED AT LINE 1087 IN MAIN.asm
UTILITY1:           0693 DEFINED AT LINE 1103 IN MAIN.asm
                    > USED AT LINE 1091 IN MAIN.asm
UTILITY2:           06A5 DEFINED AT LINE 1112 IN MAIN.asm
                    > USED AT LINE 1107 IN MAIN.asm
UTILITY3:           06C0 DEFINED AT LINE 1116 IN MAIN.asm
                    > USED AT LINE 1111 IN MAIN.asm
WHILE_:             06C2 DEFINED AT LINE 1119 IN MAIN.asm
WHILE:              06C2 DEFINED AT LINE 1120 IN MAIN.asm
WHILE2:             06D0 DEFINED AT LINE 1129 IN MAIN.asm
                    > USED AT LINE 1124 IN MAIN.asm
DEF:                06D2 DEFINED AT LINE 1136 IN MAIN.asm
                    > USED AT LINE 757 IN MAIN.asm
DEF0:               06E0 DEFINED AT LINE 1145 IN MAIN.asm
                    > USED AT LINE 1140 IN MAIN.asm
DEF1:               06EE DEFINED AT LINE 1153 IN MAIN.asm
                    > USED AT LINE 1144 IN MAIN.asm
                    > USED AT LINE 1160 IN MAIN.asm
DEF2:               06F8 DEFINED AT LINE 1161 IN MAIN.asm
                    > USED AT LINE 1159 IN MAIN.asm
DEF3:               06F9 DEFINED AT LINE 1163 IN MAIN.asm
NUM:                06FF DEFINED AT LINE 1167 IN MAIN.asm
                    > USED AT LINE 659 IN MAIN.asm
                    > USED AT LINE 755 IN MAIN.asm
NUM0:               0708 DEFINED AT LINE 1173 IN MAIN.asm
                    > USED AT LINE 1171 IN MAIN.asm
NUM1:               0709 DEFINED AT LINE 1175 IN MAIN.asm
                    > USED AT LINE 1192 IN MAIN.asm
NUM2:               0721 DEFINED AT LINE 1193 IN MAIN.asm
                    > USED AT LINE 820 IN MAIN.asm
                    > USED AT LINE 822 IN MAIN.asm
                    > USED AT LINE 1178 IN MAIN.asm
                    > USED AT LINE 1180 IN MAIN.asm
NUM3:               072C DEFINED AT LINE 1201 IN MAIN.asm
                    > USED AT LINE 1196 IN MAIN.asm
PRINTDEC:           072F DEFINED AT LINE 1210 IN MAIN.asm
                    > USED AT LINE 579 IN MAIN.asm
PRINTDEC2:          073E DEFINED AT LINE 1221 IN MAIN.asm
                    > USED AT LINE 1212 IN MAIN.asm
PRINTDEC4:          0760 DEFINED AT LINE 1237 IN MAIN.asm
                    > USED AT LINE 1225 IN MAIN.asm
                    > USED AT LINE 1227 IN MAIN.asm
                    > USED AT LINE 1229 IN MAIN.asm
                    > USED AT LINE 1231 IN MAIN.asm
                    > USED AT LINE 1234 IN MAIN.asm
PRINTDEC5:          0762 DEFINED AT LINE 1239 IN MAIN.asm
                    > USED AT LINE 1242 IN MAIN.asm
PRINTDEC6:          0772 DEFINED AT LINE 1251 IN MAIN.asm
                    > USED AT LINE 1246 IN MAIN.asm
PRINTDEC7:          0773 DEFINED AT LINE 1253 IN MAIN.asm
                    > USED AT LINE 1250 IN MAIN.asm
BEGIN:              0777 DEFINED AT LINE 1258 IN MAIN.asm
                    > USED AT LINE 750 IN MAIN.asm
LOOPSTART:          0777 DEFINED AT LINE 1259 IN MAIN.asm
LOOPSTART1:         077D DEFINED AT LINE 1262 IN MAIN.asm
                    > USED AT LINE 1266 IN MAIN.asm
LOOPSTART2:         0790 DEFINED AT LINE 1274 IN MAIN.asm
                    > USED AT LINE 1270 IN MAIN.asm
LOOPSTART3:         0799 DEFINED AT LINE 1280 IN MAIN.asm
                    > USED AT LINE 1278 IN MAIN.asm
LOOPSTART4:         07AF DEFINED AT LINE 1290 IN MAIN.asm
                    > USED AT LINE 1273 IN MAIN.asm
AGAIN:              07B1 DEFINED AT LINE 1293 IN MAIN.asm
                    > USED AT LINE 752 IN MAIN.asm
LOOPEND:            07B1 DEFINED AT LINE 1294 IN MAIN.asm
LOOPEND2:           07CA DEFINED AT LINE 1310 IN MAIN.asm
                    > USED AT LINE 1304 IN MAIN.asm
LOOPEND3:           07D7 DEFINED AT LINE 1316 IN MAIN.asm
LOOPEND4:           07E6 DEFINED AT LINE 1322 IN MAIN.asm
                    > USED AT LINE 1128 IN MAIN.asm
                    > USED AT LINE 1299 IN MAIN.asm
CARRY:              07ED DEFINED AT LINE 1327 IN MAIN.asm
                    > USED AT LINE 567 IN MAIN.asm
                    > USED AT LINE 667 IN MAIN.asm
COMMENT:            07F7 DEFINED AT LINE 1333 IN MAIN.asm
                    > USED AT LINE 776 IN MAIN.asm
                    > USED AT LINE 1337 IN MAIN.asm
DSIZE:              0080 DEFINED AT LINE 1 IN ram.asm
                    > USED AT LINE 14 IN ram.asm
RSIZE:              0080 DEFINED AT LINE 2 IN ram.asm
                    > USED AT LINE 11 IN ram.asm
TIBSIZE:            0100 DEFINED AT LINE 3 IN ram.asm
                    > USED AT LINE 9 IN ram.asm
VARS_SIZE:          0068 DEFINED AT LINE 5 IN ram.asm
                    > USED AT LINE 301 IN MAIN.asm
                    > USED AT LINE 74 IN ram.asm
TIB:                0800 DEFINED AT LINE 9 IN ram.asm
                    > USED AT LINE 168 IN MAIN.asm
                    > USED AT LINE 217 IN MAIN.asm
                    > USED AT LINE 226 IN MAIN.asm
                    > USED AT LINE 243 IN MAIN.asm
                    > USED AT LINE 386 IN MAIN.asm
                    > USED AT LINE 401 IN MAIN.asm
RSTACK:             0980 DEFINED AT LINE 12 IN ram.asm
                    > USED AT LINE 278 IN MAIN.asm
DSTACK:             0A00 DEFINED AT LINE 15 IN ram.asm
                    > USED AT LINE 153 IN MAIN.asm
                    > USED AT LINE 270 IN MAIN.asm
                    > USED AT LINE 273 IN MAIN.asm
                    > USED AT LINE 291 IN MAIN.asm
                    > USED AT LINE 1096 IN MAIN.asm
STACK:              0A00 DEFINED AT LINE 16 IN ram.asm
                    > USED AT LINE 445 IN IOSerial.asm
OPCODES:            0A00 DEFINED AT LINE 18 IN ram.asm
                    > USED AT LINE 306 IN MAIN.asm
ALTCODES:           0A5E DEFINED AT LINE 20 IN ram.asm
                    > USED AT LINE 798 IN MAIN.asm
MINTVARS:           0B00 DEFINED AT LINE 24 IN ram.asm
VLOOPSP:            0B30 DEFINED AT LINE 26 IN ram.asm
TBPTR:              0B32 DEFINED AT LINE 28 IN ram.asm
VTEMP1:             0B34 DEFINED AT LINE 29 IN ram.asm
                    > USED AT LINE 913 IN MAIN.asm
                    > USED AT LINE 956 IN MAIN.asm
                    > USED AT LINE 1260 IN MAIN.asm
                    > USED AT LINE 1284 IN MAIN.asm
VTEMP2:             0B36 DEFINED AT LINE 30 IN ram.asm
                    > USED AT LINE 915 IN MAIN.asm
                    > USED AT LINE 949 IN MAIN.asm
RST08:              0B38 DEFINED AT LINE 32 IN ram.asm
                    > USED AT LINE 107 IN IOSerial.asm
                    > USED AT LINE 447 IN IOSerial.asm
RST10:              0B3A DEFINED AT LINE 33 IN ram.asm
                    > USED AT LINE 113 IN IOSerial.asm
                    > USED AT LINE 448 IN IOSerial.asm
RST18:              0B3C DEFINED AT LINE 34 IN ram.asm
                    > USED AT LINE 119 IN IOSerial.asm
                    > USED AT LINE 449 IN IOSerial.asm
RST20:              0B3E DEFINED AT LINE 35 IN ram.asm
                    > USED AT LINE 125 IN IOSerial.asm
                    > USED AT LINE 450 IN IOSerial.asm
RST28:              0B40 DEFINED AT LINE 36 IN ram.asm
                    > USED AT LINE 131 IN IOSerial.asm
                    > USED AT LINE 451 IN IOSerial.asm
RST30:              0B42 DEFINED AT LINE 37 IN ram.asm
                    > USED AT LINE 137 IN IOSerial.asm
                    > USED AT LINE 452 IN IOSerial.asm
BAUD:               0B44 DEFINED AT LINE 38 IN ram.asm
INTVEC:             0B46 DEFINED AT LINE 39 IN ram.asm
                    > USED AT LINE 143 IN IOSerial.asm
                    > USED AT LINE 453 IN IOSerial.asm
NMIVEC:             0B48 DEFINED AT LINE 40 IN ram.asm
                    > USED AT LINE 191 IN IOSerial.asm
                    > USED AT LINE 454 IN IOSerial.asm
GETCVEC:            0B4A DEFINED AT LINE 41 IN ram.asm
                    > USED AT LINE 435 IN IOSerial.asm
                    > USED AT LINE 457 IN IOSerial.asm
PUTCVEC:            0B4C DEFINED AT LINE 42 IN ram.asm
                    > USED AT LINE 440 IN IOSerial.asm
                    > USED AT LINE 459 IN IOSerial.asm
ALTVARS:            0B82 DEFINED AT LINE 45 IN ram.asm
                    > USED AT LINE 281 IN MAIN.asm
                    > USED AT LINE 789 IN MAIN.asm
VBYTEMODE:          0B84 DEFINED AT LINE 48 IN ram.asm
                    > USED AT LINE 705 IN MAIN.asm
                    > USED AT LINE 740 IN MAIN.asm
                    > USED AT LINE 936 IN MAIN.asm
                    > USED AT LINE 978 IN MAIN.asm
                    > USED AT LINE 980 IN MAIN.asm
                    > USED AT LINE 981 IN MAIN.asm
VCARRY:             0B86 DEFINED AT LINE 49 IN ram.asm
                    > USED AT LINE 1330 IN MAIN.asm
VELSE:              0B8A DEFINED AT LINE 51 IN ram.asm
                    > USED AT LINE 1272 IN MAIN.asm
                    > USED AT LINE 1318 IN MAIN.asm
VFALSE:             0B8C DEFINED AT LINE 52 IN ram.asm
VHEAPPTR:           0B90 DEFINED AT LINE 54 IN ram.asm
                    > USED AT LINE 296 IN MAIN.asm
                    > USED AT LINE 922 IN MAIN.asm
                    > USED AT LINE 951 IN MAIN.asm
                    > USED AT LINE 955 IN MAIN.asm
                    > USED AT LINE 1142 IN MAIN.asm
                    > USED AT LINE 1148 IN MAIN.asm
                    > USED AT LINE 1164 IN MAIN.asm
VTIBPTR:            0B96 DEFINED AT LINE 57 IN ram.asm
                    > USED AT LINE 162 IN MAIN.asm
                    > USED AT LINE 209 IN MAIN.asm
                    > USED AT LINE 213 IN MAIN.asm
                    > USED AT LINE 242 IN MAIN.asm
                    > USED AT LINE 404 IN MAIN.asm
VPOINTER:           0BA0 DEFINED AT LINE 62 IN ram.asm
                    > USED AT LINE 644 IN MAIN.asm
                    > USED AT LINE 702 IN MAIN.asm
VREMAIN:            0BA4 DEFINED AT LINE 64 IN ram.asm
                    > USED AT LINE 851 IN MAIN.asm
                    > USED AT LINE 909 IN MAIN.asm
VS0:                0BA6 DEFINED AT LINE 65 IN ram.asm
                    > USED AT LINE 292 IN MAIN.asm
VTRUE:              0BA8 DEFINED AT LINE 66 IN ram.asm
                    > USED AT LINE 288 IN MAIN.asm
VUNLIMITED:         0BAA DEFINED AT LINE 67 IN ram.asm
                    > USED AT LINE 290 IN MAIN.asm
VLASTDEF:           0BB4 DEFINED AT LINE 72 IN ram.asm
                    > USED AT LINE 294 IN MAIN.asm
                    > USED AT LINE 1146 IN MAIN.asm
VARS:               0BB6 DEFINED AT LINE 74 IN ram.asm
                    > USED AT LINE 297 IN MAIN.asm
                    > USED AT LINE 339 IN MAIN.asm
HEAP:               0C1E DEFINED AT LINE 76 IN ram.asm
                    > USED AT LINE 295 IN MAIN.asm
