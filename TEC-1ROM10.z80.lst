0000                          .ENGINE   mycomputer   
0000                             ; 
0000                TEC_1:    EQU   1   
0000                RC2014:   EQU   0   
0000                EXTENDED:   EQU   0   
0000                          IF   RC2014   
                                 ; Configuration for RC2014
                    ROMSTART:   EQU   $8000   
                    RAMSTART:   EQU   $8800   
                    LOADER:   EQU   0   
                    BITBANG:   EQU   0   
0000                          ENDIF      
0000                          IF   TEC_1   
0000                             ; Configuration for TEC-1
0000                LOADER:   EQU   0   
0000                BITBANG:   EQU   0   
0000                ROMSTART:   EQU   $0000   
0000                RAMSTART:   EQU   $0800   
0000                ROMSIZE:   EQU   $0800   
0000                RAMSIZE:   EQU   $0800   
0000                             ;TEC-1D SC 8k rom/ram
0000                             ; ROMSTART .equ $0000
0000                             ; RAMSTART .equ $2000
0000                             ; ROMSIZE  .equ 8192
0000                             ; RAMSIZE  .equ 8192
0000                          ENDIF      
0000                             ; ROM code
0000                             ; Targets:
0000                             ; TEC-1,TEC-1D,TEC-1F,Southern Cross,RC2014
0000                             ; Memory Map: 2k ROM/RAM, 8K ROM/RAM, RC2014
0000                             ; Serial: Bit Bang, 6850 ACIA
0000                             ; 
0000                          IF   TEC_1   
0000                          IF   BITBANG   
                                 ; 
                                 ; bit bang baud rate constants @ 4MHz
                    B300:     EQU   0220H   
                    B1200:    EQU   0080H   
                    B2400:    EQU   003FH   
                    B4800:    EQU   001BH   
                    B9600:    EQU   000BH   
                                 ; 
0000                          ELSE      ;6850
0000                             ; 
0000                             ; 
0000                             ; 6850 ACIA registers
0000                             ;----------------------
0000                CONTROL:   EQU   $80   ;(write) 
0000                STATUS:   EQU   $80   ;(read)
0000                TDR:      EQU   $81   ;(write)
0000                RDR:      EQU   $81   ;(read)
0000                             ; 
0000                             ; control register bits
0000                             ;----------------------
0000                             ; 
0000                             ;clock divisor
0000                             ; 
0000                MRESET:   EQU   $03   ;master reset the ACIA
0000                             ; DIV_0    .EQU  $00        ;CLOCK/1
0000                             ; DIV_16   .EQU  $01        ;CLOCK/16
0000                DIV_64:   EQU   $02   ;CLOCK/64
0000                             ; 
0000                             ; format select
0000                             ; 
0000                F7E2:     EQU   $00   ;7 data bits, EVEN parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7O2:     EQU   $04   ;7 data bits, ODD parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7E1:     EQU   $08   ;7 data bits, EVEN parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F7O1:     EQU   $0C   ;7 data bits, ODD parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F8N2:     EQU   $10   ;8 data bits, NO parity, 2 stop bits (1+8+0+2= 11 bits)
0000                F8N1:     EQU   $14   ;8 data bits, NO parity, 1 stop bit (1+8+0+1= 10 bits)
0000                F8E1:     EQU   $18   ;8 data bits, EVEN parity, 1 stop bit (1+8+1+1= 11 bits)
0000                F8O1:     EQU   $1C   ;8 data bits, ODD parity,1 stop bit (1+8+1+1= 11 bits)
0000                             ; 
0000                             ; transmitter control
0000                             ; 
0000                RTSLID:   EQU   $00   ;RTS LOW, transmit interrupt disabled
0000                RTSLIE:   EQU   $20   ;RTS LOW, transmit interrupt enabled
0000                RTSHID:   EQU   $40   ;RTS HIGH, transmit interrupt disabled
0000                RTSLIDB:   EQU   $60   ;RTS LOW, transmit interrupt disabled and "break" transmitted
0000                             ; 
0000                             ; receiver interrupt
0000                             ; 
0000                RIE:      EQU   $80   ;receiver interrupt enabled
0000                             ; 
0000                             ; status register bits
0000                             ;---------------------
0000                RDRF:     EQU   0   ;receive data register full
0000                TDRE:     EQU   1   ;transmit data register empty
0000                DCD:      EQU   2   ;data carrier detect
0000                CTS:      EQU   3   ;clear to send
0000                FE:       EQU   4   ;framing error
0000                OVRN:     EQU   5   ;overrun
0000                PE:       EQU   6   ;parity error
0000                IRQ:      EQU   7   ;interrupt request
0000                             ; 
0000                          ENDIF      
0000                          ENDIF      
0000                             ; 
0000                             ; I/O port addresses
0000                             ; 
0000                          IF   TEC_1   
0000                KEYBUF:   EQU   00H   ;MM74C923N KEYBOARD ENCODER
0000                SCAN:     EQU   01H   ;DISPLAY SCAN LATCH
0000                DISPLY:   EQU   02H   ;DISPLAY LATCH
0000                PORT3:    EQU   03H   ;ST3 (8X8), STROBE (RELAY BOARD) DATLATCH (DAT BOARD)
0000                PORT4:    EQU   04H   ;ST4 (8X8), LCD "E" (DAT BOARD)
0000                PORT5:    EQU   05H   
0000                PORT6:    EQU   06H   
0000                PORT7:    EQU   07H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ELSE      ;SC
                    IO0:      EQU   80H   ;IO PORT 0
                    IO1:      EQU   81H   ;IO PORT 1
                    IO2:      EQU   82H   ;IO PORT 2
                    IO3:      EQU   83H   ;IO PORT 3
                    DISPLY:   EQU   84H   ;DISPLAY LATCH
                    SCAN:     EQU   85H   ;DISPLAY SCAN LATCH
                    KEYBUF:   EQU   86H   ;KEYBOARD BUFFER
                    IO7:      EQU   87H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ENDIF      
0000                             ; 
0000                             ; ASCII codes
0000                ESC:      EQU   1BH   
0000                CR:       EQU   0DH   
0000                LF:       EQU   0AH   
0000                             ; 
0000                          .ORG   ROMSTART   
0000                             ;reset
0000                RSTVEC:      
0000   C3 8B 00               JP   RESET   
0003                             ;RST 1
0008                          .ORG   ROMSTART+$08   
0008   E5                     PUSH   HL   
0009   2A 38 0B               LD   HL,(RST08)   
000C   E9                     JP   (HL)   
000D                             ; 
000D                             ;RST 2
0010                          .ORG   ROMSTART+$10   
0010   E5                     PUSH   HL   
0011   2A 3A 0B               LD   HL,(RST10)   
0014   E9                     JP   (HL)   
0015                             ; 
0015                             ;RST 3
0018                          .ORG   ROMSTART+$18   
0018   E5                     PUSH   HL   
0019   2A 3C 0B               LD   HL,(RST18)   
001C   E9                     JP   (HL)   
001D                             ; 
001D                             ;RST 4
0020                          .ORG   ROMSTART+$20   
0020   E5                     PUSH   HL   
0021   2A 3E 0B               LD   HL,(RST20)   
0024   E9                     JP   (HL)   
0025                             ; 
0025                             ;RST 5
0028                          .ORG   ROMSTART+$28   
0028   E5                     PUSH   HL   
0029   2A 40 0B               LD   HL,(RST28)   
002C   E9                     JP   (HL)   
002D                             ; 
002D                             ;RST 6
0030                          .ORG   ROMSTART+$30   
0030   E5                     PUSH   HL   
0031   2A 42 0B               LD   HL,(RST30)   
0034   E9                     JP   (HL)   
0035                             ; 
0035                             ;RST 7 Interrupt
0038                          .ORG   ROMSTART+$38   
0038   E5                     PUSH   HL   
0039   2A 46 0B               LD   HL,(INTVEC)   
003C   E9                     JP   (HL)   
003D   ED 4D                  RETI      
003F                             ; 
0040                          .ORG   ROMSTART+$40   
0040                             ; 
0040                             ;hexadecimal to 7 segment display code table
0040                          IF   TEC_1   
0040                             ; 
0040                SEVENSEGMENT:      
0040   EB 28 CD AD            DB   0EBH,28H,0CDH,0ADH   ;0,1,2,3
0044   2E A7 E7 29            DB   2EH,0A7H,0E7H,29H   ;4,5,6,7
0048   EF 2F 6F E6            DB   0EFH,2FH,6FH,0E6H   ;8,9,A,B
004C   C3 EC C7 47            DB   0C3H,0ECH,0C7H,47H   ;C,D,E,F
0050                          ELSE      ;SC
                                 ; 
                    SEVENSEGMENT:      
                              DB   3FH,06H,5BH,4FH   ;0,1,2,3
                              DB   66H,6DH,7DH,07H   ;4,5,6,7
                              DB   7FH,6FH,77H,7CH   ;8,9,A,B
                              DB   39H,5EH,79H,71H   ;C,D,E,F
0050                          ENDIF      
0050                             ; 
0050                             ; 
0050                             ;---------------
0050                             ; BIT TIME DELAY
0050                             ;---------------
0050                             ;DELAY FOR ONE SERIAL BIT TIME
0050                             ;ENTRY : HL = DELAY TIME
0050                             ; NO REGISTERS MODIFIED
0050                             ; 
0050                PWRUP:       
0050   21 00 20               LD   hl,$2000   
0053                BITIME:      
0053   E5                     PUSH   HL   
0054   D5                     PUSH   DE   
0055   11 01 00               LD   DE,0001H   
0058                BITIM1:      
0058   ED 52                  SBC   HL,DE   
005A   D2 58 00               JP   NC,BITIM1   
005D   D1                     POP   DE   
005E   E1                     POP   HL   
005F                INTRET:      
005F   C9                     RET      
0060                             ; 
0060                             ;RST 8  Non Maskable Interrupt
0066                          .ORG   ROMSTART+$66   
0066   E5                     PUSH   HL   
0067   2A 48 0B               LD   HL,(NMIVEC)   
006A   E9                     JP   (HL)   
006B                             ; 
006B                             ; 
006B                          IF   BITBANG   
                                 ; 
                                 ;------------------------
                                 ; SERIAL TRANSMIT ROUTINE
                                 ;------------------------
                                 ;TRANSMIT BYTE SERIALLY ON DOUT
                                 ; 
                                 ; ENTRY : A = BYTE TO TRANSMIT
                                 ;  EXIT : NO REGISTERS MODIFIED
                                 ; 
                                 ; 
                    TXCHAR:      
                    TXDATA:      
                              PUSH   AF   
                              PUSH   BC   
                              PUSH   HL   
                              LD   HL,(BAUD)   
                              LD   C,A   
                                 ; 
                                 ; TRANSMIT START BIT
                                 ; 
                              XOR   A   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                                 ; 
                                 ; TRANSMIT DATA
                                 ; 
                              LD   B,08H   
                              RRC   C   
                    NXTBIT:      
                              RRC   C   ;SHIFT BITS TO D6,
                              LD   A,C   ;LSB FIRST AND OUTPUT
                              AND   40H   ;THEM FOR ONE BIT TIME.
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              DJNZ   NXTBIT   
                                 ; 
                                 ; SEND STOP BITS
                                 ; 
                              LD   A,40H   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              CALL   BITIME   
                              POP   HL   
                              POP   BC   
                              POP   AF   
                              RET      
                                 ;-----------------------
                                 ; SERIAL RECEIVE ROUTINE
                                 ;-----------------------
                                 ;RECEIVE SERIAL BYTE FROM DIN
                                 ; 
                                 ; ENTRY : NONE
                                 ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
                                 ; 
                                 ; REGISTERS MODIFIED A AND F
                                 ; 
                    RXCHAR:      
                    RXDATA:      
                              PUSH   BC   
                              PUSH   HL   
                                 ; 
                                 ; WAIT FOR START BIT 
                                 ; 
                    RXDAT1:   IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;NO START BIT
                                 ; 
                                 ; DETECTED START BIT
                                 ; 
                              LD   HL,(BAUD)   
                              SRL   H   
                              RR   L   ;DELAY FOR HALF BIT TIME
                              CALL   BITIME   
                              IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;START BIT NOT VALID
                                 ; 
                                 ; DETECTED VALID START BIT,READ IN DATA
                                 ; 
                              LD   B,08H   
                    RXDAT2:      
                              LD   HL,(BAUD)   
                              CALL   BITIME   ;DELAY ONE BIT TIME
                              IN   A,(KEYBUF)   
                              RL   A   
                              RR   C   ;SHIFT BIT INTO DATA REG
                              DJNZ   RXDAT2   
                              LD   A,C   
                              OR   A   ;CLEAR CARRY FLAG
                              POP   HL   
                              POP   BC   
                              RET      
                                 ; 
006B                          ELSE      ;6850
006B                             ; 
006B                             ; transmit a character in a
006B                             ;--------------------------
006B                TXDATA:      
006B                TXCHAR:      
006B   C5                     PUSH   bc   
006C   47                     LD   b,a   ;save the character  for later
006D                TXCHAR1:      
006D   DB 80                  IN   a,(STATUS)   ;get the ACIA status
006F   CB 4F                  BIT   1,a   
0071                             ;        bit   TDRE,a                ;is the TDRE bit high?
0071   28 FA                  JR   z,TxChar1   ;no, the TDR is not empty
0073   78                     LD   a,b   ;yes, get the character
0074   D3 81                  OUT   (TDR),a   ;and put it in the TDR
0076   C1                     POP   bc   
0077   C9                     RET      
0078                             ; 
0078                             ; receive  a character in a
0078                             ;---------------------------------
0078                RXDATA:      
0078                RXCHAR:      
0078   DB 80                  IN   a,(STATUS)   ;get the ACIA status
007A   CB 47                  BIT   0,a   
007C                             ;        bit   RDRF,a             ;is the RDRF bit high?
007C   28 FA                  JR   z,RxChar   ;no, the RDR is empty
007E   DB 81                  IN   a,(RDR)   ;yes, read the received char
0080   C9                     RET      
0081                          ENDIF      
0081                             ; 
0081                          IF   LOADER   
                                 ;   .ORG   ROMSTART + $0700
                                 ;-----------------------
                                 ; RECEIVE INTEL HEX FILE
                                 ;-----------------------
                    INTELH:      
                              LD   IX,BUF   
                                 ; 
                                 ; WAIT FOR RECORD MARK
                                 ; 
                    INTEL1:      
                              XOR   A   
                              LD   (IX+3),A   ;CLEAR CHECKSUM
                              CALL   RXDATA   ;WAIT FOR THE RECORD MARK
                              CP   ":"   ;TO BE TRANSMITTED
                              JR   NZ,INTEL1   ;NOT RECORD MARK
                                 ; 
                                 ; GET RECORD LENGTH
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+0),A   ;NUMBER OF DATA BYTES
                                 ; 
                                 ; GET ADDRESS FIELD
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+2),A   ;LOAD ADDRESS HIGH BYTE
                              CALL   GETBYT   
                              LD   (IX+1),A   ;LOAD ADDRESS LOW BYTE
                                 ; 
                                 ; GET RECORD TYPE
                                 ; 
                              CALL   GETBYT   
                              JR   NZ,INTEL4   ;END OF FILE RECORD
                                 ; 
                                 ; READ IN THE DATA
                                 ; 
                              LD   B,(IX+0)   ;NUMBER OF DATA BYTES
                              LD   H,(IX+2)   ;LOAD ADDRESS HIGH BYTE
                              LD   L,(IX+1)   ;LOAD ADDRESS LOW BYTE
                                 ; 
                    INTEL2:      
                              CALL   GETBYT   ;GET DATA BYTE
                              LD   (HL),A   ;STORE DATA BYTE
                              INC   HL   
                              DJNZ   INTEL2   ;LOAD MORE BYTES
                                 ; 
                                 ; GET CHECKSUM AND COMPARE
                                 ; 
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE RECORD CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              JR   Z,INTEL1   ;CHECKSUM OK,NEXT RECORD
                              RET      ;NZ=CHECKSUM ERROR
                                 ; 
                                 ; END OF FILE RECORD
                                 ; 
                    INTEL4:      
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE EOF CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              RET      ;NZ=CHECKSUM ERROR
                                 ;--------------------------
                                 ; GET BYTE FROM SERIAL PORT
                                 ;--------------------------
                    GETBYT:      
                              PUSH   BC   
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT1   
                              ADD   A,09H   
                    GETBT1:      
                              AND   0FH   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              LD   C,A   
                                 ; 
                                 ; GET LOW NYBBLE
                                 ; 
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT2   
                              ADD   A,09H   
                    GETBT2:   AND   0FH   
                              OR   C   
                              LD   B,A   
                              ADD   A,(IX+3)   
                              LD   (IX+3),A   ;ADD TO CHECKSUM
                              LD   A,B   
                              AND   A   ;CLEAR CARRY
                              POP   BC   
                              RET      
0081                          ENDIF      
0081                             ; 
0081                             ; in this example code just wait for an INTEL Hex file download
0081                             ;just going to send a char to let you know I'm here
0081                          IF   LOADER   
                                 ; 
                    LOAD:        
                              LD   a,"L"   ; L for load
                              CALL   TxChar   
                              CALL   INTELH   
                              JP   z,RAMSTART   ;assume the downloaded code starts here
                              LD   a,"0"   ;0 is false
                              CALL   TxChar   
                              JR   load   ;if at first you don't succeed...
0081                          ENDIF      
0081                             ; 
0081                GETCHAR:      
0081   2A 4A 0B               LD   HL,(GETCVEC)   
0084   E9                     JP   (HL)   
0085                             ; 
0085                PUTCHAR:      
0085   E5                     PUSH   HL   
0086   2A 4C 0B               LD   HL,(PUTCVEC)   
0089   E3                     EX   (SP),HL   
008A   C9                     RET      
008B                             ; 
008B                RESET:       
008B   31 00 0A               LD   SP,stack   
008E   21 5F 00               LD   HL,IntRet   
0091   22 38 0B               LD   (RST08),HL   
0094   22 3A 0B               LD   (RST10),HL   
0097   22 3C 0B               LD   (RST18),HL   
009A   22 3E 0B               LD   (RST20),HL   
009D   22 40 0B               LD   (RST28),HL   
00A0   22 42 0B               LD   (RST30),HL   
00A3   22 46 0B               LD   (INTVEC),HL   
00A6   22 48 0B               LD   (NMIVEC),HL   
00A9                             ; 
00A9   21 78 00               LD   HL,RXDATA   
00AC   22 4A 0B               LD   (GETCVEC),HL   
00AF   21 6B 00               LD   HL,TXDATA   
00B2   22 4C 0B               LD   (PUTCVEC),HL   
00B5                             ; 
00B5                          IF   TEC_1   
00B5                          IF   BITBANG = 0   
00B5                             ; 
00B5   3E 03                  LD   a,MRESET   
00B7   D3 80                  OUT   (CONTROL),a   ;reset the ACIA
00B9                             ; 
00B9                          ENDIF      
00B9                          ENDIF      
00B9                             ; 
00B9   CD 50 00               CALL   PWRUP   
00BC   ED 56                  IM   1   
00BE   FB                     EI      
00BF                             ; 
00BF                          IF   TEC_1   
00BF                          IF   BITBANG   
                                 ; 
                                 ;inline serial initialisation
                              LD   A,$40   
                              LD   C,SCAN   
                              OUT   (C),A   
                              LD   HL,B4800   
                              LD   (BAUD),HL   
                                 ; 
00BF                          ELSE      ;6850      
00BF                             ; 
00BF   3E 12                  LD   a,RTSLID+F8N2+DIV_64   
00C1   D3 80                  OUT   (CONTROL),a   ;initialise ACIA  8 bit word, No parity 2 stop divide by 64 for 115200 baud
00C3                             ; 
00C3                          ENDIF      
00C3                          ENDIF      
00C3                             ; 
00C3                             ; 
00C3                             ; 
00C3   C3 05 02               JP   start   
00C6                             ; 
00C6                             ; *************************************************************************
00C6                             ; 
00C6                             ;       Mondo Minimal Interpreter for the z80
00C6                             ; 
00C6                             ;       John Hardy with additional code by Ken Boak and Craig Jones.
00C6                             ; 
00C6                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
00C6                             ; 
00C6                             ;       see the LICENSE file in this repo for more information
00C6                             ; 
00C6                             ; *****************************************************************************
00C6                FALSE:    EQU   0   
00C6                TRUE:     EQU   -1   
00C6                UNLIMITED:   EQU   -2   ; for endless loops
00C6                CTRL_C:   EQU   3   ; end of text
00C6                CTRL_E:   EQU   5   ; edit
00C6                CTRL_H:   EQU   8   ; backspace
00C6                CTRL_J:   EQU   10   ; re-edit
00C6                CTRL_P:   EQU   16   ; print stack
00C6                BSLASH:   EQU   $5c   
00C6                .macro LITDAT,len
00C6                             ; 
00C6                 db len
00C6                .endm
00C6                 
00C6                .macro REPDAT,len,data
00C6                             ; 
00C6                 db (len | $80)
00C6                 db data
00C6                .endm
00C6                 
00C6                .macro ENDDAT,
00C6                             ; 
00C6                 db 0
00C6                .endm
00C6                 
00C6                             ; **************************************************************************
00C6                             ; Page 0  Initialisation
00C6                             ; **************************************************************************		
0180                          .ORG   ROMSTART + $180   ; 0+180 put Mondo code from here	
0180                             ; **************************************************************************
0180                             ; Macros must be written in Mondo and end with ;
0180                             ; this code must not span pages
0180                             ; **************************************************************************
0180                MACROS:      
0180                REEDIT_:      
0180   2F 7A 2F 55 45 3B      DB   "/z/UE;"   ; remembers last line edited
0186                EDIT_:       
0186   60 3F 60 2F 4B 2F 55 50 2F 55 45 3B 00 .CSTR   "`?`/K/UP/UE;"   
0193                PRINTSTACK_:      
0193   60 3D 3E 20 60 2F 73 32 2D 2F 55 44 31 2D 28 23 30 40 2C 32 2D 29 5C 2F 4E 2F 55 50 3B 00 .CSTR   "`=> `/s2-/UD1-(#0@,2-)\\/N/UP;"   
01B1                IOPCODES:      
01B1                          ;*Macro unroll:  LITDAT 15
01B1   0F                     DB   15   
01B2   66                     DB   lsb(bang_)   ;    !
01B3   00                     DB   lsb(dquote_)   ;    "
01B4   44                     DB   lsb(hash_)   ;    #
01B5   49                     DB   lsb(dollar_)   ;    $
01B6   4E                     DB   lsb(percent_)   ;    %
01B7   02                     DB   lsb(amper_)   ;    &
01B8   EE                     DB   lsb(quote_)   ;    '
01B9   DF                     DB   lsb(lparen_)   ;    (
01BA   E2                     DB   lsb(rparen_)   ;    )
01BB   F0                     DB   lsb(star_)   ;    *
01BC   1F                     DB   lsb(plus_)   ;    +
01BD   3B                     DB   lsb(comma_)   ;    ,
01BE   70                     DB   lsb(minus_)   ;    -
01BF   30                     DB   lsb(dot_)   ;    .
01C0   F2                     DB   lsb(slash_)   ;    /	;/MOD
01C1                          ;*Macro unroll:  REPDAT 10, lsb(num_)		; 10 x repeat lsb of add to the num routine
01C1   8A                     DB   (10 | $80)   ; 10 x repeat lsb of add to the num routine
01C2   E5                     DB   lsb(num_)   
01C3                          ;*Macro unroll:  LITDAT 7
01C3   07                     DB   7   
01C4   E8                     DB   lsb(colon_)   ;    :
01C5   55                     DB   lsb(semi_)   ;    ;
01C6   9C                     DB   lsb(lt_)   ;    <
01C7   85                     DB   lsb(eq_)   ;    =
01C8   98                     DB   lsb(gt_)   ;    >
01C9   00                     DB   lsb(question_)   ;    ?   ( -- val )  read a char from input
01CA   D2                     DB   lsb(at_)   ;    @
01CB                          ;*Macro unroll:  REPDAT 26, lsb(call_)	; call a command A, B ....z
01CB   9A                     DB   (26 | $80)   ; call a command A, B ....z
01CC   26                     DB   lsb(call_)   
01CD                          ;*Macro unroll:  LITDAT 6
01CD   06                     DB   6   
01CE   C9                     DB   lsb(lbrack_)   ;    [
01CF   41                     DB   lsb(bslash_)   ;    \
01D0   EB                     DB   lsb(rbrack_)   ;    ]
01D1   16                     DB   lsb(caret_)   ;    ^
01D2   00                     DB   lsb(underscore_)   ;    _
01D3   BA                     DB   lsb(grave_)   ;    `   ; for printing `hello`
01D4                          ;*Macro unroll:  REPDAT 26, lsb(var_)	; a b c .....z
01D4   9A                     DB   (26 | $80)   ; a b c .....z
01D5   A5                     DB   lsb(var_)   
01D6                          ;*Macro unroll:  LITDAT 4
01D6   04                     DB   4   
01D7   00                     DB   lsb(lbrace_)   ;    {
01D8   0D                     DB   lsb(pipe_)   ;    |
01D9   00                     DB   lsb(rbrace_)   ;    }
01DA   5C                     DB   lsb(tilde_)   ;    ~ ( a b c -- b c a ) rotate
01DB                IALTCODES:      
01DB                          ;*Macro unroll:  LITDAT 24
01DB   18                     DB   24   
01DC   06                     DB   lsb(aNop_)   ;A
01DD   08                     DB   lsb(bmode_)   ;B      toggle byte mode
01DE   06                     DB   lsb(aNop_)   ;C
01DF   06                     DB   lsb(aNop_)   ;D
01E0   14                     DB   lsb(emit_)   ;E      emit a char
01E1   06                     DB   lsb(aNop_)   ;F      false
01E2   2C                     DB   lsb(go_)   ;G      execute Mondo code
01E3   06                     DB   lsb(aNop_)   ;H      toggle hex mode
01E4   41                     DB   lsb(inPort_)   ;I      input from port
01E5   06                     DB   lsb(aNop_)   ;J      loop variable
01E6   23                     DB   lsb(key_)   ;K      input char
01E7   5A                     DB   lsb(shl_)   ;L
01E8   06                     DB   lsb(aNop_)   ;M
01E9   4C                     DB   lsb(newln_)   ;N      prints a newline to output
01EA   51                     DB   lsb(outPort_)   ;O      output to port
01EB   06                     DB   lsb(aNop_)   ;P      print Mondo prompt
01EC   06                     DB   lsb(aNop_)   ;Q
01ED   69                     DB   lsb(shr_)   ;R
01EE   00                     DB   lsb(arrSize_)   ;S      array size
01EF   06                     DB   lsb(aNop_)   ;T      true
01F0   7B                     DB   lsb(utility_)   ;U
01F1   06                     DB   lsb(aNop_)   ;V
01F2   A3                     DB   lsb(while_)   ;W      word mode
01F3   1B                     DB   lsb(exec_)   ;X      execute machine code
01F4                          ;*Macro unroll:  REPDAT 3, lsb(aNop_)
01F4   83                     DB   (3 | $80)   
01F5   06                     DB   lsb(aNop_)   
01F6                             ;Y
01F6                             ;Z
01F6                          ;*Macro unroll:  ENDDAT
01F6   00                     DB   0   
01F7                BACKSPACE:      
01F7   79                     LD   a,c   
01F8   B0                     OR   b   
01F9   28 29                  JR   z,interpret2   
01FB   0B                     DEC   bc   
01FC   CD C4 03               CALL   printStr   
01FF   08 20 08 00            .CSTR   "\b \b"   
0203   18 1F                  JR   interpret2   
0205                START:       
0205   31 00 0A               LD   SP,DSTACK   ; start of Mondo
0208   CD C7 02               CALL   init   ; setups
020B   CD C4 03               CALL   printStr   ; prog count to stack, put code line 235 on stack then call print
020E   4D 6F 6E 64 6F 20 30 2E 31 0D 0A 00 .CSTR   "Mondo 0.1\r\n"   
021A                INTERPRET:      
021A   CD B4 03               CALL   prompt   
021D   01 00 00               LD   bc,0   ; load bc with offset into TIb, decide char into tib or execute or control
0220   ED 43 96 0B            LD   (vTIBPtr),bc   
0224                INTERPRET2:      ; calc nesting (a macro might have changed it)
0224   1E 00                  LD   e,0   ; initilize nesting value
0226   C5                     PUSH   bc   ; save offset into TIb,
0227                             ; bc is also the count of chars in TIB
0227   21 00 08               LD   hl,TIB   ; hl is start of TIB
022A   18 06                  JR   interpret4   
022C                INTERPRET3:      
022C   7E                     LD   a,(hl)   ; A = char in TIB
022D   23                     INC   hl   ; inc pointer into TIB
022E   0B                     DEC   bc   ; dec count of chars in TIB
022F   CD 88 03               CALL   nesting   ; update nesting value
0232                INTERPRET4:      
0232   79                     LD   a,c   ; is count zero?
0233   B0                     OR   B   
0234   20 F6                  JR   nz,interpret3   ; if not loop
0236   C1                     POP   bc   ; restore offset into TIB
0237                WAITCHAR:      
0237   CD 81 00               CALL   getchar   ; loop around waiting for character from serial port
023A   FE 20                  CP   $20   ; compare to space
023C   30 33                  JR   nc,waitchar1   ; if >= space, if below 20 set cary flag
023E   FE 00                  CP   $0   ; is it end of string? null end of string
0240   28 53                  JR   z,waitchar4   
0242   FE 0D                  CP   "\r"   ; carriage return? ascii 13
0244   28 39                  JR   z,waitchar3   ; if anything else its macro/control
0246   FE 08                  CP   CTRL_H   
0248   28 AD                  JR   z,backSpace   
024A   16 01                  LD   d,msb(macros)   
024C   FE 05                  CP   CTRL_E   
024E   1E 86                  LD   e,lsb(edit_)   
0250   28 0E                  JR   z,macro   
0252   FE 0A                  CP   CTRL_J   
0254   1E 80                  LD   e,lsb(reedit_)   
0256   28 08                  JR   z,macro   
0258   FE 10                  CP   CTRL_P   
025A   1E 93                  LD   e,lsb(printStack_)   
025C   28 02                  JR   z,macro   
025E   18 C4                  JR   interpret2   
0260                MACRO:       
0260   ED 43 96 0B            LD   (vTIBPtr),bc   
0264   D5                     PUSH   de   
0265   CD EF 03               CALL   ENTER   ;Mondo go operation and jump to it
0268   2F 47 00               .CSTR   "/G"   
026B   ED 4B 96 0B            LD   bc,(vTIBPtr)   
026F   18 B3                  JR   interpret2   
0271                WAITCHAR1:      
0271   21 00 08               LD   hl,TIB   
0274   09                     ADD   hl,bc   
0275   77                     LD   (hl),A   ; store the character in textbuf
0276   03                     INC   bc   
0277   CD 85 00               CALL   putchar   ; echo character to screen
027A   CD 88 03               CALL   nesting   
027D   18 B8                  JR   waitchar   ; wait for next character
027F                WAITCHAR3:      
027F   21 00 08               LD   hl,TIB   
0282   09                     ADD   hl,bc   
0283   36 0D                  LD   (hl),"\r"   ; store the crlf in textbuf
0285   23                     INC   hl   
0286   36 0A                  LD   (hl),"\n"   
0288   23                     INC   hl   ; ????
0289   03                     INC   bc   
028A   03                     INC   bc   
028B   CD BD 03               CALL   crlf   ; echo character to screen
028E   7B                     LD   a,E   ; if zero nesting append and ETX after \r
028F   B7                     OR   A   
0290   20 A5                  JR   nz,waitchar   
0292   36 03                  LD   (hl),$03   ; store end of text ETX in text buffer
0294   03                     INC   bc   
0295                WAITCHAR4:      
0295   ED 43 96 0B            LD   (vTIBPtr),bc   
0299   01 00 08               LD   bc,TIB   ; Instructions stored on heap at address HERe, we pressed enter
029C   0B                     DEC   bc   
029D                NEXT:        ; 
029D   03                     INC   bc   ;       Increment the IP
029E   0A                     LD   a,(bc)   ;       Get the next character and dispatch
029F   B7                     OR   a   ; is it NUL?
02A0   28 0F                  JR   z,exit   
02A2   FE 03                  CP   cTRL_c   
02A4   28 15                  JR   z,etx   
02A6   D6 21                  SUB   "!"   
02A8   38 F3                  JR   c,NexT   
02AA   6F                     LD   L,A   ;       Index into table
02AB   26 0A                  LD   H,msb(opcodes)   ;       Start address of jump table
02AD   6E                     LD   L,(hl)   ;       get low jump address
02AE   26 04                  LD   H,msb(page4)   ;       Load H with the 1st page address
02B0   E9                     JP   (hl)   ;       Jump to routine
02B1                EXIT:        
02B1   03                     INC   bc   ; store offests into a table of bytes, smaller
02B2   50 59                  LD   de,bc   
02B4   CD DF 03               CALL   rpop   ; Restore Instruction pointer
02B7   44 4D                  LD   bc,hl   
02B9   EB                     EX   de,hl   
02BA   E9                     JP   (hl)   
02BB                ETX:         
02BB   21 00 F6               LD   hl,-DSTACK   ; check if stack pointer is underwater
02BE   39                     ADD   hl,SP   
02BF   30 03                  JR   nc,etx1   
02C1   31 00 0A               LD   SP,DSTACK   
02C4                ETX1:        
02C4   C3 1A 02               JP   interpret   
02C7                INIT:        
02C7   DD 21 80 09            LD   ix,RSTACK   
02CB   FD 21 9D 02            LD   iy,NexT   ; iy provides a faster jump to NexT
02CF   21 82 0B               LD   hl,altVars   ; init altVars to 0
02D2   06 34                  LD   b,26 * 2   
02D4                INIT1:       
02D4   36 00                  LD   (hl),0   
02D6   23                     INC   hl   
02D7   10 FB                  DJNZ   init1   
02D9   21 FF FF               LD   hl,TRUE   ; hl = TRUE
02DC   22 A8 0B               LD   (vTrue),hl   
02DF   2B                     DEC   hl   ; hl = Unlimited
02E0   22 AA 0B               LD   (vUnlimited),hl   
02E3   21 00 0A               LD   hl,DSTACK   
02E6   22 A6 0B               LD   (vS0),hl   
02E9   21 41 00               LD   hl,65   
02EC   22 B4 0B               LD   (vLastDef),hl   
02EF   21 1E 0C               LD   hl,hEAP   
02F2   22 90 0B               LD   (vHeapPtr),hl   
02F5   21 B6 0B               LD   hl,VARS   ; init namespaces to 0 using LDIR
02F8   54 5D                  LD   de,hl   
02FA   13                     INC   de   
02FB   36 00                  LD   (hl),0   
02FD   01 68 00               LD   bc,VARS_SIZE   
0300   ED B0                  LDIR      
0302                INITOPS:      
0302   21 B1 01               LD   hl,iOpcodes   
0305   11 00 0A               LD   de,opcodes   
0308   01 00 01               LD   bc,256   
030B                INITOPS1:      
030B   7E                     LD   a,(hl)   
030C   23                     INC   hl   
030D   CB 27                  SLA   A   
030F   C8                     RET   z   
0310   38 09                  JR   c,initOps2   
0312   CB 3F                  SRL   A   
0314   4F                     LD   c,A   
0315   06 00                  LD   b,0   
0317   ED B0                  LDIR      
0319   18 F0                  JR   initOps1   
031B                INITOPS2:      
031B   CB 3F                  SRL   A   
031D   47                     LD   b,A   
031E   7E                     LD   a,(hl)   
031F   23                     INC   hl   
0320                INITOPS2A:      
0320   12                     LD   (de),A   
0321   13                     INC   de   
0322   10 FC                  DJNZ   initOps2a   
0324   18 E5                  JR   initOps1   
0326                LOOKUP:      
0326   D6 41                  SUB   "A"   
0328   18 02                  JR   lookup2   
032A                LOOKUP1:      
032A   D6 47                  SUB   "a" - 26   
032C                LOOKUP2:      
032C   87                     ADD   A,A   
032D   21 B6 0B               LD   hl,VARS   
0330   85                     ADD   A,l   
0331   6F                     LD   l,a   
0332   3E 00                  LD   a,0   
0334   8C                     ADC   a,h   
0335   67                     LD   h,a   
0336   AF                     XOR   a   
0337   B3                     OR   E   ; sets z flag if A-z
0338   C9                     RET      
0339                PRINTHEX:      
0339                             ; Display hl as a 16-bit number in hex.
0339   C5                     PUSH   bc   ; preserve the IP
033A   7C                     LD   a,h   
033B   CD 44 03               CALL   printhex2   
033E   7D                     LD   a,l   
033F   CD 44 03               CALL   printhex2   
0342   C1                     POP   bc   
0343   C9                     RET      
0344                PRINTHEX2:      
0344   4F                     LD   c,A   
0345   1F                     RRA      
0346   1F                     RRA      
0347   1F                     RRA      
0348   1F                     RRA      
0349   CD 4D 03               CALL   printhex3   
034C   79                     LD   a,c   
034D                PRINTHEX3:      
034D   E6 0F                  AND   0x0F   
034F   C6 90                  ADD   A,0x90   
0351   27                     DAA      
0352   CE 40                  ADC   A,0x40   
0354   27                     DAA      
0355   C3 85 00               JP   putchar   
0358                EDITDEF:      ; lookup up def based on number
0358   E1                     POP   hl   ; pop ret address
0359                             ; ex (SP),hl                  ; swap with TOS
0359   7D                     LD   a,l   
035A   08                     EX   AF,AF'   
035B   7D                     LD   a,l   
035C   CD 26 03               CALL   lookup   
035F   5E                     LD   e,(hl)   
0360   23                     INC   hl   
0361   56                     LD   d,(hl)   
0362   7A                     LD   a,D   
0363   B3                     OR   E   
0364   21 00 08               LD   hl,TIB   
0367   28 14                  JR   z,editDef3   
0369   3E 3A                  LD   a,":"   
036B   CD EA 03               CALL   writechar   
036E   08                     EX   AF,AF'   
036F   CD EA 03               CALL   writechar   
0372   18 01                  JR   editDef2   
0374                EDITDEF1:      
0374   13                     INC   de   
0375                EDITDEF2:      
0375   1A                     LD   a,(de)   
0376   CD EA 03               CALL   writechar   
0379   FE 3B                  CP   ";"   
037B   20 F7                  JR   nz,editDef1   
037D                EDITDEF3:      
037D   11 00 08               LD   de,TIB   
0380   B7                     OR   A   
0381   ED 52                  SBC   hl,de   
0383   22 96 0B               LD   (vTIBPtr),hl   
0386   FD E9                  JP   (iy)   
0388                             ; **************************************************************************
0388                             ; calculate nesting value
0388                             ; A is char to be tested,
0388                             ; E is the nesting value (initially 0)
0388                             ; E is increased by ( and [
0388                             ; E is decreased by ) and ]
0388                             ; E has its bit 7 toggled by `
0388                             ; limited to 127 levels
0388                             ; **************************************************************************
0388                NESTING:      
0388   FE 60                  CP   "`"   
038A   20 05                  JR   nz,nesting1   
038C   3E 80                  LD   a,$80   
038E   AB                     XOR   e   
038F   5F                     LD   e,a   
0390   C9                     RET      
0391                NESTING1:      
0391   FE 3A                  CP   ":"   
0393   28 0C                  JR   z,nesting2   
0395   FE 5B                  CP   "["   
0397   28 08                  JR   z,nesting2   
0399   FE 7B                  CP   "{"   
039B   28 04                  JR   z,nesting2   
039D   FE 28                  CP   "("   
039F   20 02                  JR   nz,nesting3   
03A1                NESTING2:      
03A1   1C                     INC   E   
03A2   C9                     RET      
03A3                NESTING3:      
03A3   FE 3B                  CP   ";"   
03A5   28 0B                  JR   z,nesting4   
03A7   FE 5D                  CP   "]"   
03A9   28 07                  JR   z,nesting4   
03AB   FE 7D                  CP   "}"   
03AD   28 03                  JR   z,nesting4   
03AF   FE 29                  CP   ")"   
03B1   C0                     RET   nz   
03B2                NESTING4:      
03B2   1D                     DEC   E   
03B3   C9                     RET      
03B4                PROMPT:      
03B4   CD C4 03               CALL   printStr   
03B7   0D 0A 3E 20 00         .CSTR   "\r\n> "   
03BC   C9                     RET      
03BD                CRLF:        
03BD   CD C4 03               CALL   printStr   
03C0   0D 0A 00               .CSTR   "\r\n"   
03C3   C9                     RET      
03C4                PRINTSTR:      
03C4   E3                     EX   (SP),hl   ; swap			
03C5   CD CF 03               CALL   putStr   
03C8   23                     INC   hl   ; inc past null
03C9   E3                     EX   (SP),hl   ; put it back	
03CA   C9                     RET      
03CB                PUTSTR0:      
03CB   CD 85 00               CALL   putchar   
03CE   23                     INC   hl   
03CF                PUTSTR:      
03CF   7E                     LD   a,(hl)   
03D0   B7                     OR   A   
03D1   20 F8                  JR   nz,putStr0   
03D3   C9                     RET      
03D4                RPUSH:       
03D4   DD 2B                  DEC   ix   
03D6   DD 74 00               LD   (ix+0),h   
03D9   DD 2B                  DEC   ix   
03DB   DD 75 00               LD   (ix+0),l   
03DE   C9                     RET      
03DF                RPOP:        
03DF   DD 6E 00               LD   L,(ix+0)   
03E2   DD 23                  INC   ix   
03E4   DD 66 00               LD   H,(ix+0)   
03E7   DD 23                  INC   ix   
03E9                RPOP2:       
03E9   C9                     RET      
03EA                WRITECHAR:      
03EA   77                     LD   (hl),A   
03EB   23                     INC   hl   
03EC   C3 85 00               JP   putchar   
03EF                ENTER:       
03EF   60 69                  LD   hl,bc   
03F1   CD D4 03               CALL   rpush   ; save Instruction Pointer
03F4   C1                     POP   bc   
03F5   0B                     DEC   bc   
03F6   FD E9                  JP   (iy)   
03F8                             ; **********************************************************************			
03F8                             ; Page 4 primitive routines
03F8                             ; **********************************************************************
03F8                          ALIGN   $100   
0400                PAGE4:       
0400                DQUOTE_:      
0400                QUESTION_:      
0400                LBRACE_:      
0400                RBRACE_:      
0400                UNDERSCORE_:      
0400   FD E9                  JP   (iy)   
0402                AMPER_:      
0402                AND_:        
0402   D1                     POP   de   ;     bitwise and the top 2 elements of the stack
0403   E1                     POP   hl   ; 
0404   7B                     LD   A,E   ; 
0405   A5                     AND   L   ; 
0406   6F                     LD   L,A   ; 
0407   7A                     LD   A,D   ; 
0408   A4                     AND   H   ; 
0409                AND1:        
0409   67                     LD   H,A   ; 
040A   E5                     PUSH   hl   ; 
040B   FD E9                  JP   (iy)   ; 
040D                PIPE_:       
040D                OR_:         
040D   D1                     POP   de   ; bitwise or the top 2 elements of the stack
040E   E1                     POP   hl   
040F   7B                     LD   A,E   
0410   B5                     OR   L   
0411   6F                     LD   L,A   
0412   7A                     LD   A,D   
0413   B4                     OR   H   
0414   18 F3                  JR   and1   
0416                CARET_:      
0416                XOR_:        
0416   D1                     POP   de   ; bitwise xor the top 2 elements of the stack
0417   E1                     POP   hl   
0418   7B                     LD   A,E   
0419   AD                     XOR   L   
041A   6F                     LD   L,A   
041B   7A                     LD   A,D   
041C   AC                     XOR   H   
041D   18 EA                  JR   and1   
041F                PLUS_:       ; add the top 2 members of the stack
041F                ADD_:        
041F   D1                     POP   de   
0420   E1                     POP   hl   
0421   19                     ADD   hl,de   
0422   E5                     PUSH   hl   
0423   C3 D8 07               JP   carry   
0426                CALL_:       
0426   0A                     LD   a,(bc)   
0427   CD 26 03               CALL   lookup   
042A   5E                     LD   e,(hl)   
042B   23                     INC   hl   
042C   56                     LD   d,(hl)   
042D   C3 2D 06               JP   go1   
0430                DOT_:        
0430   E1                     POP   hl   
0431   CD 10 07               CALL   printDec   
0434                DOT2:        
0434   3E 20                  LD   a," "   
0436   CD 85 00               CALL   putchar   
0439   FD E9                  JP   (iy)   
043B                COMMA_:      ; print hexadecimal
043B                HDOT_:       
043B   E1                     POP   hl   
043C   CD 39 03               CALL   printhex   
043F   18 F3                  JR   dot2   
0441                BSLASH_:      
0441                DROP_:       
0441   E1                     POP   hl   
0442   FD E9                  JP   (iy)   
0444                HASH_:       
0444                DUP_:        
0444   E1                     POP   hl   ; Duplicate the top member of the stack
0445   E5                     PUSH   hl   
0446   E5                     PUSH   hl   
0447   FD E9                  JP   (iy)   
0449                             ; $ swap                        ; a b -- b a Swap the top 2 elements of the stack
0449                DOLLAR_:      
0449                SWAP_:       
0449   E1                     POP   hl   
044A   E3                     EX   (SP),hl   
044B   E5                     PUSH   hl   
044C   FD E9                  JP   (iy)   
044E                PERCENT_:      
044E                OVER_:       
044E   E1                     POP   hl   ; Duplicate 2nd element of the stack
044F   D1                     POP   de   
0450   D5                     PUSH   de   
0451   E5                     PUSH   hl   
0452   D5                     PUSH   de   ; and push it to top of stack
0453   FD E9                  JP   (iy)   
0455                SEMI_:       
0455                RET_:        
0455   CD DF 03               CALL   rpop   ; Restore Instruction pointer
0458   44 4D                  LD   bc,hl   
045A   FD E9                  JP   (iy)   
045C                TILDE_:      
045C                NOT:         
045C   E1                     POP   hl   
045D   7D                     LD   a,l   
045E   2F                     CPL      
045F   6F                     LD   l,a   
0460   7C                     LD   a,h   
0461   2F                     CPL      
0462   67                     LD   h,a   
0463   E5                     PUSH   hl   
0464   FD E9                  JP   (iy)   
0466                BANG_:       ; Store the value at the address placed on the top of the stack
0466                STORE_:      
0466                ASSIGN:      
0466   D1                     POP   de   ; discard last accessed value
0467   D1                     POP   de   ; de = new value
0468                ASSIGN0:      
0468   2A A0 0B               LD   hl,(vPointer)   ; hl = pointer
046B                ASSIGN1:      
046B   73                     LD   (hl),e   ; ignore byte mode to allow assigning to vByteMode
046C   23                     INC   hl   
046D   72                     LD   (hl),d   
046E   FD E9                  JP   (iy)   
0470                MINUS_:      ; Subtract the value 2nd on stack from top of stack
0470                SUB_:        
0470   03                     INC   bc   ; check if sign of a number
0471   0A                     LD   a,(bc)   
0472   0B                     DEC   bc   
0473   FE 30                  CP   "0"   
0475   38 05                  JR   c,sub1   
0477   FE 3A                  CP   "9"+1   
0479   DA E0 06               JP   c,num   
047C                SUB1:        
047C   D1                     POP   de   ; 
047D   E1                     POP   hl   ;      Entry point for INVert
047E                SUB2:        
047E   A7                     AND   A   ;      Entry point for NEGate
047F   ED 52                  SBC   hl,de   ; 
0481   E5                     PUSH   hl   ; 
0482   C3 D8 07               JP   carry   
0485                             ; 5
0485                EQ_:         
0485   E1                     POP   hl   
0486   D1                     POP   de   
0487   B7                     OR   a   ; reset the carry flag
0488   ED 52                  SBC   hl,de   ; only equality sets hl=0 here
048A   28 06                  JR   z,true_   
048C                FALSE_:      
048C   21 00 00               LD   hl,FALSE   
048F   E5                     PUSH   hl   
0490   FD E9                  JP   (iy)   
0492                TRUE_:       
0492   21 FF FF               LD   hl,TRUE   
0495   E5                     PUSH   hl   
0496   FD E9                  JP   (iy)   
0498                GT_:         
0498   E1                     POP   hl   
0499   D1                     POP   de   
049A   18 02                  JR   lt1_   
049C                LT_:         
049C   D1                     POP   de   
049D   E1                     POP   hl   
049E                LT1_:        
049E   B7                     OR   a   ; reset the carry flag
049F   ED 52                  SBC   hl,de   ; only equality sets hl=0 here
04A1   38 EF                  JR   c,true_   
04A3   18 E7                  JR   false_   
04A5                VAR_:        
04A5   0A                     LD   a,(bc)   
04A6   CD 2A 03               CALL   lookup1   
04A9                VAR1:        
04A9   22 A0 0B               LD   (vPointer),hl   
04AC   16 00                  LD   d,0   
04AE   5E                     LD   e,(hl)   
04AF   3A 84 0B               LD   a,(vByteMode)   
04B2   3C                     INC   a   ; is it byte?
04B3   28 02                  JR   z,var2   
04B5   23                     INC   hl   
04B6   56                     LD   d,(hl)   
04B7                VAR2:        
04B7   D5                     PUSH   de   
04B8   FD E9                  JP   (iy)   
04BA                GRAVE_:      
04BA                STR:         
04BA   03                     INC   bc   
04BB                STR1:        
04BB   0A                     LD   a,(bc)   
04BC   03                     INC   bc   
04BD   FE 60                  CP   "`"   ; ` is the string terminator
04BF   28 05                  JR   z,str2   
04C1   CD 85 00               CALL   putchar   
04C4   18 F5                  JR   str1   
04C6                STR2:        
04C6   0B                     DEC   bc   
04C7   FD E9                  JP   (iy)   
04C9                LBRACK_:      
04C9                ARRDEF:      
04C9   21 00 00               LD   hl,0   
04CC   39                     ADD   hl,sp   ; save
04CD   CD D4 03               CALL   rpush   
04D0   FD E9                  JP   (iy)   
04D2                AT_:         
04D2                ARRACCESS:      
04D2   E1                     POP   hl   ; hl = index
04D3   D1                     POP   de   ; de = array
04D4   3A 84 0B               LD   a,(vByteMode)   ; a = data width
04D7   3C                     INC   a   
04D8   28 01                  JR   z,arrAccess1   
04DA                ARRACCESS0:      
04DA   29                     ADD   hl,hl   ; if data width = 2 then double
04DB                ARRACCESS1:      
04DB   19                     ADD   hl,de   ; add addr
04DC   C3 A9 04               JP   var1   
04DF                LPAREN_:      
04DF   C3 58 07               JP   begin   
04E2                RPAREN_:      
04E2   C3 92 07               JP   again   
04E5                NUM_:        
04E5   C3 E0 06               JP   num   
04E8                COLON_:      
04E8   C3 B3 06               JP   def   
04EB                RBRACK_:      
04EB   C3 B4 05               JP   arrEnd   
04EE                QUOTE_:      ; Discard the top member of the stack
04EE   18 41                  JR   hex   
04F0                STAR_:       
04F0   18 5C                  JR   mul   
04F2                SLASH_:      
04F2                             ; jr div
04F2                             ;*******************************************************************
04F2                             ; Page 5 primitive routines
04F2                             ;*******************************************************************
04F2                             ;falls through
04F2                SLASH:       
04F2   03                     INC   bc   
04F3   0A                     LD   a,(bc)   
04F4   FE 2F                  CP   "/"   
04F6   CA E2 07               JP   z,comment   
04F9   FE 61                  CP   "a"   
04FB   38 1D                  JR   c,alt1   
04FD   FE 7B                  CP   "z"+1   
04FF   30 2D                  JR   nc,alt2   
0501   FE 69                  CP   "i"   
0503   2E 00                  LD   l,0   
0505   CA CE 07               JP   z,loopVar   
0508   FE 6A                  CP   "j"   
050A   2E 08                  LD   l,8   
050C   CA CE 07               JP   z,loopVar   
050F   D6 61                  SUB   "a"   
0511   87                     ADD   A,A   
0512   21 82 0B               LD   hl,altVars   
0515   85                     ADD   a,l   
0516   6F                     LD   l,a   
0517   C3 A9 04               JP   var1   
051A                ALT1:        
051A   FE 41                  CP   "A"   
051C   38 10                  JR   c,alt2   
051E   FE 5B                  CP   "Z"+1   
0520   30 0C                  JR   nc,alt2   
0522   21 5E 0A               LD   hl,altcodes   
0525   D6 41                  SUB   "A"   
0527   85                     ADD   a,l   
0528   6F                     LD   l,a   
0529   7E                     LD   a,(hl)   ;       get low jump address
052A   26 06                  LD   h,msb(page6)   
052C   6F                     LD   L,A   
052D   E9                     JP   (hl)   ;       Jump to routine
052E                ALT2:        
052E   0B                     DEC   bc   
052F   18 3D                  JR   div   
0531                HEX:         
0531   21 00 00               LD   hl,0   ; clear hl to accept the number
0534                HEX1:        
0534   03                     INC   bc   
0535   0A                     LD   a,(bc)   ; Get the character which is a numeral
0536   CB 77                  BIT   6,A   ; is it uppercase alpha?
0538   28 02                  JR   z,hex2   ; no a decimal
053A   D6 07                  SUB   7   ; sub 7  to make $A - $F
053C                HEX2:        
053C   D6 30                  SUB   $30   ; Form decimal digit
053E   DA 02 07               JP   c,num2   
0541   FE 10                  CP   $0F+1   
0543   D2 02 07               JP   nc,num2   
0546   29                     ADD   hl,hl   ; 2X ; Multiply digit(s) in hl by 16
0547   29                     ADD   hl,hl   ; 4X
0548   29                     ADD   hl,hl   ; 8X
0549   29                     ADD   hl,hl   ; 16X
054A   85                     ADD   A,l   ; add into bottom of hl
054B   6F                     LD   L,A   
054C   18 E6                  JR   hex1   
054E                MUL:         
054E   D1                     POP   de   ; de = 2nd factor
054F   E1                     POP   hl   
0550   C5                     PUSH   bc   ; Preserve the IP
0551   44                     LD   b,h   ; bc = 2nd value
0552   4D                     LD   c,l   
0553   21 00 00               LD   hl,0   
0556   3E 10                  LD   A,16   
0558                MUL2:        
0558   29                     ADD   hl,hl   
0559   CB 13                  RL   e   
055B   CB 12                  RL   d   
055D   30 04                  JR   nc,$+6   
055F   09                     ADD   hl,bc   
0560   30 01                  JR   nc,$+3   
0562   13                     INC   de   
0563   3D                     DEC   A   
0564   20 F2                  JR   nz,mul2   
0566   C1                     POP   bc   ; Restore the IP
0567   E5                     PUSH   hl   ; Put the product on the stack - stack bug fixed 2/12/21
0568   ED 53 A4 0B            LD   (vRemain),de   
056C   FD E9                  JP   (iy)   
056E                DIV:         
056E   60 69                  LD   hl,bc   ; hl = IP
0570   C1                     POP   bc   ; bc = denominator
0571   E3                     EX   (sp),hl   ; save IP, hl = numerator
0572   7C                     LD   a,h   
0573   A8                     XOR   b   
0574   F5                     PUSH   af   
0575   A8                     XOR   b   
0576   F2 7F 05               JP   p,absbc   
0579                             ;abshl
0579   AF                     XOR   a   
057A   95                     SUB   l   
057B   6F                     LD   l,a   
057C   9F                     SBC   a,a   
057D   94                     SUB   h   
057E   67                     LD   h,a   
057F                ABSBC:       
057F   A8                     XOR   b   
0580   F2 89 05               JP   p,$+9   
0583   AF                     XOR   a   
0584   91                     SUB   c   
0585   4F                     LD   c,a   
0586   9F                     SBC   a,a   
0587   90                     SUB   b   
0588   47                     LD   b,a   
0589   29                     ADD   hl,hl   
058A   3E 0F                  LD   a,15   
058C   11 00 00               LD   de,0   
058F   EB                     EX   de,hl   
0590   18 04                  JR   jumpin   
0592                LOOP1:       
0592   09                     ADD   hl,bc   ;--
0593                LOOP2:       
0593   3D                     DEC   a   ;4
0594   28 0D                  JR   z,EndSDiv   ;12|7
0596                JUMPIN:      
0596   CB 23                  SLA   e   ;8
0598   CB 12                  RL   d   ;8
059A   ED 6A                  ADC   hl,hl   ;15
059C   ED 42                  SBC   hl,bc   ;15
059E   38 F2                  JR   c,loop1   ;23-2b
05A0   1C                     INC   e   ;--
05A1   18 F0                  JR   Loop2   ;--
05A3                ENDSDIV:      
05A3   F1                     POP   af   
05A4   F2 AD 05               JP   p,div10   
05A7   AF                     XOR   a   
05A8   93                     SUB   e   
05A9   5F                     LD   e,a   
05AA   9F                     SBC   a,a   
05AB   92                     SUB   d   
05AC   57                     LD   d,a   
05AD                DIV10:       
05AD   C1                     POP   bc   
05AE   D5                     PUSH   de   ; quotient
05AF   22 A4 0B               LD   (vRemain),hl   ; remainder
05B2   FD E9                  JP   (iy)   
05B4                ARREND:      
05B4   ED 43 34 0B            LD   (vTemp1),bc   ; save IP
05B8   CD DF 03               CALL   rpop   
05BB   22 36 0B               LD   (vTemp2),hl   ; save old SP
05BE   54 5D                  LD   de,hl   ; de = hl = old SP
05C0   B7                     OR   a   
05C1   ED 72                  SBC   hl,sp   ; hl = array count (items on stack)
05C3   CB 3C                  SRL   h   ; num items = num bytes / 2
05C5   CB 1D                  RR   l   
05C7   44 4D                  LD   bc,hl   ; bc = count
05C9   2A 90 0B               LD   hl,(vHeapPtr)   ; hl = array[-4]
05CC   71                     LD   (hl),c   ; write num items in length word
05CD   23                     INC   hl   
05CE   70                     LD   (hl),b   
05CF   23                     INC   hl   ; hl = array[0], bc = count
05D0                             ; de = old SP, hl = array[0], bc = count
05D0   18 11                  JR   arrayEnd2   
05D2                ARRAYEND1:      
05D2   0B                     DEC   bc   ; dec items count
05D3   1B                     DEC   de   
05D4   1B                     DEC   de   
05D5   1A                     LD   a,(de)   ; a = lsb of stack item
05D6   77                     LD   (hl),a   ; write lsb of array item
05D7   23                     INC   hl   ; move to msb of array item
05D8   3A 84 0B               LD   a,(vByteMode)   ; vByteMode=1?
05DB   3C                     INC   a   
05DC   28 05                  JR   z,arrayEnd2   
05DE   13                     INC   de   
05DF   1A                     LD   a,(de)   ; a = msb of stack item
05E0   1B                     DEC   de   
05E1   77                     LD   (hl),a   ; write msb of array item
05E2   23                     INC   hl   ; move to next word in array
05E3                ARRAYEND2:      
05E3   79                     LD   a,c   ; if not zero loop
05E4   B0                     OR   b   
05E5   20 EB                  JR   nz,arrayEnd1   
05E7   EB                     EX   de,hl   ; de = end of array
05E8   2A 36 0B               LD   hl,(vTemp2)   
05EB   F9                     LD   sp,hl   ; SP = old SP
05EC   2A 90 0B               LD   hl,(vHeapPtr)   ; de = array[-2]
05EF   23                     INC   hl   
05F0   23                     INC   hl   
05F1   E5                     PUSH   hl   ; return array[0]
05F2   ED 53 90 0B            LD   (vHeapPtr),de   ; move heap* to end of array
05F6   ED 4B 34 0B            LD   bc,(vTemp1)   ; restore IP
05FA   FD E9                  JP   (iy)   
05FC                             ; **************************************************************************
05FC                             ; Page 6 Alt primitives
05FC                             ; **************************************************************************
05FC                          ALIGN   $100   
0600                PAGE6:       
0600                ARRSIZE_:      
0600                ARRSIZE:      
0600   E1                     POP   hl   
0601   2B                     DEC   hl   ; msb size
0602   56                     LD   d,(hl)   
0603   2B                     DEC   hl   ; lsb size
0604   5E                     LD   e,(hl)   
0605   D5                     PUSH   de   
0606                ANOP_:       
0606   FD E9                  JP   (iy)   
0608                BMODE_:      
0608   3A 84 0B               LD   a,(vByteMode)   
060B   2F                     CPL      
060C   32 84 0B               LD   (vByteMode),a   
060F   32 85 0B               LD   (vByteMode+1),a   
0612   FD E9                  JP   (iy)   
0614                EMIT_:       
0614   E1                     POP   hl   
0615   7D                     LD   a,l   
0616   CD 85 00               CALL   putchar   
0619   FD E9                  JP   (iy)   
061B                EXEC_:       
061B   CD 20 06               CALL   exec1   
061E   FD E9                  JP   (iy)   
0620                EXEC1:       
0620   E1                     POP   hl   
0621   E3                     EX   (SP),hl   
0622   E9                     JP   (hl)   
0623                KEY_:        
0623   CD 81 00               CALL   getchar   
0626   26 00                  LD   H,0   
0628   6F                     LD   L,A   
0629   E5                     PUSH   hl   
062A   FD E9                  JP   (iy)   
062C                GO_:         ;\^
062C   D1                     POP   de   
062D                GO1:         
062D   7A                     LD   a,D   ; skip if destination address is null
062E   B3                     OR   E   
062F   28 0E                  JR   z,go3   
0631   60 69                  LD   hl,bc   
0633   03                     INC   bc   ; read next char from source
0634   0A                     LD   a,(bc)   ; if ; to tail call optimise
0635   FE 3B                  CP   ";"   ; by jumping to rather than calling destination
0637   28 03                  JR   z,go2   
0639   CD D4 03               CALL   rpush   ; save Instruction Pointer
063C                GO2:         
063C   42 4B                  LD   bc,de   
063E   0B                     DEC   bc   
063F                GO3:         
063F   FD E9                  JP   (iy)   
0641                INPORT_:      ; \<
0641   E1                     POP   hl   
0642   79                     LD   a,c   
0643   4D                     LD   c,l   
0644   ED 68                  IN   L,(c)   
0646   26 00                  LD   H,0   
0648   4F                     LD   c,A   
0649   E5                     PUSH   hl   
064A   FD E9                  JP   (iy)   
064C                NEWLN_:      
064C   CD BD 03               CALL   crlf   
064F   FD E9                  JP   (iy)   
0651                OUTPORT_:      
0651   E1                     POP   hl   
0652   59                     LD   e,c   
0653   4D                     LD   c,l   
0654   E1                     POP   hl   
0655   ED 69                  OUT   (c),l   
0657   4B                     LD   c,E   
0658   FD E9                  JP   (iy)   
065A                             ; shiftLeft
065A                             ; value count
065A                SHL_:        
065A                SHIFTLEFT:      
065A   D1                     POP   de   ; de = count
065B   E1                     POP   hl   ; hl = value
065C   C5                     PUSH   bc   ; save IP
065D   7B                     LD   a,e   
065E   B7                     OR   a   
065F   28 04                  JR   z,shiftLeft2   
0661   43                     LD   b,e   
0662                SHIFTLEFT1:      
0662   29                     ADD   hl,hl   ; left shift hl
0663   10 FD                  DJNZ   shiftLeft1   
0665                SHIFTLEFT2:      
0665   C1                     POP   bc   
0666   E5                     PUSH   hl   ; restore IP
0667   FD E9                  JP   (iy)   
0669                SHR_:        
0669   D1                     POP   de   ; de = count
066A   E1                     POP   hl   ; hl = value
066B   C5                     PUSH   bc   ; save IP
066C   7B                     LD   a,e   
066D   B7                     OR   a   
066E   28 07                  JR   z,shiftRight2   
0670   43                     LD   b,e   
0671                SHIFTRIGHT1:      
0671   CB 3C                  SRL   h   
0673   CB 1D                  RR   l   
0675   10 FA                  DJNZ   shiftRight1   
0677                SHIFTRIGHT2:      
0677   C1                     POP   bc   
0678   E5                     PUSH   hl   ; restore IP
0679   FD E9                  JP   (iy)   
067B                             ;/D -> /UD depth            depth
067B                             ;/L -> /UE edit def         editDef
067B                             ;/P -> /UP prompt           prompt
067B                             ;/T -> /US print stack      printStk
067B                UTILITY_:      
067B                UTILITY:      
067B   03                     INC   bc   
067C   0A                     LD   a,(bc)   
067D   FE 44                  CP   "D"   
067F   20 12                  JR   nz,utility1   
0681                             ; depth:
0681   21 00 00               LD   hl,0   
0684   39                     ADD   hl,SP   
0685   EB                     EX   de,hl   
0686   21 00 0A               LD   hl,DSTACK   
0689   B7                     OR   A   
068A   ED 52                  SBC   hl,de   
068C   CB 3C                  SRL   h   
068E   CB 1D                  RR   l   
0690   E5                     PUSH   hl   
0691   FD E9                  JP   (iy)   ; 
0693                UTILITY1:      
0693   FE 45                  CP   "E"   
0695   CA 58 03               JP   z,editDef   
0698   FE 50                  CP   "P"   
069A   20 05                  JR   nz,utility2   
069C   CD B4 03               CALL   prompt   
069F   FD E9                  JP   (iy)   
06A1                UTILITY2:      
06A1   FD E9                  JP   (iy)   
06A3                WHILE_:      
06A3                WHILE:       
06A3   E1                     POP   hl   
06A4   7D                     LD   a,l   
06A5   B4                     OR   h   
06A6   20 09                  JR   nz,while2   
06A8   DD 4E 06               LD   c,(ix+6)   ; IP = )
06AB   DD 46 07               LD   b,(ix+7)   
06AE                             ; inc bc                      ; IP = one after )
06AE   C3 C7 07               JP   loopEnd4   
06B1                WHILE2:      
06B1   FD E9                  JP   (iy)   
06B3                             ;*******************************************************************
06B3                             ; Page 5 primitive routines continued
06B3                             ;*******************************************************************
06B3                DEF:         ; create a colon definition
06B3   03                     INC   bc   
06B4   0A                     LD   A,(bc)   ; Get the next character
06B5   FE 3A                  CP   ":"   ; is it anonymouse
06B7   20 08                  JR   nz,def0   
06B9   03                     INC   bc   
06BA   ED 5B 90 0B            LD   de,(vHeapPtr)   ; return start of definition
06BE   D5                     PUSH   de   
06BF   18 0E                  JR   def1   
06C1                DEF0:        
06C1   32 B4 0B               LD   (vLastDef),A   
06C4   CD 26 03               CALL   lookup   
06C7   ED 5B 90 0B            LD   de,(vHeapPtr)   ; start of defintion
06CB   73                     LD   (hl),E   ; Save low byte of address in cFA
06CC   23                     INC   hl   
06CD   72                     LD   (hl),D   ; Save high byte of address in cFA+1
06CE   03                     INC   bc   
06CF                DEF1:        ; Skip to end of definition
06CF   0A                     LD   a,(bc)   ; Get the next character
06D0   03                     INC   bc   ; Point to next character
06D1   12                     LD   (de),A   
06D2   13                     INC   de   
06D3   FE 3B                  CP   ";"   ; Is it a semicolon
06D5   28 02                  JR   z,def2   ; end the definition
06D7   18 F6                  JR   def1   ; get the next element
06D9                DEF2:        
06D9   0B                     DEC   bc   
06DA                DEF3:        
06DA   ED 53 90 0B            LD   (vHeapPtr),de   ; bump heap ptr to after definiton
06DE   FD E9                  JP   (iy)   
06E0                NUM:         
06E0   21 00 00               LD   hl,$0000   ; clear hl to accept the number
06E3   0A                     LD   a,(bc)   ; Get numeral or -
06E4   FE 2D                  CP   "-"   
06E6   20 01                  JR   nz,num0   
06E8   03                     INC   bc   ; move to next char, no flags affected
06E9                NUM0:        
06E9   08                     EX   af,af'   ; save zero flag = 0 for later
06EA                NUM1:        
06EA   0A                     LD   a,(bc)   ; read digit
06EB   D6 30                  SUB   "0"   ; less than 0?
06ED   38 13                  JR   c,num2   ; not a digit, exit loop
06EF   FE 0A                  CP   10   ; greater that 9?
06F1   30 0F                  JR   nc,num2   ; not a digit, exit loop
06F3   03                     INC   bc   ; inc IP
06F4   54 5D                  LD   de,hl   ; multiply hl * 10
06F6   29                     ADD   hl,hl   
06F7   29                     ADD   hl,hl   
06F8   19                     ADD   hl,de   
06F9   29                     ADD   hl,hl   
06FA   85                     ADD   a,l   ; add digit in a to hl
06FB   6F                     LD   l,a   
06FC   3E 00                  LD   a,0   
06FE   8C                     ADC   a,h   
06FF   67                     LD   h,a   
0700   18 E8                  JR   num1   
0702                NUM2:        
0702   0B                     DEC   bc   
0703   08                     EX   af,af'   ; restore zero flag
0704   20 07                  JR   nz,num3   
0706   EB                     EX   de,hl   ; negate the value of hl
0707   21 00 00               LD   hl,0   
070A   B7                     OR   a   ; jump to sub2
070B   ED 52                  SBC   hl,de   
070D                NUM3:        
070D   E5                     PUSH   hl   ; Put the number on the stack
070E   FD E9                  JP   (iy)   ; and process the next character
0710                             ;*******************************************************************
0710                             ; Subroutines
0710                             ;*******************************************************************
0710                             ; hl = value
0710                PRINTDEC:      
0710   CB 7C                  BIT   7,h   
0712   28 0B                  JR   z,printDec2   
0714   3E 2D                  LD   a,"-"   
0716   CD 85 00               CALL   putchar   
0719   AF                     XOR   a   
071A   95                     SUB   l   
071B   6F                     LD   l,a   
071C   9F                     SBC   a,a   
071D   94                     SUB   h   
071E   67                     LD   h,a   
071F                PRINTDEC2:      
071F   C5                     PUSH   bc   
0720   0E 00                  LD   c,0   ; leading zeros flag = false
0722   11 F0 D8               LD   de,-10000   
0725   CD 41 07               CALL   printDec4   
0728   11 18 FC               LD   de,-1000   
072B   CD 41 07               CALL   printDec4   
072E   11 9C FF               LD   de,-100   
0731   CD 41 07               CALL   printDec4   
0734   1E F6                  LD   e,-10   
0736   CD 41 07               CALL   printDec4   
0739   0C                     INC   c   ; flag = true for at least digit
073A   1E FF                  LD   e,-1   
073C   CD 41 07               CALL   printDec4   
073F   C1                     POP   bc   
0740   C9                     RET      
0741                PRINTDEC4:      
0741   06 2F                  LD   b,"0"-1   
0743                PRINTDEC5:      
0743   04                     INC   b   
0744   19                     ADD   hl,de   
0745   38 FC                  JR   c,printDec5   
0747   ED 52                  SBC   hl,de   
0749   3E 30                  LD   a,"0"   
074B   B8                     CP   b   
074C   20 05                  JR   nz,printDec6   
074E   AF                     XOR   a   
074F   B1                     OR   c   
0750   C8                     RET   z   
0751   18 01                  JR   printDec7   
0753                PRINTDEC6:      
0753   0C                     INC   c   
0754                PRINTDEC7:      
0754   78                     LD   a,b   
0755   C3 85 00               JP   putchar   
0758                             ; (val -- )
0758                BEGIN:       
0758                LOOPSTART:      
0758   ED 43 34 0B            LD   (vTemp1),bc   ; save start
075C   1E 01                  LD   e,1   ; skip to loop end, nesting = 1
075E                LOOPSTART1:      
075E   03                     INC   bc   
075F   0A                     LD   a,(bc)   
0760   CD 88 03               CALL   nesting   ; affects zero flag
0763   20 F9                  JR   nz,loopStart1   
0765   D1                     POP   de   ; de = limit
0766   7B                     LD   a,e   ; is it zero?
0767   B2                     OR   d   
0768   20 07                  JR   nz,loopStart2   
076A   1B                     DEC   de   ; de = TRUE
076B   ED 53 8A 0B            LD   (vElse),de   
076F   18 1F                  JR   loopStart4   ; yes continue after skip
0771                LOOPSTART2:      
0771   3E 02                  LD   a,2   ; is it TRUE
0773   83                     ADD   a,e   
0774   82                     ADD   a,d   
0775   20 03                  JR   nz,loopStart3   
0777   11 01 00               LD   de,1   ; yes make it 1
077A                LOOPSTART3:      
077A   60 69                  LD   hl,bc   
077C   CD D4 03               CALL   rpush   ; rpush loop end
077F   0B                     DEC   bc   ; IP points to ")"
0780   2A 34 0B               LD   hl,(vTemp1)   ; restore start
0783   CD D4 03               CALL   rpush   ; rpush start
0786   EB                     EX   de,hl   ; hl = limit
0787   CD D4 03               CALL   rpush   ; rpush limit
078A   21 FF FF               LD   hl,-1   ; hl = count = -1
078D   CD D4 03               CALL   rpush   ; rpush count
0790                LOOPSTART4:      
0790   FD E9                  JP   (iy)   
0792                AGAIN:       
0792                LOOPEND:      
0792   DD 5E 02               LD   e,(ix+2)   ; de = limit
0795   DD 56 03               LD   d,(ix+3)   
0798   7B                     LD   a,e   ; a = lsb(limit)
0799   B2                     OR   d   ; if limit 0 exit loop
079A   28 2B                  JR   z,loopEnd4   
079C   13                     INC   de   ; is limit -2
079D   13                     INC   de   
079E   7B                     LD   a,e   ; a = lsb(limit)
079F   B2                     OR   d   ; if limit 0 exit loop
07A0   28 09                  JR   z,loopEnd2   ; yes, loop again
07A2   1B                     DEC   de   
07A3   1B                     DEC   de   
07A4   1B                     DEC   de   
07A5   DD 73 02               LD   (ix+2),e   
07A8   DD 72 03               LD   (ix+3),d   
07AB                LOOPEND2:      
07AB   DD 5E 00               LD   e,(ix+0)   ; inc counter
07AE   DD 56 01               LD   d,(ix+1)   
07B1   13                     INC   de   
07B2   DD 73 00               LD   (ix+0),e   
07B5   DD 72 01               LD   (ix+1),d   
07B8                LOOPEND3:      
07B8   11 00 00               LD   de,FALSE   ; if clause ran then vElse = FALSE
07BB   ED 53 8A 0B            LD   (vElse),de   
07BF   DD 4E 04               LD   c,(ix+4)   ; IP = start
07C2   DD 46 05               LD   b,(ix+5)   
07C5   FD E9                  JP   (iy)   
07C7                LOOPEND4:      
07C7   11 08 00               LD   de,2*4   ; rpop frame
07CA   DD 19                  ADD   ix,de   
07CC   FD E9                  JP   (iy)   
07CE                LOOPVAR:      
07CE   26 00                  LD   h,0   
07D0   DD 54                  LD   d,ixh   
07D2   DD 5D                  LD   e,ixl   
07D4   19                     ADD   hl,de   
07D5   C3 A9 04               JP   var1   
07D8                CARRY:       
07D8   21 00 00               LD   hl,0   
07DB   CB 15                  RL   l   
07DD   22 86 0B               LD   (vcarry),hl   
07E0   FD E9                  JP   (iy)   
07E2                COMMENT:      
07E2   03                     INC   bc   ; point to next char
07E3   0A                     LD   a,(bc)   
07E4   FE 0D                  CP   "\r"   ; terminate at cr
07E6   20 FA                  JR   nz,comment   
07E8   0B                     DEC   bc   
07E9   FD E9                  JP   (iy)   
07EB                             ; 0 1 count
07EB                             ; 2 3 limit
07EB                             ; 4 5 start
07EB                             ; 6 7 end
07EB                DSIZE:    EQU   $80   
07EB                RSIZE:    EQU   $80   
07EB                TIBSIZE:   EQU   $100   ; 256 bytes , along line!
07EB                VARS_SIZE:   EQU   26*2*2   ; A..Z, a..z words
0800                          .ORG   RAMSTART   
0800                TIB:      DS   TIBSIZE   
0900                          DS   RSIZE   
0980                RSTACK:      
0980                          DS   DSIZE   
0A00                DSTACK:      
0A00                STACK:       
0A00                          ALIGN   $100   
0A00                OPCODES:      
0A00                          DS   $80-32-1-1   
0A5E                ALTCODES:      
0A5E                          DS   $80-32-1-5   
0AB8                          ALIGN   $100   
0B00                MINTVARS:      
0B00                          DS   $30   
0B30                VLOOPSP:   DS   2   ; 
0B32                TBPTR:    DS   2   ; reserved for tests
0B34                VTEMP1:   DS   2   ; 
0B36                VTEMP2:   DS   2   ; 
0B38                RST08:    DS   2   
0B3A                RST10:    DS   2   
0B3C                RST18:    DS   2   
0B3E                RST20:    DS   2   
0B40                RST28:    DS   2   
0B42                RST30:    DS   2   ; 
0B44                BAUD:     DS   2   ; 
0B46                INTVEC:   DS   2   ; 
0B48                NMIVEC:   DS   2   ; 
0B4A                GETCVEC:   DS   2   ; 
0B4C                PUTCVEC:   DS   2   ; 
0B4E                          DS   26*2   
0B82                ALTVARS:      
0B82                          DS   2   ; a
0B84                VBYTEMODE:   DS   2   ; b
0B86                VCARRY:   DS   2   ; c
0B88                          DS   2   ; d
0B8A                VELSE:    DS   2   ; e
0B8C                VFALSE:   DS   2   ; f
0B8E                          DS   2   ; g
0B90                VHEAPPTR:   DS   2   ; h
0B92                          DS   2   ; i
0B94                          DS   2   ; j
0B96                VTIBPTR:   DS   2   ; k
0B98                          DS   2   ; l
0B9A                          DS   2   ; m
0B9C                          DS   2   ; n
0B9E                          DS   2   ; o
0BA0                VPOINTER:   DS   2   ; p
0BA2                          DS   2   ; q
0BA4                VREMAIN:   DS   2   ; r
0BA6                VS0:      DS   2   ; s
0BA8                VTRUE:    DS   2   ; t
0BAA                VUNLIMITED:   DS   2   ; u
0BAC                          DS   2   ; v
0BAE                          DS   2   ; w
0BB0                          DS   2   ; x
0BB2                          DS   2   ; y
0BB4                VLASTDEF:   DS   2   ; z
0BB6                VARS:     DS   VARS_SIZE   
0C1E                HEAP:        


TEC_1:              0001 DEFINED AT LINE 1 IN constants.asm
RC2014:             0000 DEFINED AT LINE 2 IN constants.asm
EXTENDED:           0000 DEFINED AT LINE 4 IN constants.asm
LOADER:             0000 DEFINED AT LINE 20 IN constants.asm
BITBANG:            0000 DEFINED AT LINE 21 IN constants.asm
ROMSTART:           0000 DEFINED AT LINE 23 IN constants.asm
                    > USED AT LINE 100 IN IOSerial.asm
                    > USED AT LINE 105 IN IOSerial.asm
                    > USED AT LINE 111 IN IOSerial.asm
                    > USED AT LINE 117 IN IOSerial.asm
                    > USED AT LINE 123 IN IOSerial.asm
                    > USED AT LINE 129 IN IOSerial.asm
                    > USED AT LINE 135 IN IOSerial.asm
                    > USED AT LINE 141 IN IOSerial.asm
                    > USED AT LINE 147 IN IOSerial.asm
                    > USED AT LINE 189 IN IOSerial.asm
                    > USED AT LINE 42 IN MAIN.asm
RAMSTART:           0800 DEFINED AT LINE 24 IN constants.asm
                    > USED AT LINE 7 IN ram.asm
ROMSIZE:            0800 DEFINED AT LINE 25 IN constants.asm
RAMSIZE:            0800 DEFINED AT LINE 26 IN constants.asm
CONTROL:            0080 DEFINED AT LINE 22 IN IOSerial.asm
                    > USED AT LINE 465 IN IOSerial.asm
                    > USED AT LINE 487 IN IOSerial.asm
STATUS:             0080 DEFINED AT LINE 23 IN IOSerial.asm
                    > USED AT LINE 298 IN IOSerial.asm
                    > USED AT LINE 311 IN IOSerial.asm
TDR:                0081 DEFINED AT LINE 24 IN IOSerial.asm
                    > USED AT LINE 303 IN IOSerial.asm
RDR:                0081 DEFINED AT LINE 25 IN IOSerial.asm
                    > USED AT LINE 315 IN IOSerial.asm
MRESET:             0003 DEFINED AT LINE 32 IN IOSerial.asm
                    > USED AT LINE 464 IN IOSerial.asm
DIV_64:             0002 DEFINED AT LINE 35 IN IOSerial.asm
                    > USED AT LINE 486 IN IOSerial.asm
F7E2:               0000 DEFINED AT LINE 39 IN IOSerial.asm
F7O2:               0004 DEFINED AT LINE 40 IN IOSerial.asm
F7E1:               0008 DEFINED AT LINE 41 IN IOSerial.asm
F7O1:               000C DEFINED AT LINE 42 IN IOSerial.asm
F8N2:               0010 DEFINED AT LINE 43 IN IOSerial.asm
                    > USED AT LINE 486 IN IOSerial.asm
F8N1:               0014 DEFINED AT LINE 44 IN IOSerial.asm
F8E1:               0018 DEFINED AT LINE 45 IN IOSerial.asm
F8O1:               001C DEFINED AT LINE 46 IN IOSerial.asm
RTSLID:             0000 DEFINED AT LINE 50 IN IOSerial.asm
                    > USED AT LINE 486 IN IOSerial.asm
RTSLIE:             0020 DEFINED AT LINE 51 IN IOSerial.asm
RTSHID:             0040 DEFINED AT LINE 52 IN IOSerial.asm
RTSLIDB:            0060 DEFINED AT LINE 53 IN IOSerial.asm
RIE:                0080 DEFINED AT LINE 57 IN IOSerial.asm
RDRF:               0000 DEFINED AT LINE 61 IN IOSerial.asm
TDRE:               0001 DEFINED AT LINE 62 IN IOSerial.asm
DCD:                0002 DEFINED AT LINE 63 IN IOSerial.asm
CTS:                0003 DEFINED AT LINE 64 IN IOSerial.asm
FE:                 0004 DEFINED AT LINE 65 IN IOSerial.asm
OVRN:               0005 DEFINED AT LINE 66 IN IOSerial.asm
PE:                 0006 DEFINED AT LINE 67 IN IOSerial.asm
IRQ:                0007 DEFINED AT LINE 68 IN IOSerial.asm
KEYBUF:             0000 DEFINED AT LINE 76 IN IOSerial.asm
SCAN:               0001 DEFINED AT LINE 77 IN IOSerial.asm
DISPLY:             0002 DEFINED AT LINE 78 IN IOSerial.asm
PORT3:              0003 DEFINED AT LINE 79 IN IOSerial.asm
PORT4:              0004 DEFINED AT LINE 80 IN IOSerial.asm
PORT5:              0005 DEFINED AT LINE 81 IN IOSerial.asm
PORT6:              0006 DEFINED AT LINE 82 IN IOSerial.asm
PORT7:              0007 DEFINED AT LINE 83 IN IOSerial.asm
ESC:                001B DEFINED AT LINE 96 IN IOSerial.asm
CR:                 000D DEFINED AT LINE 97 IN IOSerial.asm
LF:                 000A DEFINED AT LINE 98 IN IOSerial.asm
RSTVEC:             0000 DEFINED AT LINE 102 IN IOSerial.asm
SEVENSEGMENT:       0040 DEFINED AT LINE 152 IN IOSerial.asm
PWRUP:              0050 DEFINED AT LINE 174 IN IOSerial.asm
                    > USED AT LINE 470 IN IOSerial.asm
BITIME:             0053 DEFINED AT LINE 176 IN IOSerial.asm
BITIM1:             0058 DEFINED AT LINE 180 IN IOSerial.asm
                    > USED AT LINE 182 IN IOSerial.asm
INTRET:             005F DEFINED AT LINE 185 IN IOSerial.asm
                    > USED AT LINE 446 IN IOSerial.asm
TXDATA:             006B DEFINED AT LINE 293 IN IOSerial.asm
                    > USED AT LINE 458 IN IOSerial.asm
TXCHAR:             006B DEFINED AT LINE 294 IN IOSerial.asm
TXCHAR1:            006D DEFINED AT LINE 297 IN IOSerial.asm
                    > USED AT LINE 301 IN IOSerial.asm
RXDATA:             0078 DEFINED AT LINE 309 IN IOSerial.asm
                    > USED AT LINE 456 IN IOSerial.asm
RXCHAR:             0078 DEFINED AT LINE 310 IN IOSerial.asm
                    > USED AT LINE 314 IN IOSerial.asm
GETCHAR:            0081 DEFINED AT LINE 434 IN IOSerial.asm
                    > USED AT LINE 180 IN MAIN.asm
                    > USED AT LINE 983 IN MAIN.asm
PUTCHAR:            0085 DEFINED AT LINE 438 IN IOSerial.asm
                    > USED AT LINE 214 IN MAIN.asm
                    > USED AT LINE 365 IN MAIN.asm
                    > USED AT LINE 460 IN MAIN.asm
                    > USED AT LINE 486 IN MAIN.asm
                    > USED AT LINE 566 IN MAIN.asm
                    > USED AT LINE 707 IN MAIN.asm
                    > USED AT LINE 971 IN MAIN.asm
                    > USED AT LINE 1192 IN MAIN.asm
                    > USED AT LINE 1233 IN MAIN.asm
RESET:              008B DEFINED AT LINE 444 IN IOSerial.asm
                    > USED AT LINE 103 IN IOSerial.asm
FALSE:              0000 DEFINED AT LINE 12 IN MAIN.asm
                    > USED AT LINE 660 IN MAIN.asm
                    > USED AT LINE 1295 IN MAIN.asm
TRUE:               00-1 DEFINED AT LINE 13 IN MAIN.asm
                    > USED AT LINE 280 IN MAIN.asm
                    > USED AT LINE 665 IN MAIN.asm
UNLIMITED:          00-2 DEFINED AT LINE 14 IN MAIN.asm
CTRL_C:             0003 DEFINED AT LINE 16 IN MAIN.asm
                    > USED AT LINE 244 IN MAIN.asm
CTRL_E:             0005 DEFINED AT LINE 17 IN MAIN.asm
                    > USED AT LINE 190 IN MAIN.asm
CTRL_H:             0008 DEFINED AT LINE 18 IN MAIN.asm
                    > USED AT LINE 187 IN MAIN.asm
CTRL_J:             000A DEFINED AT LINE 19 IN MAIN.asm
                    > USED AT LINE 193 IN MAIN.asm
CTRL_P:             0010 DEFINED AT LINE 20 IN MAIN.asm
                    > USED AT LINE 196 IN MAIN.asm
BSLASH:             005C DEFINED AT LINE 22 IN MAIN.asm
MACROS:             0180 DEFINED AT LINE 48 IN MAIN.asm
REEDIT_:            0180 DEFINED AT LINE 50 IN MAIN.asm
EDIT_:              0186 DEFINED AT LINE 53 IN MAIN.asm
PRINTSTACK_:        0193 DEFINED AT LINE 56 IN MAIN.asm
IOPCODES:           01B1 DEFINED AT LINE 59 IN MAIN.asm
                    > USED AT LINE 298 IN MAIN.asm
IALTCODES:          01DB DEFINED AT LINE 106 IN MAIN.asm
BACKSPACE:          01F7 DEFINED AT LINE 139 IN MAIN.asm
                    > USED AT LINE 188 IN MAIN.asm
START:              0205 DEFINED AT LINE 148 IN MAIN.asm
                    > USED AT LINE 6
INTERPRET:          021A DEFINED AT LINE 154 IN MAIN.asm
                    > USED AT LINE 268 IN MAIN.asm
INTERPRET2:         0224 DEFINED AT LINE 160 IN MAIN.asm
                    > USED AT LINE 142 IN MAIN.asm
                    > USED AT LINE 146 IN MAIN.asm
                    > USED AT LINE 199 IN MAIN.asm
                    > USED AT LINE 207 IN MAIN.asm
INTERPRET3:         022C DEFINED AT LINE 167 IN MAIN.asm
                    > USED AT LINE 176 IN MAIN.asm
INTERPRET4:         0232 DEFINED AT LINE 173 IN MAIN.asm
                    > USED AT LINE 165 IN MAIN.asm
WAITCHAR:           0237 DEFINED AT LINE 179 IN MAIN.asm
                    > USED AT LINE 216 IN MAIN.asm
                    > USED AT LINE 230 IN MAIN.asm
MACRO:              0260 DEFINED AT LINE 201 IN MAIN.asm
                    > USED AT LINE 192 IN MAIN.asm
                    > USED AT LINE 195 IN MAIN.asm
                    > USED AT LINE 198 IN MAIN.asm
WAITCHAR1:          0271 DEFINED AT LINE 209 IN MAIN.asm
                    > USED AT LINE 182 IN MAIN.asm
WAITCHAR3:          027F DEFINED AT LINE 218 IN MAIN.asm
                    > USED AT LINE 186 IN MAIN.asm
WAITCHAR4:          0295 DEFINED AT LINE 234 IN MAIN.asm
                    > USED AT LINE 184 IN MAIN.asm
NEXT:               029D DEFINED AT LINE 239 IN MAIN.asm
                    > USED AT LINE 247 IN MAIN.asm
                    > USED AT LINE 272 IN MAIN.asm
EXIT:               02B1 DEFINED AT LINE 254 IN MAIN.asm
                    > USED AT LINE 243 IN MAIN.asm
ETX:                02BB DEFINED AT LINE 262 IN MAIN.asm
                    > USED AT LINE 245 IN MAIN.asm
ETX1:               02C4 DEFINED AT LINE 267 IN MAIN.asm
                    > USED AT LINE 265 IN MAIN.asm
INIT:               02C7 DEFINED AT LINE 270 IN MAIN.asm
                    > USED AT LINE 150 IN MAIN.asm
INIT1:              02D4 DEFINED AT LINE 276 IN MAIN.asm
                    > USED AT LINE 279 IN MAIN.asm
INITOPS:            0302 DEFINED AT LINE 297 IN MAIN.asm
INITOPS1:           030B DEFINED AT LINE 302 IN MAIN.asm
                    > USED AT LINE 312 IN MAIN.asm
                    > USED AT LINE 323 IN MAIN.asm
INITOPS2:           031B DEFINED AT LINE 314 IN MAIN.asm
                    > USED AT LINE 307 IN MAIN.asm
INITOPS2A:          0320 DEFINED AT LINE 319 IN MAIN.asm
                    > USED AT LINE 322 IN MAIN.asm
LOOKUP:             0326 DEFINED AT LINE 325 IN MAIN.asm
                    > USED AT LINE 373 IN MAIN.asm
                    > USED AT LINE 555 IN MAIN.asm
                    > USED AT LINE 1125 IN MAIN.asm
LOOKUP1:            032A DEFINED AT LINE 328 IN MAIN.asm
                    > USED AT LINE 684 IN MAIN.asm
LOOKUP2:            032C DEFINED AT LINE 330 IN MAIN.asm
                    > USED AT LINE 327 IN MAIN.asm
PRINTHEX:           0339 DEFINED AT LINE 342 IN MAIN.asm
                    > USED AT LINE 572 IN MAIN.asm
PRINTHEX2:          0344 DEFINED AT LINE 351 IN MAIN.asm
                    > USED AT LINE 346 IN MAIN.asm
                    > USED AT LINE 348 IN MAIN.asm
PRINTHEX3:          034D DEFINED AT LINE 359 IN MAIN.asm
                    > USED AT LINE 357 IN MAIN.asm
EDITDEF:            0358 DEFINED AT LINE 367 IN MAIN.asm
                    > USED AT LINE 1089 IN MAIN.asm
EDITDEF1:           0374 DEFINED AT LINE 386 IN MAIN.asm
                    > USED AT LINE 392 IN MAIN.asm
EDITDEF2:           0375 DEFINED AT LINE 388 IN MAIN.asm
                    > USED AT LINE 385 IN MAIN.asm
EDITDEF3:           037D DEFINED AT LINE 393 IN MAIN.asm
                    > USED AT LINE 380 IN MAIN.asm
NESTING:            0388 DEFINED AT LINE 410 IN MAIN.asm
                    > USED AT LINE 171 IN MAIN.asm
                    > USED AT LINE 215 IN MAIN.asm
                    > USED AT LINE 1243 IN MAIN.asm
NESTING1:           0391 DEFINED AT LINE 417 IN MAIN.asm
                    > USED AT LINE 412 IN MAIN.asm
NESTING2:           03A1 DEFINED AT LINE 426 IN MAIN.asm
                    > USED AT LINE 419 IN MAIN.asm
                    > USED AT LINE 421 IN MAIN.asm
                    > USED AT LINE 423 IN MAIN.asm
NESTING3:           03A3 DEFINED AT LINE 429 IN MAIN.asm
                    > USED AT LINE 425 IN MAIN.asm
NESTING4:           03B2 DEFINED AT LINE 438 IN MAIN.asm
                    > USED AT LINE 431 IN MAIN.asm
                    > USED AT LINE 433 IN MAIN.asm
                    > USED AT LINE 435 IN MAIN.asm
PROMPT:             03B4 DEFINED AT LINE 442 IN MAIN.asm
                    > USED AT LINE 155 IN MAIN.asm
                    > USED AT LINE 1092 IN MAIN.asm
CRLF:               03BD DEFINED AT LINE 447 IN MAIN.asm
                    > USED AT LINE 227 IN MAIN.asm
                    > USED AT LINE 1018 IN MAIN.asm
PRINTSTR:           03C4 DEFINED AT LINE 452 IN MAIN.asm
                    > USED AT LINE 144 IN MAIN.asm
                    > USED AT LINE 151 IN MAIN.asm
                    > USED AT LINE 443 IN MAIN.asm
                    > USED AT LINE 448 IN MAIN.asm
PUTSTR0:            03CB DEFINED AT LINE 459 IN MAIN.asm
                    > USED AT LINE 465 IN MAIN.asm
PUTSTR:             03CF DEFINED AT LINE 462 IN MAIN.asm
                    > USED AT LINE 454 IN MAIN.asm
RPUSH:              03D4 DEFINED AT LINE 468 IN MAIN.asm
                    > USED AT LINE 490 IN MAIN.asm
                    > USED AT LINE 717 IN MAIN.asm
                    > USED AT LINE 1000 IN MAIN.asm
                    > USED AT LINE 1260 IN MAIN.asm
                    > USED AT LINE 1263 IN MAIN.asm
                    > USED AT LINE 1265 IN MAIN.asm
                    > USED AT LINE 1267 IN MAIN.asm
RPOP:               03DF DEFINED AT LINE 475 IN MAIN.asm
                    > USED AT LINE 257 IN MAIN.asm
                    > USED AT LINE 606 IN MAIN.asm
                    > USED AT LINE 898 IN MAIN.asm
RPOP2:              03E9 DEFINED AT LINE 480 IN MAIN.asm
WRITECHAR:          03EA DEFINED AT LINE 483 IN MAIN.asm
                    > USED AT LINE 382 IN MAIN.asm
                    > USED AT LINE 384 IN MAIN.asm
                    > USED AT LINE 390 IN MAIN.asm
ENTER:              03EF DEFINED AT LINE 488 IN MAIN.asm
                    > USED AT LINE 204 IN MAIN.asm
PAGE4:              0400 DEFINED AT LINE 499 IN MAIN.asm
DQUOTE_:            0400 DEFINED AT LINE 501 IN MAIN.asm
QUESTION_:          0400 DEFINED AT LINE 502 IN MAIN.asm
LBRACE_:            0400 DEFINED AT LINE 503 IN MAIN.asm
RBRACE_:            0400 DEFINED AT LINE 504 IN MAIN.asm
UNDERSCORE_:        0400 DEFINED AT LINE 505 IN MAIN.asm
AMPER_:             0402 DEFINED AT LINE 508 IN MAIN.asm
AND_:               0402 DEFINED AT LINE 509 IN MAIN.asm
AND1:               0409 DEFINED AT LINE 517 IN MAIN.asm
                    > USED AT LINE 532 IN MAIN.asm
                    > USED AT LINE 543 IN MAIN.asm
PIPE_:              040D DEFINED AT LINE 523 IN MAIN.asm
OR_:                040D DEFINED AT LINE 524 IN MAIN.asm
CARET_:             0416 DEFINED AT LINE 534 IN MAIN.asm
XOR_:               0416 DEFINED AT LINE 535 IN MAIN.asm
PLUS_:              041F DEFINED AT LINE 545 IN MAIN.asm
ADD_:               041F DEFINED AT LINE 546 IN MAIN.asm
CALL_:              0426 DEFINED AT LINE 553 IN MAIN.asm
DOT_:               0430 DEFINED AT LINE 561 IN MAIN.asm
DOT2:               0434 DEFINED AT LINE 564 IN MAIN.asm
                    > USED AT LINE 573 IN MAIN.asm
COMMA_:             043B DEFINED AT LINE 569 IN MAIN.asm
HDOT_:              043B DEFINED AT LINE 570 IN MAIN.asm
BSLASH_:            0441 DEFINED AT LINE 575 IN MAIN.asm
DROP_:              0441 DEFINED AT LINE 576 IN MAIN.asm
HASH_:              0444 DEFINED AT LINE 580 IN MAIN.asm
DUP_:               0444 DEFINED AT LINE 581 IN MAIN.asm
DOLLAR_:            0449 DEFINED AT LINE 588 IN MAIN.asm
SWAP_:              0449 DEFINED AT LINE 589 IN MAIN.asm
PERCENT_:           044E DEFINED AT LINE 595 IN MAIN.asm
OVER_:              044E DEFINED AT LINE 596 IN MAIN.asm
SEMI_:              0455 DEFINED AT LINE 604 IN MAIN.asm
RET_:               0455 DEFINED AT LINE 605 IN MAIN.asm
TILDE_:             045C DEFINED AT LINE 610 IN MAIN.asm
NOT:                045C DEFINED AT LINE 611 IN MAIN.asm
BANG_:              0466 DEFINED AT LINE 622 IN MAIN.asm
STORE_:             0466 DEFINED AT LINE 623 IN MAIN.asm
ASSIGN:             0466 DEFINED AT LINE 624 IN MAIN.asm
ASSIGN0:            0468 DEFINED AT LINE 627 IN MAIN.asm
ASSIGN1:            046B DEFINED AT LINE 629 IN MAIN.asm
MINUS_:             0470 DEFINED AT LINE 635 IN MAIN.asm
SUB_:               0470 DEFINED AT LINE 636 IN MAIN.asm
SUB1:               047C DEFINED AT LINE 644 IN MAIN.asm
                    > USED AT LINE 641 IN MAIN.asm
SUB2:               047E DEFINED AT LINE 647 IN MAIN.asm
EQ_:                0485 DEFINED AT LINE 653 IN MAIN.asm
FALSE_:             048C DEFINED AT LINE 659 IN MAIN.asm
                    > USED AT LINE 680 IN MAIN.asm
TRUE_:              0492 DEFINED AT LINE 664 IN MAIN.asm
                    > USED AT LINE 658 IN MAIN.asm
                    > USED AT LINE 679 IN MAIN.asm
GT_:                0498 DEFINED AT LINE 669 IN MAIN.asm
LT_:                049C DEFINED AT LINE 673 IN MAIN.asm
LT1_:               049E DEFINED AT LINE 676 IN MAIN.asm
                    > USED AT LINE 672 IN MAIN.asm
VAR_:               04A5 DEFINED AT LINE 682 IN MAIN.asm
VAR1:               04A9 DEFINED AT LINE 685 IN MAIN.asm
                    > USED AT LINE 731 IN MAIN.asm
                    > USED AT LINE 776 IN MAIN.asm
                    > USED AT LINE 1310 IN MAIN.asm
VAR2:               04B7 DEFINED AT LINE 694 IN MAIN.asm
                    > USED AT LINE 691 IN MAIN.asm
GRAVE_:             04BA DEFINED AT LINE 698 IN MAIN.asm
STR:                04BA DEFINED AT LINE 699 IN MAIN.asm
STR1:               04BB DEFINED AT LINE 702 IN MAIN.asm
                    > USED AT LINE 708 IN MAIN.asm
STR2:               04C6 DEFINED AT LINE 709 IN MAIN.asm
                    > USED AT LINE 706 IN MAIN.asm
LBRACK_:            04C9 DEFINED AT LINE 713 IN MAIN.asm
ARRDEF:             04C9 DEFINED AT LINE 714 IN MAIN.asm
AT_:                04D2 DEFINED AT LINE 720 IN MAIN.asm
ARRACCESS:          04D2 DEFINED AT LINE 721 IN MAIN.asm
ARRACCESS0:         04DA DEFINED AT LINE 727 IN MAIN.asm
ARRACCESS1:         04DB DEFINED AT LINE 729 IN MAIN.asm
                    > USED AT LINE 726 IN MAIN.asm
LPAREN_:            04DF DEFINED AT LINE 733 IN MAIN.asm
RPAREN_:            04E2 DEFINED AT LINE 735 IN MAIN.asm
NUM_:               04E5 DEFINED AT LINE 738 IN MAIN.asm
COLON_:             04E8 DEFINED AT LINE 740 IN MAIN.asm
RBRACK_:            04EB DEFINED AT LINE 742 IN MAIN.asm
QUOTE_:             04EE DEFINED AT LINE 745 IN MAIN.asm
STAR_:              04F0 DEFINED AT LINE 747 IN MAIN.asm
SLASH_:             04F2 DEFINED AT LINE 749 IN MAIN.asm
SLASH:              04F2 DEFINED AT LINE 756 IN MAIN.asm
ALT1:               051A DEFINED AT LINE 777 IN MAIN.asm
                    > USED AT LINE 762 IN MAIN.asm
ALT2:               052E DEFINED AT LINE 790 IN MAIN.asm
                    > USED AT LINE 764 IN MAIN.asm
                    > USED AT LINE 779 IN MAIN.asm
                    > USED AT LINE 781 IN MAIN.asm
HEX:                0531 DEFINED AT LINE 794 IN MAIN.asm
                    > USED AT LINE 746 IN MAIN.asm
HEX1:               0534 DEFINED AT LINE 796 IN MAIN.asm
                    > USED AT LINE 813 IN MAIN.asm
HEX2:               053C DEFINED AT LINE 802 IN MAIN.asm
                    > USED AT LINE 800 IN MAIN.asm
MUL:                054E DEFINED AT LINE 815 IN MAIN.asm
                    > USED AT LINE 748 IN MAIN.asm
MUL2:               0558 DEFINED AT LINE 823 IN MAIN.asm
                    > USED AT LINE 832 IN MAIN.asm
DIV:                056E DEFINED AT LINE 838 IN MAIN.asm
                    > USED AT LINE 792 IN MAIN.asm
ABSBC:              057F DEFINED AT LINE 854 IN MAIN.asm
                    > USED AT LINE 846 IN MAIN.asm
LOOP1:              0592 DEFINED AT LINE 868 IN MAIN.asm
                    > USED AT LINE 878 IN MAIN.asm
LOOP2:              0593 DEFINED AT LINE 870 IN MAIN.asm
                    > USED AT LINE 880 IN MAIN.asm
JUMPIN:             0596 DEFINED AT LINE 873 IN MAIN.asm
                    > USED AT LINE 867 IN MAIN.asm
ENDSDIV:            05A3 DEFINED AT LINE 881 IN MAIN.asm
                    > USED AT LINE 872 IN MAIN.asm
DIV10:              05AD DEFINED AT LINE 890 IN MAIN.asm
                    > USED AT LINE 883 IN MAIN.asm
ARREND:             05B4 DEFINED AT LINE 896 IN MAIN.asm
                    > USED AT LINE 743 IN MAIN.asm
ARRAYEND1:          05D2 DEFINED AT LINE 913 IN MAIN.asm
                    > USED AT LINE 931 IN MAIN.asm
ARRAYEND2:          05E3 DEFINED AT LINE 928 IN MAIN.asm
                    > USED AT LINE 912 IN MAIN.asm
                    > USED AT LINE 922 IN MAIN.asm
PAGE6:              0600 DEFINED AT LINE 947 IN MAIN.asm
ARRSIZE_:           0600 DEFINED AT LINE 950 IN MAIN.asm
ARRSIZE:            0600 DEFINED AT LINE 951 IN MAIN.asm
ANOP_:              0606 DEFINED AT LINE 958 IN MAIN.asm
BMODE_:             0608 DEFINED AT LINE 961 IN MAIN.asm
EMIT_:              0614 DEFINED AT LINE 968 IN MAIN.asm
EXEC_:              061B DEFINED AT LINE 974 IN MAIN.asm
EXEC1:              0620 DEFINED AT LINE 977 IN MAIN.asm
                    > USED AT LINE 975 IN MAIN.asm
KEY_:               0623 DEFINED AT LINE 982 IN MAIN.asm
GO_:                062C DEFINED AT LINE 989 IN MAIN.asm
GO1:                062D DEFINED AT LINE 991 IN MAIN.asm
                    > USED AT LINE 559 IN MAIN.asm
GO2:                063C DEFINED AT LINE 1001 IN MAIN.asm
                    > USED AT LINE 999 IN MAIN.asm
GO3:                063F DEFINED AT LINE 1004 IN MAIN.asm
                    > USED AT LINE 994 IN MAIN.asm
INPORT_:            0641 DEFINED AT LINE 1007 IN MAIN.asm
NEWLN_:             064C DEFINED AT LINE 1017 IN MAIN.asm
OUTPORT_:           0651 DEFINED AT LINE 1021 IN MAIN.asm
SHL_:               065A DEFINED AT LINE 1032 IN MAIN.asm
SHIFTLEFT:          065A DEFINED AT LINE 1033 IN MAIN.asm
SHIFTLEFT1:         0662 DEFINED AT LINE 1041 IN MAIN.asm
                    > USED AT LINE 1043 IN MAIN.asm
SHIFTLEFT2:         0665 DEFINED AT LINE 1044 IN MAIN.asm
                    > USED AT LINE 1039 IN MAIN.asm
SHR_:               0669 DEFINED AT LINE 1049 IN MAIN.asm
SHIFTRIGHT1:        0671 DEFINED AT LINE 1057 IN MAIN.asm
                    > USED AT LINE 1060 IN MAIN.asm
SHIFTRIGHT2:        0677 DEFINED AT LINE 1061 IN MAIN.asm
                    > USED AT LINE 1055 IN MAIN.asm
UTILITY_:           067B DEFINED AT LINE 1070 IN MAIN.asm
UTILITY:            067B DEFINED AT LINE 1071 IN MAIN.asm
UTILITY1:           0693 DEFINED AT LINE 1087 IN MAIN.asm
                    > USED AT LINE 1075 IN MAIN.asm
UTILITY2:           06A1 DEFINED AT LINE 1094 IN MAIN.asm
                    > USED AT LINE 1091 IN MAIN.asm
WHILE_:             06A3 DEFINED AT LINE 1097 IN MAIN.asm
WHILE:              06A3 DEFINED AT LINE 1098 IN MAIN.asm
WHILE2:             06B1 DEFINED AT LINE 1107 IN MAIN.asm
                    > USED AT LINE 1102 IN MAIN.asm
DEF:                06B3 DEFINED AT LINE 1114 IN MAIN.asm
                    > USED AT LINE 741 IN MAIN.asm
DEF0:               06C1 DEFINED AT LINE 1123 IN MAIN.asm
                    > USED AT LINE 1118 IN MAIN.asm
DEF1:               06CF DEFINED AT LINE 1131 IN MAIN.asm
                    > USED AT LINE 1122 IN MAIN.asm
                    > USED AT LINE 1138 IN MAIN.asm
DEF2:               06D9 DEFINED AT LINE 1139 IN MAIN.asm
                    > USED AT LINE 1137 IN MAIN.asm
DEF3:               06DA DEFINED AT LINE 1141 IN MAIN.asm
NUM:                06E0 DEFINED AT LINE 1145 IN MAIN.asm
                    > USED AT LINE 643 IN MAIN.asm
                    > USED AT LINE 739 IN MAIN.asm
NUM0:               06E9 DEFINED AT LINE 1151 IN MAIN.asm
                    > USED AT LINE 1149 IN MAIN.asm
NUM1:               06EA DEFINED AT LINE 1153 IN MAIN.asm
                    > USED AT LINE 1170 IN MAIN.asm
NUM2:               0702 DEFINED AT LINE 1171 IN MAIN.asm
                    > USED AT LINE 804 IN MAIN.asm
                    > USED AT LINE 806 IN MAIN.asm
                    > USED AT LINE 1156 IN MAIN.asm
                    > USED AT LINE 1158 IN MAIN.asm
NUM3:               070D DEFINED AT LINE 1179 IN MAIN.asm
                    > USED AT LINE 1174 IN MAIN.asm
PRINTDEC:           0710 DEFINED AT LINE 1188 IN MAIN.asm
                    > USED AT LINE 563 IN MAIN.asm
PRINTDEC2:          071F DEFINED AT LINE 1199 IN MAIN.asm
                    > USED AT LINE 1190 IN MAIN.asm
PRINTDEC4:          0741 DEFINED AT LINE 1215 IN MAIN.asm
                    > USED AT LINE 1203 IN MAIN.asm
                    > USED AT LINE 1205 IN MAIN.asm
                    > USED AT LINE 1207 IN MAIN.asm
                    > USED AT LINE 1209 IN MAIN.asm
                    > USED AT LINE 1212 IN MAIN.asm
PRINTDEC5:          0743 DEFINED AT LINE 1217 IN MAIN.asm
                    > USED AT LINE 1220 IN MAIN.asm
PRINTDEC6:          0753 DEFINED AT LINE 1229 IN MAIN.asm
                    > USED AT LINE 1224 IN MAIN.asm
PRINTDEC7:          0754 DEFINED AT LINE 1231 IN MAIN.asm
                    > USED AT LINE 1228 IN MAIN.asm
BEGIN:              0758 DEFINED AT LINE 1236 IN MAIN.asm
                    > USED AT LINE 734 IN MAIN.asm
LOOPSTART:          0758 DEFINED AT LINE 1237 IN MAIN.asm
LOOPSTART1:         075E DEFINED AT LINE 1240 IN MAIN.asm
                    > USED AT LINE 1244 IN MAIN.asm
LOOPSTART2:         0771 DEFINED AT LINE 1252 IN MAIN.asm
                    > USED AT LINE 1248 IN MAIN.asm
LOOPSTART3:         077A DEFINED AT LINE 1258 IN MAIN.asm
                    > USED AT LINE 1256 IN MAIN.asm
LOOPSTART4:         0790 DEFINED AT LINE 1268 IN MAIN.asm
                    > USED AT LINE 1251 IN MAIN.asm
AGAIN:              0792 DEFINED AT LINE 1271 IN MAIN.asm
                    > USED AT LINE 736 IN MAIN.asm
LOOPEND:            0792 DEFINED AT LINE 1272 IN MAIN.asm
LOOPEND2:           07AB DEFINED AT LINE 1288 IN MAIN.asm
                    > USED AT LINE 1282 IN MAIN.asm
LOOPEND3:           07B8 DEFINED AT LINE 1294 IN MAIN.asm
LOOPEND4:           07C7 DEFINED AT LINE 1300 IN MAIN.asm
                    > USED AT LINE 1106 IN MAIN.asm
                    > USED AT LINE 1277 IN MAIN.asm
LOOPVAR:            07CE DEFINED AT LINE 1305 IN MAIN.asm
                    > USED AT LINE 767 IN MAIN.asm
                    > USED AT LINE 770 IN MAIN.asm
CARRY:              07D8 DEFINED AT LINE 1312 IN MAIN.asm
                    > USED AT LINE 551 IN MAIN.asm
                    > USED AT LINE 651 IN MAIN.asm
COMMENT:            07E2 DEFINED AT LINE 1318 IN MAIN.asm
                    > USED AT LINE 760 IN MAIN.asm
                    > USED AT LINE 1322 IN MAIN.asm
DSIZE:              0080 DEFINED AT LINE 1 IN ram.asm
                    > USED AT LINE 14 IN ram.asm
RSIZE:              0080 DEFINED AT LINE 2 IN ram.asm
                    > USED AT LINE 11 IN ram.asm
TIBSIZE:            0100 DEFINED AT LINE 3 IN ram.asm
                    > USED AT LINE 9 IN ram.asm
VARS_SIZE:          0068 DEFINED AT LINE 5 IN ram.asm
                    > USED AT LINE 294 IN MAIN.asm
                    > USED AT LINE 74 IN ram.asm
TIB:                0800 DEFINED AT LINE 9 IN ram.asm
                    > USED AT LINE 164 IN MAIN.asm
                    > USED AT LINE 210 IN MAIN.asm
                    > USED AT LINE 219 IN MAIN.asm
                    > USED AT LINE 236 IN MAIN.asm
                    > USED AT LINE 379 IN MAIN.asm
                    > USED AT LINE 394 IN MAIN.asm
RSTACK:             0980 DEFINED AT LINE 12 IN ram.asm
                    > USED AT LINE 271 IN MAIN.asm
DSTACK:             0A00 DEFINED AT LINE 15 IN ram.asm
                    > USED AT LINE 149 IN MAIN.asm
                    > USED AT LINE 263 IN MAIN.asm
                    > USED AT LINE 266 IN MAIN.asm
                    > USED AT LINE 284 IN MAIN.asm
                    > USED AT LINE 1080 IN MAIN.asm
STACK:              0A00 DEFINED AT LINE 16 IN ram.asm
                    > USED AT LINE 445 IN IOSerial.asm
OPCODES:            0A00 DEFINED AT LINE 18 IN ram.asm
                    > USED AT LINE 299 IN MAIN.asm
ALTCODES:           0A5E DEFINED AT LINE 20 IN ram.asm
                    > USED AT LINE 782 IN MAIN.asm
MINTVARS:           0B00 DEFINED AT LINE 24 IN ram.asm
VLOOPSP:            0B30 DEFINED AT LINE 26 IN ram.asm
TBPTR:              0B32 DEFINED AT LINE 28 IN ram.asm
VTEMP1:             0B34 DEFINED AT LINE 29 IN ram.asm
                    > USED AT LINE 897 IN MAIN.asm
                    > USED AT LINE 940 IN MAIN.asm
                    > USED AT LINE 1238 IN MAIN.asm
                    > USED AT LINE 1262 IN MAIN.asm
VTEMP2:             0B36 DEFINED AT LINE 30 IN ram.asm
                    > USED AT LINE 899 IN MAIN.asm
                    > USED AT LINE 933 IN MAIN.asm
RST08:              0B38 DEFINED AT LINE 32 IN ram.asm
                    > USED AT LINE 107 IN IOSerial.asm
                    > USED AT LINE 447 IN IOSerial.asm
RST10:              0B3A DEFINED AT LINE 33 IN ram.asm
                    > USED AT LINE 113 IN IOSerial.asm
                    > USED AT LINE 448 IN IOSerial.asm
RST18:              0B3C DEFINED AT LINE 34 IN ram.asm
                    > USED AT LINE 119 IN IOSerial.asm
                    > USED AT LINE 449 IN IOSerial.asm
RST20:              0B3E DEFINED AT LINE 35 IN ram.asm
                    > USED AT LINE 125 IN IOSerial.asm
                    > USED AT LINE 450 IN IOSerial.asm
RST28:              0B40 DEFINED AT LINE 36 IN ram.asm
                    > USED AT LINE 131 IN IOSerial.asm
                    > USED AT LINE 451 IN IOSerial.asm
RST30:              0B42 DEFINED AT LINE 37 IN ram.asm
                    > USED AT LINE 137 IN IOSerial.asm
                    > USED AT LINE 452 IN IOSerial.asm
BAUD:               0B44 DEFINED AT LINE 38 IN ram.asm
INTVEC:             0B46 DEFINED AT LINE 39 IN ram.asm
                    > USED AT LINE 143 IN IOSerial.asm
                    > USED AT LINE 453 IN IOSerial.asm
NMIVEC:             0B48 DEFINED AT LINE 40 IN ram.asm
                    > USED AT LINE 191 IN IOSerial.asm
                    > USED AT LINE 454 IN IOSerial.asm
GETCVEC:            0B4A DEFINED AT LINE 41 IN ram.asm
                    > USED AT LINE 435 IN IOSerial.asm
                    > USED AT LINE 457 IN IOSerial.asm
PUTCVEC:            0B4C DEFINED AT LINE 42 IN ram.asm
                    > USED AT LINE 440 IN IOSerial.asm
                    > USED AT LINE 459 IN IOSerial.asm
ALTVARS:            0B82 DEFINED AT LINE 45 IN ram.asm
                    > USED AT LINE 274 IN MAIN.asm
                    > USED AT LINE 773 IN MAIN.asm
VBYTEMODE:          0B84 DEFINED AT LINE 48 IN ram.asm
                    > USED AT LINE 689 IN MAIN.asm
                    > USED AT LINE 724 IN MAIN.asm
                    > USED AT LINE 920 IN MAIN.asm
                    > USED AT LINE 962 IN MAIN.asm
                    > USED AT LINE 964 IN MAIN.asm
                    > USED AT LINE 965 IN MAIN.asm
VCARRY:             0B86 DEFINED AT LINE 49 IN ram.asm
                    > USED AT LINE 1315 IN MAIN.asm
VELSE:              0B8A DEFINED AT LINE 51 IN ram.asm
                    > USED AT LINE 1250 IN MAIN.asm
                    > USED AT LINE 1296 IN MAIN.asm
VFALSE:             0B8C DEFINED AT LINE 52 IN ram.asm
VHEAPPTR:           0B90 DEFINED AT LINE 54 IN ram.asm
                    > USED AT LINE 289 IN MAIN.asm
                    > USED AT LINE 906 IN MAIN.asm
                    > USED AT LINE 935 IN MAIN.asm
                    > USED AT LINE 939 IN MAIN.asm
                    > USED AT LINE 1120 IN MAIN.asm
                    > USED AT LINE 1126 IN MAIN.asm
                    > USED AT LINE 1142 IN MAIN.asm
VTIBPTR:            0B96 DEFINED AT LINE 57 IN ram.asm
                    > USED AT LINE 158 IN MAIN.asm
                    > USED AT LINE 202 IN MAIN.asm
                    > USED AT LINE 206 IN MAIN.asm
                    > USED AT LINE 235 IN MAIN.asm
                    > USED AT LINE 397 IN MAIN.asm
VPOINTER:           0BA0 DEFINED AT LINE 62 IN ram.asm
                    > USED AT LINE 628 IN MAIN.asm
                    > USED AT LINE 686 IN MAIN.asm
VREMAIN:            0BA4 DEFINED AT LINE 64 IN ram.asm
                    > USED AT LINE 835 IN MAIN.asm
                    > USED AT LINE 893 IN MAIN.asm
VS0:                0BA6 DEFINED AT LINE 65 IN ram.asm
                    > USED AT LINE 285 IN MAIN.asm
VTRUE:              0BA8 DEFINED AT LINE 66 IN ram.asm
                    > USED AT LINE 281 IN MAIN.asm
VUNLIMITED:         0BAA DEFINED AT LINE 67 IN ram.asm
                    > USED AT LINE 283 IN MAIN.asm
VLASTDEF:           0BB4 DEFINED AT LINE 72 IN ram.asm
                    > USED AT LINE 287 IN MAIN.asm
                    > USED AT LINE 1124 IN MAIN.asm
VARS:               0BB6 DEFINED AT LINE 74 IN ram.asm
                    > USED AT LINE 290 IN MAIN.asm
                    > USED AT LINE 332 IN MAIN.asm
HEAP:               0C1E DEFINED AT LINE 76 IN ram.asm
                    > USED AT LINE 288 IN MAIN.asm
