0000                          .ENGINE   mycomputer   
0000                             ; 
0000                TEC_1:    EQU   1   
0000                RC2014:   EQU   0   
0000                EXTENDED:   EQU   0   
0000                          IF   TEC_1   
0000                             ; Configuration for TEC-1
0000                LOADER:   EQU   0   
0000                BITBANG:   EQU   0   
0000                ROMSTART:   EQU   $0000   
0000                RAMSTART:   EQU   $0800   
0000                          ENDIF      
0000                          IF   RC2014   
                                 ; Configuration for RC2014
                    ROMSTART:   EQU   $8000   
                    RAMSTART:   EQU   $8800   
                    LOADER:   EQU   0   
                    BITBANG:   EQU   0   
0000                          ENDIF      
0000                             ; ROM code
0000                             ; Targets:
0000                             ; TEC-1,TEC-1D,TEC-1F,Southern Cross,RC2014
0000                             ; Memory Map: 2k ROM/RAM, 8K ROM/RAM, RC2014
0000                             ; Serial: Bit Bang, 6850 ACIA
0000                             ; 
0000                          IF   TEC_1   
0000                          IF   BITBANG   
                                 ; 
                                 ; bit bang baud rate constants @ 4MHz
                    B300:     EQU   0220H   
                    B1200:    EQU   0080H   
                    B2400:    EQU   003FH   
                    B4800:    EQU   001BH   
                    B9600:    EQU   000BH   
                                 ; 
0000                          ELSE      ;6850
0000                             ; 
0000                             ; 
0000                             ; 6850 ACIA registers
0000                             ;----------------------
0000                CONTROL:   EQU   $80   ;(write) 
0000                STATUS:   EQU   $80   ;(read)
0000                TDR:      EQU   $81   ;(write)
0000                RDR:      EQU   $81   ;(read)
0000                             ; 
0000                             ; control register bits
0000                             ;----------------------
0000                             ; 
0000                             ;clock divisor
0000                             ; 
0000                MRESET:   EQU   $03   ;master reset the ACIA
0000                             ; DIV_0    .EQU  $00        ;CLOCK/1
0000                             ; DIV_16   .EQU  $01        ;CLOCK/16
0000                DIV_64:   EQU   $02   ;CLOCK/64
0000                             ; 
0000                             ; format select
0000                             ; 
0000                F7E2:     EQU   $00   ;7 data bits, EVEN parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7O2:     EQU   $04   ;7 data bits, ODD parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7E1:     EQU   $08   ;7 data bits, EVEN parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F7O1:     EQU   $0C   ;7 data bits, ODD parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F8N2:     EQU   $10   ;8 data bits, NO parity, 2 stop bits (1+8+0+2= 11 bits)
0000                F8N1:     EQU   $14   ;8 data bits, NO parity, 1 stop bit (1+8+0+1= 10 bits)
0000                F8E1:     EQU   $18   ;8 data bits, EVEN parity, 1 stop bit (1+8+1+1= 11 bits)
0000                F8O1:     EQU   $1C   ;8 data bits, ODD parity,1 stop bit (1+8+1+1= 11 bits)
0000                             ; 
0000                             ; transmitter control
0000                             ; 
0000                RTSLID:   EQU   $00   ;RTS LOW, transmit interrupt disabled
0000                RTSLIE:   EQU   $20   ;RTS LOW, transmit interrupt enabled
0000                RTSHID:   EQU   $40   ;RTS HIGH, transmit interrupt disabled
0000                RTSLIDB:   EQU   $60   ;RTS LOW, transmit interrupt disabled and "break" transmitted
0000                             ; 
0000                             ; receiver interrupt
0000                             ; 
0000                RIE:      EQU   $80   ;receiver interrupt enabled
0000                             ; 
0000                             ; status register bits
0000                             ;---------------------
0000                RDRF:     EQU   0   ;receive data register full
0000                TDRE:     EQU   1   ;transmit data register empty
0000                DCD:      EQU   2   ;data carrier detect
0000                CTS:      EQU   3   ;clear to send
0000                FE:       EQU   4   ;framing error
0000                OVRN:     EQU   5   ;overrun
0000                PE:       EQU   6   ;parity error
0000                IRQ:      EQU   7   ;interrupt request
0000                             ; 
0000                          ENDIF      
0000                          ENDIF      
0000                             ; 
0000                             ; I/O port addresses
0000                             ; 
0000                          IF   TEC_1   
0000                KEYBUF:   EQU   00H   ;MM74C923N KEYBOARD ENCODER
0000                SCAN:     EQU   01H   ;DISPLAY SCAN LATCH
0000                DISPLY:   EQU   02H   ;DISPLAY LATCH
0000                PORT3:    EQU   03H   ;ST3 (8X8), STROBE (RELAY BOARD) DATLATCH (DAT BOARD)
0000                PORT4:    EQU   04H   ;ST4 (8X8), LCD "E" (DAT BOARD)
0000                PORT5:    EQU   05H   
0000                PORT6:    EQU   06H   
0000                PORT7:    EQU   07H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ELSE      ;SC
                    IO0:      EQU   80H   ;IO PORT 0
                    IO1:      EQU   81H   ;IO PORT 1
                    IO2:      EQU   82H   ;IO PORT 2
                    IO3:      EQU   83H   ;IO PORT 3
                    DISPLY:   EQU   84H   ;DISPLAY LATCH
                    SCAN:     EQU   85H   ;DISPLAY SCAN LATCH
                    KEYBUF:   EQU   86H   ;KEYBOARD BUFFER
                    IO7:      EQU   87H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ENDIF      
0000                             ; 
0000                             ; ASCII codes
0000                ESC:      EQU   1BH   
0000                CR:       EQU   0DH   
0000                LF:       EQU   0AH   
0000                             ; 
0000                          .ORG   ROMSTART   
0000                             ;reset
0000                RSTVEC:      
0000   C3 8B 00               JP   RESET   
0003                             ;RST 1
0008                          .ORG   ROMSTART+$08   
0008   E5                     PUSH   HL   
0009   2A 34 0D               LD   HL,(RST08)   
000C   E9                     JP   (HL)   
000D                             ; 
000D                             ;RST 2
0010                          .ORG   ROMSTART+$10   
0010   E5                     PUSH   HL   
0011   2A 36 0D               LD   HL,(RST10)   
0014   E9                     JP   (HL)   
0015                             ; 
0015                             ;RST 3
0018                          .ORG   ROMSTART+$18   
0018   E5                     PUSH   HL   
0019   2A 38 0D               LD   HL,(RST18)   
001C   E9                     JP   (HL)   
001D                             ; 
001D                             ;RST 4
0020                          .ORG   ROMSTART+$20   
0020   E5                     PUSH   HL   
0021   2A 3A 0D               LD   HL,(RST20)   
0024   E9                     JP   (HL)   
0025                             ; 
0025                             ;RST 5
0028                          .ORG   ROMSTART+$28   
0028   E5                     PUSH   HL   
0029   2A 3C 0D               LD   HL,(RST28)   
002C   E9                     JP   (HL)   
002D                             ; 
002D                             ;RST 6
0030                          .ORG   ROMSTART+$30   
0030   E5                     PUSH   HL   
0031   2A 3E 0D               LD   HL,(RST30)   
0034   E9                     JP   (HL)   
0035                             ; 
0035                             ;RST 7 Interrupt
0038                          .ORG   ROMSTART+$38   
0038   E5                     PUSH   HL   
0039   2A 42 0D               LD   HL,(INTVEC)   
003C   E9                     JP   (HL)   
003D   ED 4D                  RETI      
003F                             ; 
0040                          .ORG   ROMSTART+$40   
0040                             ; 
0040                             ;hexadecimal to 7 segment display code table
0040                          IF   TEC_1   
0040                             ; 
0040                SEVENSEGMENT:      
0040   EB 28 CD AD            DB   0EBH,28H,0CDH,0ADH   ;0,1,2,3
0044   2E A7 E7 29            DB   2EH,0A7H,0E7H,29H   ;4,5,6,7
0048   EF 2F 6F E6            DB   0EFH,2FH,6FH,0E6H   ;8,9,A,B
004C   C3 EC C7 47            DB   0C3H,0ECH,0C7H,47H   ;C,D,E,F
0050                          ELSE      ;SC
                                 ; 
                    SEVENSEGMENT:      
                              DB   3FH,06H,5BH,4FH   ;0,1,2,3
                              DB   66H,6DH,7DH,07H   ;4,5,6,7
                              DB   7FH,6FH,77H,7CH   ;8,9,A,B
                              DB   39H,5EH,79H,71H   ;C,D,E,F
0050                          ENDIF      
0050                             ; 
0050                             ; 
0050                             ;---------------
0050                             ; BIT TIME DELAY
0050                             ;---------------
0050                             ;DELAY FOR ONE SERIAL BIT TIME
0050                             ;ENTRY : HL = DELAY TIME
0050                             ; NO REGISTERS MODIFIED
0050                             ; 
0050                PWRUP:       
0050   21 00 20               LD   hl,$2000   
0053                BITIME:      
0053   E5                     PUSH   HL   
0054   D5                     PUSH   DE   
0055   11 01 00               LD   DE,0001H   
0058                BITIM1:      
0058   ED 52                  SBC   HL,DE   
005A   D2 58 00               JP   NC,BITIM1   
005D   D1                     POP   DE   
005E   E1                     POP   HL   
005F                INTRET:      
005F   C9                     RET      
0060                             ; 
0060                             ;RST 8  Non Maskable Interrupt
0066                          .ORG   ROMSTART+$66   
0066   E5                     PUSH   HL   
0067   2A 44 0D               LD   HL,(NMIVEC)   
006A   E9                     JP   (HL)   
006B                             ; 
006B                             ; 
006B                          IF   BITBANG   
                                 ; 
                                 ;------------------------
                                 ; SERIAL TRANSMIT ROUTINE
                                 ;------------------------
                                 ;TRANSMIT BYTE SERIALLY ON DOUT
                                 ; 
                                 ; ENTRY : A = BYTE TO TRANSMIT
                                 ;  EXIT : NO REGISTERS MODIFIED
                                 ; 
                                 ; 
                    TXCHAR:      
                    TXDATA:      
                              PUSH   AF   
                              PUSH   BC   
                              PUSH   HL   
                              LD   HL,(BAUD)   
                              LD   C,A   
                                 ; 
                                 ; TRANSMIT START BIT
                                 ; 
                              XOR   A   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                                 ; 
                                 ; TRANSMIT DATA
                                 ; 
                              LD   B,08H   
                              RRC   C   
                    NXTBIT:      
                              RRC   C   ;SHIFT BITS TO D6,
                              LD   A,C   ;LSB FIRST AND OUTPUT
                              AND   40H   ;THEM FOR ONE BIT TIME.
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              DJNZ   NXTBIT   
                                 ; 
                                 ; SEND STOP BITS
                                 ; 
                              LD   A,40H   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              CALL   BITIME   
                              POP   HL   
                              POP   BC   
                              POP   AF   
                              RET      
                                 ;-----------------------
                                 ; SERIAL RECEIVE ROUTINE
                                 ;-----------------------
                                 ;RECEIVE SERIAL BYTE FROM DIN
                                 ; 
                                 ; ENTRY : NONE
                                 ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
                                 ; 
                                 ; REGISTERS MODIFIED A AND F
                                 ; 
                    RXCHAR:      
                    RXDATA:      
                              PUSH   BC   
                              PUSH   HL   
                                 ; 
                                 ; WAIT FOR START BIT 
                                 ; 
                    RXDAT1:   IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;NO START BIT
                                 ; 
                                 ; DETECTED START BIT
                                 ; 
                              LD   HL,(BAUD)   
                              SRL   H   
                              RR   L   ;DELAY FOR HALF BIT TIME
                              CALL   BITIME   
                              IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;START BIT NOT VALID
                                 ; 
                                 ; DETECTED VALID START BIT,READ IN DATA
                                 ; 
                              LD   B,08H   
                    RXDAT2:      
                              LD   HL,(BAUD)   
                              CALL   BITIME   ;DELAY ONE BIT TIME
                              IN   A,(KEYBUF)   
                              RL   A   
                              RR   C   ;SHIFT BIT INTO DATA REG
                              DJNZ   RXDAT2   
                              LD   A,C   
                              OR   A   ;CLEAR CARRY FLAG
                              POP   HL   
                              POP   BC   
                              RET      
                                 ; 
006B                          ELSE      ;6850
006B                             ; 
006B                             ; transmit a character in a
006B                             ;--------------------------
006B                TXDATA:      
006B                TXCHAR:      
006B   C5                     PUSH   bc   
006C   47                     LD   b,a   ;save the character  for later
006D                TXCHAR1:      
006D   DB 80                  IN   a,(STATUS)   ;get the ACIA status
006F   CB 4F                  BIT   1,a   
0071                             ;        bit   TDRE,a                ;is the TDRE bit high?
0071   28 FA                  JR   z,TxChar1   ;no, the TDR is not empty
0073   78                     LD   a,b   ;yes, get the character
0074   D3 81                  OUT   (TDR),a   ;and put it in the TDR
0076   C1                     POP   bc   
0077   C9                     RET      
0078                             ; 
0078                             ; receive  a character in a
0078                             ;---------------------------------
0078                RXDATA:      
0078                RXCHAR:      
0078   DB 80                  IN   a,(STATUS)   ;get the ACIA status
007A   CB 47                  BIT   0,a   
007C                             ;        bit   RDRF,a             ;is the RDRF bit high?
007C   28 FA                  JR   z,RxChar   ;no, the RDR is empty
007E   DB 81                  IN   a,(RDR)   ;yes, read the received char
0080   C9                     RET      
0081                          ENDIF      
0081                             ; 
0081                          IF   LOADER   
                                 ;   .ORG   ROMSTART + $0700
                                 ;-----------------------
                                 ; RECEIVE INTEL HEX FILE
                                 ;-----------------------
                    INTELH:      
                              LD   IX,BUF   
                                 ; 
                                 ; WAIT FOR RECORD MARK
                                 ; 
                    INTEL1:      
                              XOR   A   
                              LD   (IX+3),A   ;CLEAR CHECKSUM
                              CALL   RXDATA   ;WAIT FOR THE RECORD MARK
                              CP   ":"   ;TO BE TRANSMITTED
                              JR   NZ,INTEL1   ;NOT RECORD MARK
                                 ; 
                                 ; GET RECORD LENGTH
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+0),A   ;NUMBER OF DATA BYTES
                                 ; 
                                 ; GET ADDRESS FIELD
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+2),A   ;LOAD ADDRESS HIGH BYTE
                              CALL   GETBYT   
                              LD   (IX+1),A   ;LOAD ADDRESS LOW BYTE
                                 ; 
                                 ; GET RECORD TYPE
                                 ; 
                              CALL   GETBYT   
                              JR   NZ,INTEL4   ;END OF FILE RECORD
                                 ; 
                                 ; READ IN THE DATA
                                 ; 
                              LD   B,(IX+0)   ;NUMBER OF DATA BYTES
                              LD   H,(IX+2)   ;LOAD ADDRESS HIGH BYTE
                              LD   L,(IX+1)   ;LOAD ADDRESS LOW BYTE
                                 ; 
                    INTEL2:      
                              CALL   GETBYT   ;GET DATA BYTE
                              LD   (HL),A   ;STORE DATA BYTE
                              INC   HL   
                              DJNZ   INTEL2   ;LOAD MORE BYTES
                                 ; 
                                 ; GET CHECKSUM AND COMPARE
                                 ; 
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE RECORD CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              JR   Z,INTEL1   ;CHECKSUM OK,NEXT RECORD
                              RET      ;NZ=CHECKSUM ERROR
                                 ; 
                                 ; END OF FILE RECORD
                                 ; 
                    INTEL4:      
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE EOF CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              RET      ;NZ=CHECKSUM ERROR
                                 ;--------------------------
                                 ; GET BYTE FROM SERIAL PORT
                                 ;--------------------------
                    GETBYT:      
                              PUSH   BC   
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT1   
                              ADD   A,09H   
                    GETBT1:      
                              AND   0FH   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              LD   C,A   
                                 ; 
                                 ; GET LOW NYBBLE
                                 ; 
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT2   
                              ADD   A,09H   
                    GETBT2:   AND   0FH   
                              OR   C   
                              LD   B,A   
                              ADD   A,(IX+3)   
                              LD   (IX+3),A   ;ADD TO CHECKSUM
                              LD   A,B   
                              AND   A   ;CLEAR CARRY
                              POP   BC   
                              RET      
0081                          ENDIF      
0081                             ; 
0081                             ; in this example code just wait for an INTEL Hex file download
0081                             ;just going to send a char to let you know I'm here
0081                          IF   LOADER   
                                 ; 
                    LOAD:        
                              LD   a,"L"   ; L for load
                              CALL   TxChar   
                              CALL   INTELH   
                              JP   z,RAMSTART   ;assume the downloaded code starts here
                              LD   a,"0"   ;0 is false
                              CALL   TxChar   
                              JR   load   ;if at first you don't succeed...
0081                          ENDIF      
0081                             ; 
0081                GETCHAR:      
0081   2A 46 0D               LD   HL,(GETCVEC)   
0084   E9                     JP   (HL)   
0085                             ; 
0085                PUTCHAR:      
0085   E5                     PUSH   HL   
0086   2A 48 0D               LD   HL,(PUTCVEC)   
0089   E3                     EX   (SP),HL   
008A   C9                     RET      
008B                             ; 
008B                RESET:       
008B   31 00 0B               LD   SP,stack   
008E   21 5F 00               LD   HL,IntRet   
0091   22 34 0D               LD   (RST08),HL   
0094   22 36 0D               LD   (RST10),HL   
0097   22 38 0D               LD   (RST18),HL   
009A   22 3A 0D               LD   (RST20),HL   
009D   22 3C 0D               LD   (RST28),HL   
00A0   22 3E 0D               LD   (RST30),HL   
00A3   22 42 0D               LD   (INTVEC),HL   
00A6   22 44 0D               LD   (NMIVEC),HL   
00A9                             ; 
00A9   21 78 00               LD   HL,RXDATA   
00AC   22 46 0D               LD   (GETCVEC),HL   
00AF   21 6B 00               LD   HL,TXDATA   
00B2   22 48 0D               LD   (PUTCVEC),HL   
00B5                             ; 
00B5                          IF   TEC_1   
00B5                          IF   BITBANG = 0   
00B5                             ; 
00B5   3E 03                  LD   a,MRESET   
00B7   D3 80                  OUT   (CONTROL),a   ;reset the ACIA
00B9                             ; 
00B9                          ENDIF      
00B9                          ENDIF      
00B9                             ; 
00B9   CD 50 00               CALL   PWRUP   
00BC   ED 56                  IM   1   
00BE   FB                     EI      
00BF                             ; 
00BF                          IF   TEC_1   
00BF                          IF   BITBANG   
                                 ; 
                                 ;inline serial initialisation
                              LD   A,$40   
                              LD   C,SCAN   
                              OUT   (C),A   
                              LD   HL,B4800   
                              LD   (BAUD),HL   
                                 ; 
00BF                          ELSE      ;6850      
00BF                             ; 
00BF   3E 12                  LD   a,RTSLID+F8N2+DIV_64   
00C1   D3 80                  OUT   (CONTROL),a   ;initialise ACIA  8 bit word, No parity 2 stop divide by 64 for 115200 baud
00C3                             ; 
00C3                          ENDIF      
00C3                          ENDIF      
00C3                             ; 
00C3                             ; 
00C3                             ; 
00C3   C3 C6 01               JP   start   
00C6                             ; 
00C6                             ; *************************************************************************
00C6                             ; 
00C6                             ;       Mondo Minimal Interpreter for the Z80
00C6                             ; 
00C6                             ;       by John Hardy and contains code from the
00C6                             ;       MINT project by Ken Boak and Craig Jones.
00C6                             ; 
00C6                             ;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
00C6                             ; 
00C6                             ;       see the LICENSE file in this repo for more information
00C6                             ; 
00C6                             ; *****************************************************************************
00C6                TRUE:     EQU   1   
00C6                FALSE:    EQU   0   
00C6                NULL:     EQU   0   
00C6                ETX:      EQU   3   
00C6                .macro LITDAT,len
00C6                             ; 
00C6                 db len
00C6                .endm
00C6                 
00C6                .macro REPDAT,len,data
00C6                             ; 
00C6                 db (len | $80)
00C6                 db data
00C6                .endm
00C6                 
00C6                .macro ENDDAT,
00C6                             ; 
00C6                 db 0
00C6                .endm
00C6                 
00C6                             ; **************************************************************************
00C6                             ; Page 0  Initialisation
00C6                             ; **************************************************************************		
0180                          .ORG   ROMSTART + $180   ; 0+180 put Mondo code from here	
0180                IOPCODES:      
0180                          ;*Macro unroll:  LITDAT 15
0180   0F                     DB   15   
0181   4C                     DB   lsb(bang_)   ;   !
0182   00                     DB   lsb(nop_)   ;   "
0183   30                     DB   lsb(hash_)   ;   #
0184   DD                     DB   lsb(dollar_)   ;   $
0185   00                     DB   lsb(nop_)   ;   %
0186   02                     DB   lsb(amper_)   ;   &
0187   A7                     DB   lsb(quote_)   ;   '
0188   F4                     DB   lsb(lparen_)   ;   (
0189   E6                     DB   lsb(rparen_)   ;   )
018A   3D                     DB   lsb(star_)   ;   *
018B   16                     DB   lsb(plus_)   ;   +
018C   00                     DB   lsb(nop_)   ;   ,
018D   56                     DB   lsb(minus_)   ;   -
018E   E0                     DB   lsb(dot_)   ;   .
018F   CC                     DB   lsb(slash_)   ;   /	
0190                          ;*Macro unroll:  REPDAT 10, lsb(num_)		; 10 x repeat lsb of add to the num routine
0190   8A                     DB   (10 | $80)   ; 10 x repeat lsb of add to the num routine
0191   E3                     DB   lsb(num_)   
0192                          ;*Macro unroll:  LITDAT 7
0192   07                     DB   7   
0193   F2                     DB   lsb(colon_)   ;   :
0194   45                     DB   lsb(semi_)   ;   ;
0195   84                     DB   lsb(lt_)   ;   <
0196   74                     DB   lsb(eq_)   ;   =
0197   80                     DB   lsb(gt_)   ;   >
0198   00                     DB   lsb(nop_)   ;   ?   ( -- val )  read a char from input
0199   00                     DB   lsb(at_)   ;   @
019A                          ;*Macro unroll:  REPDAT 26, lsb(var_)	; call a command A, B ....Z
019A   9A                     DB   (26 | $80)   ; call a command A, B ....Z
019B   95                     DB   lsb(var_)   
019C                          ;*Macro unroll:  LITDAT 6
019C   06                     DB   6   
019D   F6                     DB   lsb(lbrack_)   ;    [
019E   DA                     DB   lsb(backslash_)   ;    \
019F   FF                     DB   lsb(rbrack_)   ;    ]
01A0   D7                     DB   lsb(caret_)   ;    ^   ; execute Mondo code
01A1   00                     DB   lsb(nop_)   ;    _
01A2   BD                     DB   lsb(grave_)   ;    `   ; print literal `hello`
01A3                          ;*Macro unroll:  REPDAT 26, lsb(var_)		; a b c ...z
01A3   9A                     DB   (26 | $80)   ; a b c ...z
01A4   95                     DB   lsb(var_)   
01A5                          ;*Macro unroll:  LITDAT 4
01A5   04                     DB   4   
01A6   E9                     DB   lsb(shl_)   ;    {
01A7   0D                     DB   lsb(pipe_)   ;    |
01A8   EC                     DB   lsb(shr_)   ;    }
01A9   EF                     DB   lsb(tilde_)   ;    ~
01AA                IALTCODES:      
01AA                          ;*Macro unroll:  LITDAT 26
01AA   1A                     DB   26   
01AB   00                     DB   lsb(arrayLength_)   ;       \A  ; array size
01AC   08                     DB   lsb(togByteMode_)   ;       \B  ; toggle byte mode
01AD   36                     DB   lsb(prnChar_)   ;       \C  ; print char
01AE   16                     DB   lsb(decimal_)   ;       \D  ; decimal
01AF   34                     DB   lsb(aNop_)   ;       \E  ;
01B0   34                     DB   lsb(aNop_)   ;       \F  ;
01B1   3D                     DB   lsb(go_)   ;       \G  ; go
01B2   11                     DB   lsb(hexadecimal_)   ;       \H  ; hexadecimal
01B3   4A                     DB   lsb(inPort_)   ;       \I  ; in port
01B4   34                     DB   lsb(aNop_)   ;       \J  ;
01B5   55                     DB   lsb(key_)   ;       \K  ; key input
01B6   34                     DB   lsb(aNop_)   ;       \L  ;
01B7   34                     DB   lsb(aNop_)   ;       \M  ;
01B8   5E                     DB   lsb(newln_)   ;       \N  ; new line
01B9   63                     DB   lsb(outPort_)   ;       \O  ; out port
01BA   6C                     DB   lsb(prnStr_)   ;       \P  ; print string
01BB   72                     DB   lsb(quit_)   ;       \Q  ; quit. early return
01BC   34                     DB   lsb(aNop_)   ;       \R  ;
01BD   34                     DB   lsb(aNop_)   ;       \S  ;
01BE   34                     DB   lsb(aNop_)   ;       \T  ;
01BF   34                     DB   lsb(aNop_)   ;       \U  ;
01C0   34                     DB   lsb(aNop_)   ;       \V  ;
01C1   1E                     DB   lsb(while_)   ;       \W  ; while
01C2   7A                     DB   lsb(xor_)   ;       \X  ; xor
01C3   34                     DB   lsb(aNop_)   ;       \Y  ;
01C4   34                     DB   lsb(aNop_)   ;       \Z  ;
01C5                          ;*Macro unroll:  ENDDAT
01C5   00                     DB   0   
01C6                START:       
01C6   31 00 0B               LD   SP,DSTACK   ; start of Mondo
01C9   CD 75 02               CALL   init   ; setups
01CC   CD DC 02               CALL   printStr   ; prog count to stack, put code line 235 on stack then call print
01CF   4D 69 6E 64 79 20 56 31 2E 30 0D 0A 00 .CSTR   "Mondo V1.0\r\n"   
01DC                INTERPRET:      
01DC   CD 5E 06               CALL   prompt   
01DF   01 00 00               LD   bc,0   ; load bc with offset into TIB, decide char into tib or execute or control
01E2   ED 43 76 0D            LD   (vTIBPtr),bc   
01E6                INTERPRET2:      ; calc nesting (a macro might have changed it)
01E6   1E 00                  LD   E,0   ; initilize nesting value
01E8   C5                     PUSH   bc   ; save offset into TIB,
01E9                             ; bc is also the count of chars in TIB
01E9   21 00 08               LD   hl,TIB   ; hl is start of TIB
01EC   18 06                  JR   interpret4   
01EE                INTERPRET3:      
01EE   7E                     LD   A,(hl)   ; A = char in TIB
01EF   23                     INC   hl   ; inc pointer into TIB
01F0   0B                     DEC   bc   ; dec count of chars in TIB
01F1   CD E1 06               CALL   nesting   ; update nesting value
01F4                INTERPRET4:      
01F4   79                     LD   A,C   ; is count zero?
01F5   B0                     OR   B   
01F6   20 F6                  JR   NZ,interpret3   ; if not loop
01F8   C1                     POP   bc   ; restore offset into TIB
01F9                             ; *******************************************************************
01F9                             ; Wait for a character from the serial input (keyboard)
01F9                             ; and store it in the text buffer. Keep accepting characters,
01F9                             ; increasing the instruction pointer bc - until a newline received.
01F9                             ; *******************************************************************
01F9                WAITCHAR:      
01F9   CD 81 00               CALL   getchar   ; loop around waiting for character from serial port
01FC   FE 20                  CP   " "   ; compare to space
01FE   30 20                  JR   NC,waitchar1   ; if >= space, if below 20 set cary flag
0200   FE 00                  CP   NULL   ; is it end of string? null end of string
0202   28 40                  JR   Z,waitchar4   
0204   FE 0D                  CP   "\r"   ; carriage return? ascii 13
0206   28 26                  JR   Z,waitchar3   ; if anything else its macro/control
0208   ED 43 76 0D            LD   (vTIBPtr),bc   
020C   FE 08                  CP   "\b"   ; ^H
020E   20 D6                  JR   nz,interpret2   
0210   79                     LD   a,c   
0211   B0                     OR   b   
0212   CA E6 01               JP   z,interpret2   
0215   0B                     DEC   bc   
0216   CD DC 02               CALL   printStr   
0219   08 20 08 00            .CSTR   "\b \b"   
021D   C3 E6 01               JP   interpret2   
0220                WAITCHAR1:      
0220   21 00 08               LD   hl,TIB   
0223   09                     ADD   hl,bc   
0224   77                     LD   (hl),A   ; store the character in textbuf
0225   03                     INC   bc   
0226   CD 85 00               CALL   putchar   ; echo character to screen
0229   CD E1 06               CALL   nesting   
022C   18 CB                  JR   waitchar   ; wait for next character
022E                WAITCHAR3:      
022E   21 00 08               LD   hl,TIB   
0231   09                     ADD   hl,bc   
0232   36 0D                  LD   (hl),"\r"   ; store the crlf in textbuf
0234   23                     INC   hl   
0235   36 0A                  LD   (hl),"\n"   
0237   23                     INC   hl   ; ????
0238   03                     INC   bc   
0239   03                     INC   bc   
023A   CD 71 06               CALL   crlf   ; echo character to screen
023D   7B                     LD   a,e   ; if zero nesting append and ETX after \r
023E   B7                     OR   a   
023F   20 B8                  JR   NZ,waitchar   
0241   36 03                  LD   (hl),ETX   ; store end of text ETX in text buffer
0243   03                     INC   bc   
0244                WAITCHAR4:      
0244   ED 43 76 0D            LD   (vTIBPtr),bc   
0248   01 00 08               LD   bc,TIB   ; Instructions stored on heap at address HERE, we pressed enter
024B   0B                     DEC   bc   
024C                NEXT:        
024C   03                     INC   bc   ;   Increment the IP
024D   0A                     LD   A,(bc)   ;   Get the next character and dispatch
024E   FE 00                  CP   0   ;   NUL get least signif byte of address exit_
0250   21 26 03               LD   hl,exit_   
0253   28 13                  JR   z,next1   
0255   FE 03                  CP   ETX   ;   ETX
0257   21 69 02               LD   hl,endTxt   
025A   28 0C                  JR   z,next1   
025C   FE 21                  CP   " "+1   
025E   38 EC                  JR   c,next   
0260   D6 21                  SUB   "!"   
0262   6F                     LD   l,a   ;       Index into table
0263   26 0C                  LD   H,msb(opcodes)   ;       Start address of jump table
0265   6E                     LD   L,(hl)   ;       get low jump address
0266   26 03                  LD   H,msb(page4)   ;       Load H with the 1st page address
0268                NEXT1:       
0268   E9                     JP   (hl)   ;       Jump to routine
0269                ENDTXT:      
0269   21 00 F5               LD   hl,-DSTACK   ;       if too much popped of stack rest stack pointer
026C   39                     ADD   hl,SP   
026D   30 03                  JR   NC,endTxt1   
026F   31 00 0B               LD   SP,DSTACK   
0272                ENDTXT1:      
0272   C3 DC 01               JP   interpret   
0275                INIT:        
0275   21 80 0B               LD   hl,LSTACK   
0278   22 30 0D               LD   (vLoopSP),hl   ; Loop stack pointer stored in memory
027B   DD 21 80 0A            LD   IX,RSTACK   
027F   FD 21 4C 02            LD   IY,next   ; IY provides a faster jump to next
0283   21 50 0D               LD   hl,altVars   ; init altVars to 0 using LDIR
0286   54 5D                  LD   de,hl   
0288   13                     INC   de   
0289   36 00                  LD   (hl),0   
028B   01 34 00               LD   bc,26 * 2   
028E   ED B0                  LDIR      
0290   21 00 09               LD   hl,BUFFER   ; \a vBufPtr			
0293   22 50 0D               LD   (vBufPtr),hl   
0296   21 EC 0D               LD   hl,HEAP   ; \h vHeapPtr start of the free mem
0299   22 5E 0D               LD   (vHeapPtr),hl   
029C   21 00 08               LD   hl,TIB   ; \t vTIBPtr			
029F   22 76 0D               LD   (vTIBPtr),hl   
02A2   21 84 0D               LD   hl,variables   ; init namespaces to 0 using LDIR
02A5   54 5D                  LD   de,hl   
02A7   13                     INC   de   
02A8   36 00                  LD   (hl),0   
02AA   01 68 00               LD   bc,VARS_SIZE   
02AD   ED B0                  LDIR      
02AF                INITOPS:      
02AF   21 80 01               LD   hl,iOpcodes   
02B2   11 00 0C               LD   de,opcodes   
02B5   01 00 01               LD   bc,256   
02B8                INITOPS1:      
02B8   7E                     LD   A,(hl)   
02B9   23                     INC   hl   
02BA   CB 27                  SLA   A   
02BC   C8                     RET   Z   
02BD   38 09                  JR   C,initOps2   
02BF   CB 3F                  SRL   A   
02C1   4F                     LD   C,A   
02C2   06 00                  LD   B,0   
02C4   ED B0                  LDIR      
02C6   18 F0                  JR   initOps1   
02C8                INITOPS2:      
02C8   CB 3F                  SRL   A   
02CA   47                     LD   B,A   
02CB   7E                     LD   A,(hl)   
02CC   23                     INC   hl   
02CD                INITOPS2A:      
02CD   12                     LD   (de),A   
02CE   13                     INC   de   
02CF   10 FC                  DJNZ   initOps2a   
02D1   18 E5                  JR   initOps1   
02D3                ENTER:       ;=9
02D3   60 69                  LD   hl,bc   
02D5   CD E3 02               CALL   rpush   ; save Instruction Pointer
02D8   C1                     POP   bc   
02D9   0B                     DEC   bc   
02DA   FD E9                  JP   (iy)   
02DC                PRINTSTR:      ;=14
02DC   E3                     EX   (SP),hl   ; swap			
02DD   CD 6B 06               CALL   putStr   
02E0   23                     INC   hl   ; inc past null
02E1   E3                     EX   (SP),hl   ; put it back	
02E2   C9                     RET      
02E3                RPUSH:       ;=11
02E3   DD 2B                  DEC   IX   
02E5   DD 74 00               LD   (IX+0),H   
02E8   DD 2B                  DEC   IX   
02EA   DD 75 00               LD   (IX+0),L   
02ED   C9                     RET      
02EE                RPOP:        ;=11
02EE   DD 6E 00               LD   L,(IX+0)   
02F1   DD 23                  INC   IX   
02F3   DD 66 00               LD   H,(IX+0)   
02F6   DD 23                  INC   IX   
02F8                RPOP2:       
02F8   C9                     RET      
02F9                WRITECHAR:      ;=5
02F9   77                     LD   (hl),A   
02FA   23                     INC   hl   
02FB   C3 85 00               JP   putchar   
02FE                             ; **********************************************************************			
02FE                             ; Page 3 primitive routines
02FE                             ; **********************************************************************
02FE                          ALIGN   $100   
0300                PAGE4:       
0300                AT_:         
0300                NOP_:        
0300   FD E9                  JP   (iy)   
0302                AMPER_:      
0302                AND:         
0302   D1                     POP   de   ;     Bitwise and the top 2 elements of the stack
0303   E1                     POP   hl   ; 
0304   7B                     LD   a,e   ; 
0305   A5                     AND   L   ; 
0306   6F                     LD   l,a   ; 
0307   7A                     LD   A,D   ; 
0308   A4                     AND   H   ; 
0309                AND1:        
0309   67                     LD   h,a   ; 
030A   E5                     PUSH   hl   ; 
030B   FD E9                  JP   (iy)   
030D                PIPE_:       
030D                OR_:         
030D   D1                     POP   de   ; Bitwise or the top 2 elements of the stack
030E   E1                     POP   hl   
030F   7B                     LD   a,e   
0310   B5                     OR   L   
0311   6F                     LD   l,a   
0312   7A                     LD   A,D   
0313   B4                     OR   H   
0314   18 F3                  JR   and1   
0316                PLUS_:       ; Add the top 2 members of the stack
0316   D1                     POP   de   
0317   03                     INC   bc   
0318   FE 2B                  CP   "+"   
031A   20 04                  JR   nz,plus1   
031C   13                     INC   de   
031D   C3 4E 03               JP   assign0   
0320                PLUS1:       
0320   0B                     DEC   bc   
0321   E1                     POP   hl   
0322   19                     ADD   hl,de   
0323   E5                     PUSH   hl   
0324   FD E9                  JP   (iy)   
0326                EXIT_:       
0326   03                     INC   bc   ; store offests into a table of bytes, smaller
0327   50 59                  LD   de,bc   
0329   CD EE 02               CALL   rpop   ; Restore Instruction pointer
032C   44 4D                  LD   bc,hl   
032E   EB                     EX   de,hl   
032F   E9                     JP   (hl)   
0330                HASH_:       
0330                ARRAYACCESS:      
0330   E1                     POP   hl   ; hl = index
0331   D1                     POP   de   ; de = array
0332   3A 52 0D               LD   a,(vByteMode)   ; a = data width
0335   3D                     DEC   a   
0336   28 01                  JR   z,arrayAccess1   
0338                ARRAYACCESS0:      
0338   29                     ADD   hl,hl   ; if data width = 2 then double
0339                ARRAYACCESS1:      
0339   19                     ADD   hl,de   ; add addr
033A   C3 99 03               JP   var1   
033D                STAR_:       
033D                MULTIPLY:      
033D   D1                     POP   de   ; get first value
033E   E1                     POP   hl   
033F   CD AB 07               CALL   mul   
0342   E5                     PUSH   hl   
0343   FD E9                  JP   (iy)   
0345                SEMI_:       
0345                RET:         
0345   CD EE 02               CALL   rpop   ; Restore Instruction pointer
0348   44 4D                  LD   bc,hl   
034A   FD E9                  JP   (iy)   
034C                             ; !                              21
034C                             ; value _oldValue --            ; uses address in vPointer 15
034C                BANG_:       
034C                ASSIGN:      
034C   D1                     POP   de   ; discard last accessed value
034D   D1                     POP   de   ; de = new value
034E                ASSIGN0:      
034E   2A 6E 0D               LD   hl,(vPointer)   ; hl = pointer
0351                ASSIGN1:      
0351   73                     LD   (hl),e   ; ignore byte mode to allow assigning to vByteMode
0352   23                     INC   hl   
0353   72                     LD   (hl),d   
0354   FD E9                  JP   (iy)   
0356                MINUS_:      
0356                MINUS:       
0356   03                     INC   bc   ; check if sign of a number
0357   0A                     LD   a,(bc)   
0358   0B                     DEC   bc   
0359   FE 30                  CP   "0"   
035B   38 05                  JR   c,sub   
035D   FE 3A                  CP   "9"+1   
035F   DA EA 05               JP   c,num   
0362                SUB:         ; Subtract the value 2nd on stack from top of stack
0362   D1                     POP   de   ; 
0363   03                     INC   bc   
0364   FE 2D                  CP   "-"   
0366   20 04                  JR   nz,sub1   
0368   1B                     DEC   de   
0369   C3 4E 03               JP   assign0   
036C                SUB1:        
036C   0B                     DEC   bc   
036D   E1                     POP   hl   ;      Entry point for INVert
036E                SUB2:        
036E   A7                     AND   A   ;      Entry point for NEGate
036F   ED 52                  SBC   hl,de   ; 15t
0371   E5                     PUSH   hl   ; 
0372   FD E9                  JP   (iy)   ; 
0374                             ; 5
0374                EQ_:         
0374   E1                     POP   hl   
0375   D1                     POP   de   
0376   A7                     AND   A   ; reset the carry flag
0377   ED 52                  SBC   hl,de   ; only equality sets hl=0 here
0379   28 16                  JR   Z,equal   
037B   21 00 00               LD   hl,0   
037E   18 12                  JR   less   ; hl = 1
0380                GT_:         
0380   D1                     POP   de   
0381   E1                     POP   hl   
0382   18 02                  JR   cmp_   
0384                LT_:         
0384   E1                     POP   hl   
0385   D1                     POP   de   
0386                CMP_:        
0386   A7                     AND   A   ; reset the carry flag
0387   ED 52                  SBC   hl,de   ; only equality sets hl=0 here
0389   28 07                  JR   Z,less   ; equality returns 0  KB 25/11/21
038B   21 00 00               LD   hl,0   
038E   FA 92 03               JP   M,less   
0391                EQUAL:       
0391   2C                     INC   L   ; hl = 1
0392                LESS:        
0392   E5                     PUSH   hl   
0393   FD E9                  JP   (iy)   
0395                VAR_:        
0395   0A                     LD   a,(bc)   
0396   CD 0D 07               CALL   lookupRef   
0399                VAR1:        
0399   16 00                  LD   d,0   
039B   5E                     LD   e,(hl)   
039C   3A 52 0D               LD   a,(vByteMode)   
039F   3D                     DEC   a   ; is it byte?
03A0   28 02                  JR   z,var2   
03A2   23                     INC   hl   
03A3   56                     LD   d,(hl)   
03A4                VAR2:        
03A4   D5                     PUSH   de   
03A5   FD E9                  JP   (iy)   
03A7                QUOTE_:      ;= 21
03A7   ED 5B 5E 0D            LD   de,(vHeapPtr)   ; hl = heap ptr
03AB   D5                     PUSH   de   ; save start of string
03AC   03                     INC   bc   ; point to next char
03AD   18 03                  JR   strDef2   
03AF                STRDEF1:      
03AF   12                     LD   (de),A   
03B0   13                     INC   de   ; increase count
03B1   03                     INC   bc   ; point to next char
03B2                STRDEF2:      
03B2   0A                     LD   A,(bc)   
03B3   FE 27                  CP   "'"   ; ` is the string terminator
03B5   20 F8                  JR   NZ,strDef1   
03B7   AF                     XOR   a   ; write null to terminate string
03B8   12                     LD   (de),A   
03B9   13                     INC   de   
03BA   C3 66 04               JP   def3   
03BD                GRAVE_:      
03BD                PRINTLITERAL:      ;=15
03BD   03                     INC   bc   
03BE                PRINTLITERAL1:      
03BE   0A                     LD   A,(bc)   
03BF   03                     INC   bc   
03C0   FE 60                  CP   "`"   ; ` is the string terminator
03C2   28 05                  JR   Z,printLiteral2   
03C4   CD 85 00               CALL   putchar   
03C7   18 F5                  JR   printLiteral1   
03C9                PRINTLITERAL2:      
03C9   0B                     DEC   bc   
03CA   FD E9                  JP   (IY)   
03CC                SLASH_:      
03CC                SLASH:       ;=34
03CC   D1                     POP   de   ; get first value
03CD   E1                     POP   hl   ; get 2nd value
03CE   CD C4 06               CALL   div   
03D1   D5                     PUSH   de   ; Push Result
03D2   22 72 0D               LD   (vRemain),hl   ; save remainder in \r
03D5   FD E9                  JP   (iy)   
03D7   C3 D5 05     CARET_:   JP   exec   
03DA   C3 8D 05     BACKSLASH_:   JP   alt   
03DD   C3 1A 06     DOLLAR_:   JP   dollar   
03E0   C3 37 06     DOT_:     JP   dot   
03E3   C3 EA 05     NUM_:     JP   num   
03E6   C3 B0 04     RPAREN_:   JP   rparen   
03E9   C3 E7 04     SHL_:     JP   shl   
03EC   C3 EC 04     SHR_:     JP   shr   
03EF   C3 4D 06     TILDE_:   JP   tilde   
03F2   18 4D        COLON_:   JR   colon   
03F4   18 76        LPAREN_:   JR   lparen   
03F6                             ; [
03F6                LBRACK_:      
03F6                ARRAYSTART:      
03F6   21 00 00               LD   hl,0   
03F9   39                     ADD   hl,sp   
03FA   CD E3 02               CALL   rpush   ; save data stack pointer
03FD   FD E9                  JP   (iy)   
03FF                RBRACK_:      
03FF                             ;*******************************************************************
03FF                             ; Page 4 primitive routines
03FF                             ;*******************************************************************
03FF                             ;falls through
03FF                             ; ]
03FF                RBRACK:      
03FF                ARRAYEND:      
03FF   ED 43 4A 0D            LD   (vTemp1),bc   ; save IP
0403   CD EE 02               CALL   rpop   
0406   54 5D                  LD   de,hl   ; de = hl = SP0
0408   B7                     OR   a   
0409   ED 72                  SBC   hl,sp   ; bc = count (items on stack)
040B   CB 3C                  SRL   h   
040D   CB 1D                  RR   l   
040F   44 4D                  LD   bc,hl   
0411   2A 5E 0D               LD   hl,(vHeapPtr)   ; hl = array[-2]
0414   71                     LD   (hl),c   ; write num items in length word
0415   23                     INC   hl   
0416   70                     LD   (hl),b   
0417   23                     INC   hl   
0418   EB                     EX   de,hl   ; hl = SP0, de = array[0], bc = count
0419   F9                     LD   sp,hl   ; sp = SP0
041A   18 11                  JR   arrayEnd3   
041C                ARRAYEND1:      
041C   2B                     DEC   hl   ; move to next word on stack
041D   2B                     DEC   hl   
041E   7E                     LD   a,(hl)   ; a = lsb of stack item
041F   12                     LD   (de),a   ; write lsb of array item
0420   13                     INC   de   ; move to byte in array
0421   3A 52 0D               LD   a,(vByteMode)   ; vByteMode = TRUE ?
0424   3D                     DEC   a   
0425   28 05                  JR   z,arrayEnd2   
0427   23                     INC   hl   ; move to previous byte on stack
0428   7E                     LD   a,(hl)   ; a = msb of stack item
0429   2B                     DEC   hl   
042A   12                     LD   (de),a   ; write msb of array item
042B   13                     INC   de   ; move to next byte in array
042C                ARRAYEND2:      
042C   0B                     DEC   bc   ; count--
042D                ARRAYEND3:      
042D   79                     LD   a,c   ; if not zero loop
042E   B0                     OR   b   
042F   20 EB                  JR   nz,arrayEnd1   
0431   2A 5E 0D               LD   hl,(vHeapPtr)   ; de = end of array, hl = array[-2]
0434   ED 53 5E 0D            LD   (vHeapPtr),de   ; move heap* to end of array
0438   23                     INC   hl   ; return array[0]
0439   23                     INC   hl   
043A   E5                     PUSH   hl   
043B   ED 4B 4A 0D            LD   bc,(vTemp1)   ; restore IP
043F   FD E9                  JP   (iy)   
0441                COLON:       ; Create a colon definition
0441                DEF:         
0441   03                     INC   bc   
0442   0A                     LD   a,(bc)   ; Get the next character
0443   FE 20                  CP   " "   ; if :: then anonymous def
0445   20 09                  JR   nz,def0   
0447   03                     INC   bc   
0448   ED 5B 5E 0D            LD   de,(vHeapPtr)   ; start of defintion
044C   D5                     PUSH   de   
044D   C3 5B 04               JP   def1   
0450                DEF0:        
0450   CD 0D 07               CALL   lookupRef   
0453   ED 5B 5E 0D            LD   de,(vHeapPtr)   ; start of defintion
0457   73                     LD   (hl),e   ; Save low byte of address in CFA
0458   23                     INC   hl   
0459   72                     LD   (hl),d   ; Save high byte of address in CFA+1
045A   03                     INC   bc   
045B                DEF1:        ; Skip to end of definition
045B   0A                     LD   a,(bc)   ; Get the next character
045C   03                     INC   bc   ; Point to next character
045D   12                     LD   (de),a   
045E   13                     INC   de   
045F   FE 3B                  CP   ";"   ; compare with delimiter
0461   28 02                  JR   Z,def2   ; end the definition
0463   18 F6                  JR   def1   ; get the next element
0465                DEF2:        
0465   0B                     DEC   bc   
0466                DEF3:        
0466   ED 53 5E 0D            LD   (vHeapPtr),de   ; bump heap ptr to after definiton
046A   FD E9                  JP   (iy)   
046C                LPAREN:      ; Left parentheses begins a loop
046C                BEGIN:       
046C   E1                     POP   hl   
046D   7D                     LD   a,l   ; zero?
046E   B4                     OR   H   
046F   28 27                  JR   Z,begin1   
0471   DD E5                  PUSH   IX   
0473   DD 2A 30 0D            LD   IX,(vLoopSP)   
0477   11 FA FF               LD   de,-6   
047A   DD 19                  ADD   IX,de   
047C   DD 36 00 00            LD   (IX+0),0   ; loop var
0480   DD 36 01 00            LD   (IX+1),0   
0484   DD 75 02               LD   (IX+2),L   ; loop limit
0487   DD 74 03               LD   (IX+3),H   
048A   DD 71 04               LD   (IX+4),C   ; loop address
048D   DD 70 05               LD   (IX+5),B   
0490   DD 22 30 0D            LD   (vLoopSP),IX   
0494   DD E1                  POP   IX   
0496   FD E9                  JP   (iy)   
0498                BEGIN1:      
0498   1E 01                  LD   E,1   
049A                BEGIN2:      
049A   03                     INC   bc   
049B   0A                     LD   A,(bc)   
049C   CD E1 06               CALL   nesting   
049F   AF                     XOR   a   
04A0   B3                     OR   e   
04A1   20 F7                  JR   NZ,begin2   
04A3   21 01 00               LD   hl,1   
04A6                BEGIN3:      
04A6   03                     INC   bc   
04A7   0A                     LD   A,(bc)   
04A8   0B                     DEC   bc   
04A9   FE 28                  CP   "("   
04AB   20 01                  JR   NZ,begin4   
04AD   E5                     PUSH   hl   
04AE                BEGIN4:      
04AE   FD E9                  JP   (iy)   
04B0                RPAREN:      ;=72
04B0                AGAIN:       
04B0   DD E5                  PUSH   IX   
04B2   DD 2A 30 0D            LD   IX,(vLoopSP)   
04B6   DD 5E 00               LD   E,(IX+0)   ; peek loop var
04B9   DD 56 01               LD   D,(IX+1)   
04BC   DD 6E 02               LD   L,(IX+2)   ; peek loop limit
04BF   DD 66 03               LD   H,(IX+3)   
04C2   2B                     DEC   hl   
04C3   B7                     OR   a   
04C4   ED 52                  SBC   hl,de   
04C6   28 0F                  JR   Z,again2   
04C8   13                     INC   de   
04C9   DD 73 00               LD   (IX+0),E   ; poke loop var
04CC   DD 72 01               LD   (IX+1),D   
04CF                AGAIN1:      
04CF   DD 4E 04               LD   C,(IX+4)   ; peek loop address
04D2   DD 46 05               LD   B,(IX+5)   
04D5   18 05                  JR   again4   
04D7                AGAIN2:      
04D7   11 06 00               LD   de,6   ; drop loop frame
04DA                AGAIN3:      
04DA   DD 19                  ADD   IX,de   
04DC                AGAIN4:      
04DC   DD 22 30 0D            LD   (vLoopSP),IX   
04E0   DD E1                  POP   IX   
04E2   21 00 00               LD   hl,0   ; skip ELSE clause
04E5   18 BF                  JR   begin3   
04E7                             ;  Left shift { is multiply by 2		
04E7                SHL:         
04E7   E1                     POP   HL   ; Duplicate the top member of the stack
04E8   29                     ADD   HL,HL   
04E9   E5                     PUSH   HL   ; shift left fallthrough into add_
04EA   FD E9                  JP   (IY)   ; 
04EC                             ;  Right shift } is a divide by 2		
04EC                SHR:         
04EC   E1                     POP   HL   ; Get the top member of the stack
04ED                SHR1:        
04ED   CB 3C                  SRL   H   
04EF   CB 1D                  RR   L   
04F1   E5                     PUSH   HL   
04F2   FD E9                  JP   (IY)   ; 
04F4                             ; **************************************************************************
04F4                             ; Page 5 Alt primitives
04F4                             ; **************************************************************************
04F4                          ALIGN   $100   
0500                PAGE5:       
0500                             ; array* -- num
0500                ARRAYLENGTH_:      
0500   E1                     POP   hl   
0501   2B                     DEC   hl   ; msb size
0502   56                     LD   d,(hl)   
0503   2B                     DEC   hl   ; lsb size
0504   5E                     LD   e,(hl)   
0505   D5                     PUSH   de   
0506   FD E9                  JP   (iy)   
0508                TOGBYTEMODE_:      
0508   21 52 0D               LD   hl,vByteMode   
050B   22 6E 0D               LD   (vPointer),hl   
050E   C3 4E 06               JP   toggle0   
0511                HEXADECIMAL_:      
0511   21 01 00               LD   hl,TRUE   
0514   18 03                  JR   decimal2   
0516                DECIMAL_:      
0516   21 00 00               LD   hl,FALSE   
0519                DECIMAL2:      
0519   22 7E 0D               LD   (vHexMode),hl   
051C   FD E9                  JP   (iy)   
051E                WHILE_:      
051E   E1                     POP   hl   
051F   7D                     LD   a,l   ; zero?
0520   B4                     OR   H   
0521   28 02                  JR   Z,while1   
0523   FD E9                  JP   (iy)   
0525                WHILE1:      
0525   11 06 00               LD   de,6   ; drop loop frame
0528   DD 19                  ADD   IX,de   
052A   C3 98 04               JP   begin1   ; skip to end of loop
052D                COMMENT_:      
052D   03                     INC   bc   ; point to next char
052E   0A                     LD   A,(bc)   
052F   FE 0D                  CP   "\r"   ; terminate at cr
0531   20 FA                  JR   NZ,comment_   
0533   0B                     DEC   bc   
0534                ANOP_:       
0534   FD E9                  JP   (IY)   
0536                PRNCHAR_:      
0536   E1                     POP   hl   
0537   7D                     LD   a,l   
0538   CD 85 00               CALL   putchar   
053B   FD E9                  JP   (iy)   
053D                GO_:         
053D   CD 42 05               CALL   go1   
0540   FD E9                  JP   (iy)   
0542                GO1:         
0542   E1                     POP   hl   
0543   E3                     EX   (SP),hl   
0544   E9                     JP   (hl)   
0545                PROMPT_:      
0545   CD 5E 06               CALL   prompt   
0548   FD E9                  JP   (iy)   
054A                INPORT_:      ; \<
054A   E1                     POP   hl   
054B   79                     LD   A,C   
054C   4D                     LD   C,L   
054D   ED 68                  IN   L,(C)   
054F   26 00                  LD   H,0   
0551   4F                     LD   C,A   
0552   E5                     PUSH   hl   
0553   FD E9                  JP   (iy)   
0555                KEY_:        
0555   CD 81 00               CALL   getchar   
0558   26 00                  LD   H,0   
055A   6F                     LD   l,a   
055B   E5                     PUSH   hl   
055C   FD E9                  JP   (iy)   
055E                NEWLN_:      
055E   CD 71 06               CALL   crlf   
0561   FD E9                  JP   (iy)   
0563                OUTPORT_:      
0563   E1                     POP   hl   
0564   59                     LD   E,C   
0565   4D                     LD   C,L   
0566   E1                     POP   hl   
0567   ED 69                  OUT   (C),L   
0569   4B                     LD   C,E   
056A   FD E9                  JP   (iy)   
056C                PRNSTR_:      
056C                PRNSTR:      
056C   E1                     POP   hl   
056D   CD 6B 06               CALL   putStr   
0570   FD E9                  JP   (iy)   
0572                             ; quit function (early return)
0572                             ; --
0572                QUIT_:       
0572   E1                     POP   hl   
0573   7D                     LD   a,l   
0574   B4                     OR   H   
0575   C2 45 03               JP   NZ,semi_   
0578   FD E9                  JP   (iy)   
057A                XOR_:        
057A   D1                     POP   de   ; Bitwise xor the top 2 elements of the stack
057B                XOR1:        
057B   E1                     POP   hl   
057C   7B                     LD   a,e   
057D   AD                     XOR   L   
057E   6F                     LD   l,a   
057F   7A                     LD   A,D   
0580   AC                     XOR   H   
0581   C3 09 03               JP   and1   
0584                             ; **************************************************************************
0584                             ; Page 6 primitive routines continued  (page 7)
0584                             ; **************************************************************************
0584                             ; falls through to following page
0584                             ;*******************************************************************
0584                             ; primitive routines continued
0584                             ;*******************************************************************
0584                DOTNEXT:      
0584   3A 74 0D               LD   a,(vStrMode)   ; if string mode then exit
0587   3C                     INC   a   
0588   C4 9A 07               CALL   nz,flush   
058B   FD E9                  JP   (iy)   
058D                ALT:         ;=11
058D   03                     INC   bc   
058E   0A                     LD   A,(bc)   
058F   FE 5C                  CP   $5C   ; \ second backslash
0591   CA 2D 05               JP   z,comment_   
0594   FE 7B                  CP   "z"+1   ; if a > z then exit
0596   30 17                  JR   nc,alt1   
0598   FE 61                  CP   "a"   
059A   30 15                  JR   nc,altVar   
059C   FE 5B                  CP   "Z"+1   ; if > Z then exit
059E   30 0F                  JR   nc,alt1   
05A0   D6 41                  SUB   "A"   ; a - 65
05A2   38 0B                  JR   c,alt1   ; if < A then exit
05A4   21 5E 0C               LD   hl,altCodes   
05A7   85                     ADD   a,l   
05A8   6F                     LD   l,a   
05A9   7E                     LD   A,(hl)   ;       get low jump address
05AA   21 00 05               LD   hl,page5   
05AD   6F                     LD   l,a   
05AE   E9                     JP   (hl)   ;       Jump to routine
05AF                ALT1:        
05AF   DD E9                  JP   (ix)   
05B1                             ; \i and \j are hardwired to loop iterator vars
05B1                ALTVAR:      
05B1   2A 30 0D               LD   hl,(vLoopSP)   
05B4   FE 69                  CP   "i"   
05B6   20 03                  JR   nz,altVar1   
05B8   C3 CF 05               JP   altVar3   
05BB                ALTVAR1:      
05BB   FE 6A                  CP   "j"   
05BD   20 07                  JR   nz,altVar2   
05BF   11 06 00               LD   de,6   
05C2   19                     ADD   hl,de   
05C3   C3 CF 05               JP   altVar3   
05C6                ALTVAR2:      
05C6   0A                     LD   A,(bc)   
05C7   D6 61                  SUB   "a"   
05C9   87                     ADD   a,a   
05CA   21 50 0D               LD   hl,altVars   
05CD   85                     ADD   a,l   
05CE   6F                     LD   l,a   
05CF                ALTVAR3:      
05CF   22 6E 0D               LD   (vPointer),hl   
05D2   C3 99 03               JP   var1   
05D5                EXEC:        
05D5   D1                     POP   de   
05D6                EXEC1:       
05D6   7A                     LD   A,D   ; skip if destination address is null
05D7   B3                     OR   e   
05D8   28 0E                  JR   Z,exec3   
05DA   60 69                  LD   hl,bc   
05DC   03                     INC   bc   ; read next char from source
05DD   0A                     LD   A,(bc)   ; if ; to tail call optimise
05DE   FE 3B                  CP   ";"   ; by jumping to rather than calling destination
05E0   28 03                  JR   Z,exec2   
05E2   CD E3 02               CALL   rpush   ; save Instruction Pointer
05E5                EXEC2:       
05E5   42 4B                  LD   bc,de   
05E7   0B                     DEC   bc   
05E8                EXEC3:       
05E8   FD E9                  JP   (iy)   
05EA                             ; 0..9 number                   37
05EA                NUM:         
05EA   21 00 00               LD   hl,$0000   ; Clear hl to accept the number
05ED   0A                     LD   a,(bc)   ; Get numeral or -
05EE   FE 2D                  CP   "-"   
05F0   20 01                  JR   nz,num0   
05F2   03                     INC   bc   ; move to next char, no flags affected
05F3                NUM0:        
05F3   08                     EX   af,af'   ; save zero flag = 0 for later
05F4                NUM1:        
05F4   0A                     LD   a,(bc)   ; read digit
05F5   D6 30                  SUB   "0"   ; less than 0?
05F7   38 13                  JR   c,num2   ; not a digit, exit loop
05F9   FE 0A                  CP   10   ; greater that 9?
05FB   30 0F                  JR   nc,num2   ; not a digit, exit loop
05FD   03                     INC   bc   ; inc IP
05FE   54 5D                  LD   de,hl   ; multiply hl * 10
0600   29                     ADD   hl,hl   
0601   29                     ADD   hl,hl   
0602   19                     ADD   hl,de   
0603   29                     ADD   hl,hl   
0604   85                     ADD   a,l   ; add digit in a to hl
0605   6F                     LD   l,a   
0606   3E 00                  LD   a,0   
0608   8C                     ADC   a,h   
0609   67                     LD   h,a   
060A   18 E8                  JR   num1   
060C                NUM2:        
060C   0B                     DEC   bc   
060D   08                     EX   af,af'   ; restore zero flag
060E   20 07                  JR   nz,num3   
0610   EB                     EX   de,hl   ; negate the value of hl
0611   21 00 00               LD   hl,0   
0614   B7                     OR   a   ; jump to sub2
0615   ED 52                  SBC   hl,de   
0617                NUM3:        
0617   E5                     PUSH   hl   ; Put the number on the stack
0618   FD E9                  JP   (iy)   ; and process the next character
061A                DOLLAR:      
061A                HEXNUM:      
061A   21 00 00               LD   hl,0   ; Clear hl to accept the number
061D                HEXNUM1:      
061D   03                     INC   bc   
061E   0A                     LD   a,(bc)   ; Get the character which is a numeral
061F   CB 77                  BIT   6,a   ; is it uppercase alpha?
0621   28 02                  JR   z,hexnum2   ; no a decimal
0623   D6 07                  SUB   7   ; sub 7  to make $a - $F
0625                HEXNUM2:      
0625   D6 30                  SUB   $30   ; form decimal digit
0627   DA 0C 06               JP   c,num2   
062A   FE 10                  CP   $0F+1   
062C   D2 0C 06               JP   nc,num2   
062F   29                     ADD   hl,hl   ; 2X ; Multiply digit(s) in hl by 16
0630   29                     ADD   hl,hl   ; 4X
0631   29                     ADD   hl,hl   ; 8X
0632   29                     ADD   hl,hl   ; 16X
0633   85                     ADD   a,l   ; add into bottom of hl
0634   6F                     LD   l,a   
0635   18 E6                  JR   hexnum1   
0637                             ; . print decimal
0637                             ; value --
0637                DOT:         
0637                PRINTNUMBER:      
0637   3A 7E 0D               LD   a,(vHexMode)   
063A   3D                     DEC   a   
063B   CA 46 06               JP   z,printHex   ; else falls through
063E   D9                     EXX      
063F   E1                     POP   hl   ; hl = value
0640   CD 6B 07               CALL   putDec   
0643   C3 84 05               JP   dotNext   
0646                PRINTHEX:      
0646   E1                     POP   hl   ; hl = value
0647   CD 38 07               CALL   putHex   
064A   C3 84 05               JP   dotNext   
064D                             ; ~ toggle
064D                             ; --
064D                TILDE:       
064D                TOGGLE:      
064D   D1                     POP   de   ; de = value
064E                TOGGLE0:      
064E   7B                     LD   a,e   
064F   B2                     OR   d   
0650   28 03                  JR   z,toggle1   
0652   11 FF FF               LD   de,-1   
0655                TOGGLE1:      
0655   13                     INC   de   
0656   2A 6E 0D               LD   hl,(vPointer)   
0659   73                     LD   (hl),e   
065A   23                     INC   hl   
065B   72                     LD   (hl),d   
065C                TOGGLE2:      
065C   FD E9                  JP   (iy)   
065E                             ;*******************************************************************
065E                             ; Subroutines
065E                             ;*******************************************************************
065E                PROMPT:      ;=9
065E   CD DC 02               CALL   printStr   
0661   0D 0A 3E 20 00         .CSTR   "\r\n> "   
0666   C9                     RET      
0667                PUTSTR0:      
0667   CD 85 00               CALL   putchar   
066A   23                     INC   hl   
066B                PUTSTR:      
066B   7E                     LD   A,(hl)   
066C   FE 08                  CP   "\b"   ; if < 8 terminate
066E   30 F7                  JR   nc,putStr0   
0670   C9                     RET      
0671                CRLF:        ;=7
0671   CD DC 02               CALL   printStr   
0674   0D 0A 00               .CSTR   "\r\n"   
0677   C9                     RET      
0678                             ; hl = value
0678                             ; de = buffer*
0678                             ; a, bc, de, hl destroyed
0678                FORMATDEC0:      
0678   E5                     PUSH   hl   
0679   D9                     EXX      
067A   E1                     POP   hl   
067B                             ; hl = value
067B                             ; de' = buffer*
067B                             ; a, bc, de, hl destroyed
067B                FORMATDEC:      
067B   CB 7C                  BIT   7,h   
067D   28 0C                  JR   z,formatDec2   
067F   D9                     EXX      
0680   3E 2D                  LD   a,"-"   
0682   12                     LD   (de),a   
0683   13                     INC   de   
0684   D9                     EXX      
0685   AF                     XOR   a   
0686   95                     SUB   l   
0687   6F                     LD   l,a   
0688   9F                     SBC   a,a   
0689   94                     SUB   h   
068A   67                     LD   h,a   
068B                FORMATDEC2:      
068B   0E 00                  LD   c,0   ; leading zeros flag = false
068D   11 F0 D8               LD   de,-10000   
0690   CD AB 06               CALL   formatDec4   
0693   11 18 FC               LD   de,-1000   
0696   CD AB 06               CALL   formatDec4   
0699   11 9C FF               LD   de,-100   
069C   CD AB 06               CALL   formatDec4   
069F   1E F6                  LD   e,-10   
06A1   CD AB 06               CALL   formatDec4   
06A4   0C                     INC   c   ; flag = true for at least digit
06A5   1E FF                  LD   e,-1   
06A7   CD AB 06               CALL   formatDec4   
06AA   C9                     RET      
06AB                FORMATDEC4:      
06AB   06 2F                  LD   b,"0"-1   
06AD                FORMATDEC5:      
06AD   04                     INC   b   
06AE   19                     ADD   hl,de   
06AF   38 FC                  JR   c,formatDec5   
06B1   ED 52                  SBC   hl,de   
06B3   3E 30                  LD   a,"0"   
06B5   B8                     CP   b   
06B6   20 05                  JR   nz,formatDec6   
06B8   AF                     XOR   a   
06B9   B1                     OR   c   
06BA   C8                     RET   z   
06BB   18 01                  JR   formatDec7   
06BD                FORMATDEC6:      
06BD   0C                     INC   c   
06BE                FORMATDEC7:      
06BE   78                     LD   a,b   
06BF   D9                     EXX      
06C0   12                     LD   (de),a   
06C1   13                     INC   de   
06C2   D9                     EXX      
06C3   C9                     RET      
06C4                             ; de = first value hl = 2nd value
06C4                             ; return de = result hl = remainder
06C4                DIV:         
06C4   C5                     PUSH   bc   ; Preserve the IP
06C5   44                     LD   B,H   ; bc = 2nd value
06C6   4D                     LD   C,L   
06C7                             ; 
06C7   21 00 00               LD   hl,0   ; Zero the remainder
06CA   3E 10                  LD   A,16   ; Loop counter
06CC                DIV1:        ; shift the bits from bc (numerator) into hl (accumulator)
06CC   CB 21                  SLA   C   
06CE   CB 10                  RL   B   
06D0   ED 6A                  ADC   hl,hl   
06D2   ED 52                  SBC   hl,de   ; Check if remainder >= denominator (hl>=de)
06D4   38 03                  JR   C,div2   
06D6   0C                     INC   C   
06D7   18 01                  JR   div3   
06D9                DIV2:        ; remainder is not >= denominator, so we have to add de back to hl
06D9   19                     ADD   hl,de   
06DA                DIV3:        
06DA   3D                     DEC   A   
06DB   20 EF                  JR   NZ,div1   
06DD   50                     LD   D,B   ; Result from bc to de
06DE   59                     LD   E,C   
06DF                DIV4:        
06DF   C1                     POP   bc   ; Restore the IP
06E0   C9                     RET      
06E1                             ; calculate nesting value
06E1                             ; A is char to be tested,
06E1                             ; E is the nesting value (initially 0)
06E1                             ; E is increased by ( and [
06E1                             ; E is decreased by ) and ]
06E1                             ; E has its bit 7 toggled by `
06E1                             ; limited to 127 levels
06E1                NESTING:      ;=44
06E1   FE 60                  CP   "`"   
06E3   20 0A                  JR   NZ,nesting1   
06E5   CB 7B                  BIT   7,E   
06E7   28 03                  JR   Z,nesting1a   
06E9   CB BB                  RES   7,E   
06EB   C9                     RET      
06EC                NESTING1A:      
06EC   CB FB                  SET   7,E   
06EE   C9                     RET      
06EF                NESTING1:      
06EF   CB 7B                  BIT   7,E   
06F1   C0                     RET   NZ   
06F2   FE 3A                  CP   ":"   
06F4   28 08                  JR   Z,nesting2   
06F6   FE 5B                  CP   "["   
06F8   28 04                  JR   Z,nesting2   
06FA   FE 28                  CP   "("   
06FC   20 02                  JR   NZ,nesting3   
06FE                NESTING2:      
06FE   1C                     INC   E   
06FF   C9                     RET      
0700                NESTING3:      
0700   FE 3B                  CP   ";"   
0702   28 07                  JR   Z,nesting4   
0704   FE 5D                  CP   "]"   
0706   28 03                  JR   Z,nesting4   
0708   FE 29                  CP   ")"   
070A   C0                     RET   NZ   
070B                NESTING4:      
070B   1D                     DEC   E   
070C   C9                     RET      
070D                             ; a = name of variableA..Z,a..z
070D                             ; returns: hl = address of variable
070D                             ; clears carry flag if invalid name
070D                LOOKUPREF:      
070D   1E 00                  LD   e,0   ; offset 0
070F                LOOKUPREF0:      
070F   FE 7B                  CP   "z"+1   ; if a > z then exit
0711   D2 94 07               JP   nc,error1   
0714   FE 61                  CP   "a"   
0716   38 06                  JR   c,lookupRef1   
0718   D6 61                  SUB   "a"   
071A   1E 34                  LD   e,26*2   ; offset = 26 words
071C   18 0A                  JR   lookupRef3   
071E                LOOKUPREF1:      
071E   FE 5B                  CP   "Z"+1   ; if > Z then exit
0720   D2 94 07               JP   nc,error1   
0723   D6 41                  SUB   "A"   
0725   DA 94 07               JP   c,error1   
0728                LOOKUPREF3:      
0728   87                     ADD   a,a   ; a *= 2
0729   83                     ADD   a,e   ; a += offset
072A   21 84 0D               LD   hl,variables   ; hl = variables
072D   85                     ADD   a,l   ; hl += a
072E   6F                     LD   l,a   
072F   3E 00                  LD   a,0   
0731   8C                     ADC   a,h   
0732   67                     LD   h,a   
0733   22 6E 0D               LD   (vPointer),hl   ; store address in pointer
0736   37                     SCF      
0737   C9                     RET      
0738                             ; hl = number
0738                PUTHEX:      
0738   ED 5B 50 0D            LD   de,(vBufPtr)   
073C   3E 24                  LD   a,"$"   
073E   12                     LD   (de),a   
073F   13                     INC   de   ; string*++,
0740                PUTHEX1:      
0740   3A 52 0D               LD   a,(vByteMode)   
0743   3D                     DEC   a   
0744   28 04                  JR   z,putHex2   
0746   7C                     LD   a,h   
0747   CD 57 07               CALL   putHex3   
074A                PUTHEX2:      
074A   7D                     LD   a,l   
074B   CD 57 07               CALL   putHex3   
074E   3E 20                  LD   a," "   ; append space to buffer
0750   12                     LD   (de),a   
0751   13                     INC   de   ; string*++,
0752   ED 53 50 0D            LD   (vBufPtr),de   
0756   C9                     RET      
0757                PUTHEX3:      
0757   F5                     PUSH   af   
0758   1F                     RRA      
0759   1F                     RRA      
075A   1F                     RRA      
075B   1F                     RRA      
075C   CD 60 07               CALL   putHex4   
075F   F1                     POP   af   
0760                PUTHEX4:      
0760   E6 0F                  AND   0x0F   
0762   C6 90                  ADD   a,0x90   
0764   27                     DAA      
0765   CE 40                  ADC   a,0x40   
0767   27                     DAA      
0768   12                     LD   (de),a   
0769   13                     INC   de   ; string*++,
076A   C9                     RET      
076B                             ; hl = number
076B                PUTDEC:      
076B   D9                     EXX      
076C   ED 5B 50 0D            LD   de,(vBufPtr)   ; de"= buffer* bc" = IP
0770   D9                     EXX      
0771   3A 52 0D               LD   a,(vByteMode)   
0774   3D                     DEC   a   
0775   20 02                  JR   nz,printDec1   
0777   26 00                  LD   h,0   
0779                PRINTDEC1:      
0779   CD 7B 06               CALL   formatDec   
077C   D9                     EXX      ; de = buffer*' bc = IP
077D   3E 20                  LD   a," "   ; append space to buffer
077F   12                     LD   (de),a   
0780   13                     INC   de   ; string*++,
0781   ED 53 50 0D            LD   (vBufPtr),de   ; update buffer* with buffer*'
0785   C9                     RET      
0786                             ; hl = error code
0786                ERROR:       
0786   E5                     PUSH   hl   
0787   CD D3 02               CALL   enter   
078A   60 45 72 72 60 2E 00   DB   "`Err`.",0   
0791   C3 DC 01               JP   interpret   
0794                ERROR1:      
0794   21 01 00               LD   hl,1   
0797   C3 86 07               JP   error   
079A                FLUSH:       
079A   11 00 09               LD   de,BUFFER   
079D   2A 50 0D               LD   hl,(vBufPtr)   
07A0   36 00                  LD   (hl),0   ; store NUL at end of string
07A2   ED 53 50 0D            LD   (vBufPtr),de   ; reset vBufPtr to vHeapPtr
07A6   EB                     EX   de,hl   ; hl = BUFFER
07A7   CD 6B 06               CALL   putStr   
07AA   C9                     RET      
07AB                             ; de = first value
07AB                             ; hl = second value
07AB                             ; returns hl = value
07AB                MUL:         ;=24
07AB   C5                     PUSH   bc   ; Preserve the IP
07AC   44                     LD   B,H   ; bc = 2nd value
07AD   4D                     LD   C,L   
07AE   21 00 00               LD   hl,0   
07B1   3E 10                  LD   A,16   
07B3                MUL2:        
07B3   29                     ADD   hl,hl   
07B4   CB 13                  RL   E   
07B6   CB 12                  RL   D   
07B8   30 04                  JR   NC,$+6   
07BA   09                     ADD   hl,bc   
07BB   30 01                  JR   NC,$+3   
07BD   13                     INC   de   
07BE   3D                     DEC   A   
07BF   20 F2                  JR   NZ,mul2   
07C1   C1                     POP   bc   ; Restore the IP
07C2   C9                     RET      
0800                          .ORG   RAMSTART   
0800                TIBSIZE:   EQU   $100   ; 256 bytes , along line!
0800                BUFSIZE:   EQU   $100   
0800                DSIZE:    EQU   $80   
0800                RSIZE:    EQU   $80   
0800                LSIZE:    EQU   $80   
0800                VARS_SIZE:   EQU   26*2*2   ; A..Z, a..z words
0800                TIB:      DS   TIBSIZE   ; one page
0900                BUFFER:   DS   BUFSIZE   ; one page, lsb of vBufPtr is length and wraps around
0A00                          DS   RSIZE   
0A80                RSTACK:      
0A80                          DS   DSIZE   
0B00                DSTACK:      
0B00                STACK:       
0B00                          DS   LSIZE   
0B80                LSTACK:      
0B80                          ALIGN   $100   
0C00                OPCODES:      
0C00                          DS   $80 - $22   
0C5E                ALTCODES:      
0C5E                          DS   26 * 2   
0C92                          ALIGN   $100   
0D00                MONDOVARS:      
0D00                          DS   $30   
0D30                VLOOPSP:   DS   2   ; 
0D32                TBPTR:    DS   2   ; reserved for tests
0D34                RST08:    DS   2   
0D36                RST10:    DS   2   
0D38                RST18:    DS   2   
0D3A                RST20:    DS   2   
0D3C                RST28:    DS   2   
0D3E                RST30:    DS   2   
0D40                BAUD:     DS   2   
0D42                INTVEC:   DS   2   
0D44                NMIVEC:   DS   2   
0D46                GETCVEC:   DS   2   
0D48                PUTCVEC:   DS   2   
0D4A                VTEMP1:   DS   2   
0D4C                VTEMP2:   DS   2   
0D4E                VTEMP3:   DS   2   
0D50                ALTVARS:      
0D50                VBUFPTR:   DS   2   ; a buffer pointer
0D52                VBYTEMODE:   DS   2   ; b byte mode
0D54                VCARRY:   DS   2   ; c carry
0D56                          DS   2   ; d
0D58                VECHOMODE:   DS   2   ; e echo mode
0D5A                          DS   2   ; f
0D5C                          DS   2   ; g
0D5E                VHEAPPTR:   DS   2   ; h heap ptr
0D60                VI:       DS   2   ; i virtual var
0D62                VJ:       DS   2   ; j virtual var
0D64                          DS   2   ; k
0D66                          DS   2   ; l
0D68                          DS   2   ; m
0D6A                          DS   2   ; n
0D6C                          DS   2   ; o
0D6E                VPOINTER:   DS   2   ; p pointer
0D70                          DS   2   ; q
0D72                VREMAIN:   DS   2   ; r
0D74                VSTRMODE:   DS   2   ; s
0D76                VTIBPTR:   DS   2   ; t
0D78                          DS   2   ; u
0D7A                          DS   2   ; v
0D7C                          DS   2   ; w
0D7E                VHEXMODE:   DS   2   ; x
0D80                          DS   2   ; y
0D82                          DS   2   ; z
0D84                VARIABLES:      
0D84                          DS   VARS_SIZE   
0DEC                HEAP:        


TEC_1:              0001 DEFINED AT LINE 1 IN constants.asm
RC2014:             0000 DEFINED AT LINE 2 IN constants.asm
EXTENDED:           0000 DEFINED AT LINE 4 IN constants.asm
LOADER:             0000 DEFINED AT LINE 9 IN constants.asm
BITBANG:            0000 DEFINED AT LINE 10 IN constants.asm
ROMSTART:           0000 DEFINED AT LINE 12 IN constants.asm
                    > USED AT LINE 100 IN IOSerial.asm
                    > USED AT LINE 105 IN IOSerial.asm
                    > USED AT LINE 111 IN IOSerial.asm
                    > USED AT LINE 117 IN IOSerial.asm
                    > USED AT LINE 123 IN IOSerial.asm
                    > USED AT LINE 129 IN IOSerial.asm
                    > USED AT LINE 135 IN IOSerial.asm
                    > USED AT LINE 141 IN IOSerial.asm
                    > USED AT LINE 147 IN IOSerial.asm
                    > USED AT LINE 189 IN IOSerial.asm
                    > USED AT LINE 37 IN MONDO.asm
RAMSTART:           0800 DEFINED AT LINE 13 IN constants.asm
                    > USED AT LINE 1 IN ram.asm
CONTROL:            0080 DEFINED AT LINE 22 IN IOSerial.asm
                    > USED AT LINE 465 IN IOSerial.asm
                    > USED AT LINE 487 IN IOSerial.asm
STATUS:             0080 DEFINED AT LINE 23 IN IOSerial.asm
                    > USED AT LINE 298 IN IOSerial.asm
                    > USED AT LINE 311 IN IOSerial.asm
TDR:                0081 DEFINED AT LINE 24 IN IOSerial.asm
                    > USED AT LINE 303 IN IOSerial.asm
RDR:                0081 DEFINED AT LINE 25 IN IOSerial.asm
                    > USED AT LINE 315 IN IOSerial.asm
MRESET:             0003 DEFINED AT LINE 32 IN IOSerial.asm
                    > USED AT LINE 464 IN IOSerial.asm
DIV_64:             0002 DEFINED AT LINE 35 IN IOSerial.asm
                    > USED AT LINE 486 IN IOSerial.asm
F7E2:               0000 DEFINED AT LINE 39 IN IOSerial.asm
F7O2:               0004 DEFINED AT LINE 40 IN IOSerial.asm
F7E1:               0008 DEFINED AT LINE 41 IN IOSerial.asm
F7O1:               000C DEFINED AT LINE 42 IN IOSerial.asm
F8N2:               0010 DEFINED AT LINE 43 IN IOSerial.asm
                    > USED AT LINE 486 IN IOSerial.asm
F8N1:               0014 DEFINED AT LINE 44 IN IOSerial.asm
F8E1:               0018 DEFINED AT LINE 45 IN IOSerial.asm
F8O1:               001C DEFINED AT LINE 46 IN IOSerial.asm
RTSLID:             0000 DEFINED AT LINE 50 IN IOSerial.asm
                    > USED AT LINE 486 IN IOSerial.asm
RTSLIE:             0020 DEFINED AT LINE 51 IN IOSerial.asm
RTSHID:             0040 DEFINED AT LINE 52 IN IOSerial.asm
RTSLIDB:            0060 DEFINED AT LINE 53 IN IOSerial.asm
RIE:                0080 DEFINED AT LINE 57 IN IOSerial.asm
RDRF:               0000 DEFINED AT LINE 61 IN IOSerial.asm
TDRE:               0001 DEFINED AT LINE 62 IN IOSerial.asm
DCD:                0002 DEFINED AT LINE 63 IN IOSerial.asm
CTS:                0003 DEFINED AT LINE 64 IN IOSerial.asm
FE:                 0004 DEFINED AT LINE 65 IN IOSerial.asm
OVRN:               0005 DEFINED AT LINE 66 IN IOSerial.asm
PE:                 0006 DEFINED AT LINE 67 IN IOSerial.asm
IRQ:                0007 DEFINED AT LINE 68 IN IOSerial.asm
KEYBUF:             0000 DEFINED AT LINE 76 IN IOSerial.asm
SCAN:               0001 DEFINED AT LINE 77 IN IOSerial.asm
DISPLY:             0002 DEFINED AT LINE 78 IN IOSerial.asm
PORT3:              0003 DEFINED AT LINE 79 IN IOSerial.asm
PORT4:              0004 DEFINED AT LINE 80 IN IOSerial.asm
PORT5:              0005 DEFINED AT LINE 81 IN IOSerial.asm
PORT6:              0006 DEFINED AT LINE 82 IN IOSerial.asm
PORT7:              0007 DEFINED AT LINE 83 IN IOSerial.asm
ESC:                001B DEFINED AT LINE 96 IN IOSerial.asm
CR:                 000D DEFINED AT LINE 97 IN IOSerial.asm
LF:                 000A DEFINED AT LINE 98 IN IOSerial.asm
RSTVEC:             0000 DEFINED AT LINE 102 IN IOSerial.asm
SEVENSEGMENT:       0040 DEFINED AT LINE 152 IN IOSerial.asm
PWRUP:              0050 DEFINED AT LINE 174 IN IOSerial.asm
                    > USED AT LINE 470 IN IOSerial.asm
BITIME:             0053 DEFINED AT LINE 176 IN IOSerial.asm
BITIM1:             0058 DEFINED AT LINE 180 IN IOSerial.asm
                    > USED AT LINE 182 IN IOSerial.asm
INTRET:             005F DEFINED AT LINE 185 IN IOSerial.asm
                    > USED AT LINE 446 IN IOSerial.asm
TXDATA:             006B DEFINED AT LINE 293 IN IOSerial.asm
                    > USED AT LINE 458 IN IOSerial.asm
TXCHAR:             006B DEFINED AT LINE 294 IN IOSerial.asm
TXCHAR1:            006D DEFINED AT LINE 297 IN IOSerial.asm
                    > USED AT LINE 301 IN IOSerial.asm
RXDATA:             0078 DEFINED AT LINE 309 IN IOSerial.asm
                    > USED AT LINE 456 IN IOSerial.asm
RXCHAR:             0078 DEFINED AT LINE 310 IN IOSerial.asm
                    > USED AT LINE 314 IN IOSerial.asm
GETCHAR:            0081 DEFINED AT LINE 434 IN IOSerial.asm
                    > USED AT LINE 155 IN MONDO.asm
                    > USED AT LINE 800 IN MONDO.asm
PUTCHAR:            0085 DEFINED AT LINE 438 IN IOSerial.asm
                    > USED AT LINE 178 IN MONDO.asm
                    > USED AT LINE 317 IN MONDO.asm
                    > USED AT LINE 516 IN MONDO.asm
                    > USED AT LINE 774 IN MONDO.asm
                    > USED AT LINE 1032 IN MONDO.asm
RESET:              008B DEFINED AT LINE 444 IN IOSerial.asm
                    > USED AT LINE 103 IN IOSerial.asm
TRUE:               0001 DEFINED AT LINE 14 IN MONDO.asm
                    > USED AT LINE 743 IN MONDO.asm
FALSE:              0000 DEFINED AT LINE 15 IN MONDO.asm
                    > USED AT LINE 746 IN MONDO.asm
NULL:               0000 DEFINED AT LINE 16 IN MONDO.asm
                    > USED AT LINE 158 IN MONDO.asm
ETX:                0003 DEFINED AT LINE 17 IN MONDO.asm
                    > USED AT LINE 195 IN MONDO.asm
                    > USED AT LINE 209 IN MONDO.asm
IOPCODES:           0180 DEFINED AT LINE 39 IN MONDO.asm
                    > USED AT LINE 258 IN MONDO.asm
IALTCODES:          01AA DEFINED AT LINE 86 IN MONDO.asm
START:              01C6 DEFINED AT LINE 118 IN MONDO.asm
                    > USED AT LINE 6
INTERPRET:          01DC DEFINED AT LINE 124 IN MONDO.asm
                    > USED AT LINE 228 IN MONDO.asm
                    > USED AT LINE 1271 IN MONDO.asm
INTERPRET2:         01E6 DEFINED AT LINE 130 IN MONDO.asm
                    > USED AT LINE 164 IN MONDO.asm
                    > USED AT LINE 167 IN MONDO.asm
                    > USED AT LINE 171 IN MONDO.asm
INTERPRET3:         01EE DEFINED AT LINE 137 IN MONDO.asm
                    > USED AT LINE 146 IN MONDO.asm
INTERPRET4:         01F4 DEFINED AT LINE 143 IN MONDO.asm
                    > USED AT LINE 135 IN MONDO.asm
WAITCHAR:           01F9 DEFINED AT LINE 154 IN MONDO.asm
                    > USED AT LINE 180 IN MONDO.asm
                    > USED AT LINE 194 IN MONDO.asm
WAITCHAR1:          0220 DEFINED AT LINE 173 IN MONDO.asm
                    > USED AT LINE 157 IN MONDO.asm
WAITCHAR3:          022E DEFINED AT LINE 182 IN MONDO.asm
                    > USED AT LINE 161 IN MONDO.asm
WAITCHAR4:          0244 DEFINED AT LINE 198 IN MONDO.asm
                    > USED AT LINE 159 IN MONDO.asm
NEXT:               024C DEFINED AT LINE 203 IN MONDO.asm
                    > USED AT LINE 213 IN MONDO.asm
                    > USED AT LINE 234 IN MONDO.asm
NEXT1:              0268 DEFINED AT LINE 219 IN MONDO.asm
                    > USED AT LINE 208 IN MONDO.asm
                    > USED AT LINE 211 IN MONDO.asm
ENDTXT:             0269 DEFINED AT LINE 222 IN MONDO.asm
                    > USED AT LINE 210 IN MONDO.asm
ENDTXT1:            0272 DEFINED AT LINE 227 IN MONDO.asm
                    > USED AT LINE 225 IN MONDO.asm
INIT:               0275 DEFINED AT LINE 230 IN MONDO.asm
                    > USED AT LINE 120 IN MONDO.asm
INITOPS:            02AF DEFINED AT LINE 257 IN MONDO.asm
INITOPS1:           02B8 DEFINED AT LINE 262 IN MONDO.asm
                    > USED AT LINE 272 IN MONDO.asm
                    > USED AT LINE 283 IN MONDO.asm
INITOPS2:           02C8 DEFINED AT LINE 274 IN MONDO.asm
                    > USED AT LINE 267 IN MONDO.asm
INITOPS2A:          02CD DEFINED AT LINE 279 IN MONDO.asm
                    > USED AT LINE 282 IN MONDO.asm
ENTER:              02D3 DEFINED AT LINE 285 IN MONDO.asm
                    > USED AT LINE 1269 IN MONDO.asm
PRINTSTR:           02DC DEFINED AT LINE 292 IN MONDO.asm
                    > USED AT LINE 121 IN MONDO.asm
                    > USED AT LINE 169 IN MONDO.asm
                    > USED AT LINE 1027 IN MONDO.asm
                    > USED AT LINE 1041 IN MONDO.asm
RPUSH:              02E3 DEFINED AT LINE 299 IN MONDO.asm
                    > USED AT LINE 287 IN MONDO.asm
                    > USED AT LINE 550 IN MONDO.asm
                    > USED AT LINE 919 IN MONDO.asm
RPOP:               02EE DEFINED AT LINE 306 IN MONDO.asm
                    > USED AT LINE 372 IN MONDO.asm
                    > USED AT LINE 400 IN MONDO.asm
                    > USED AT LINE 563 IN MONDO.asm
RPOP2:              02F8 DEFINED AT LINE 311 IN MONDO.asm
WRITECHAR:          02F9 DEFINED AT LINE 314 IN MONDO.asm
PAGE4:              0300 DEFINED AT LINE 323 IN MONDO.asm
AT_:                0300 DEFINED AT LINE 325 IN MONDO.asm
NOP_:               0300 DEFINED AT LINE 326 IN MONDO.asm
AMPER_:             0302 DEFINED AT LINE 329 IN MONDO.asm
AND:                0302 DEFINED AT LINE 330 IN MONDO.asm
AND1:               0309 DEFINED AT LINE 338 IN MONDO.asm
                    > USED AT LINE 352 IN MONDO.asm
                    > USED AT LINE 843 IN MONDO.asm
PIPE_:              030D DEFINED AT LINE 343 IN MONDO.asm
OR_:                030D DEFINED AT LINE 344 IN MONDO.asm
PLUS_:              0316 DEFINED AT LINE 354 IN MONDO.asm
PLUS1:              0320 DEFINED AT LINE 361 IN MONDO.asm
                    > USED AT LINE 358 IN MONDO.asm
EXIT_:              0326 DEFINED AT LINE 369 IN MONDO.asm
                    > USED AT LINE 207 IN MONDO.asm
HASH_:              0330 DEFINED AT LINE 377 IN MONDO.asm
ARRAYACCESS:        0330 DEFINED AT LINE 378 IN MONDO.asm
ARRAYACCESS0:       0338 DEFINED AT LINE 384 IN MONDO.asm
ARRAYACCESS1:       0339 DEFINED AT LINE 386 IN MONDO.asm
                    > USED AT LINE 383 IN MONDO.asm
STAR_:              033D DEFINED AT LINE 390 IN MONDO.asm
MULTIPLY:           033D DEFINED AT LINE 391 IN MONDO.asm
SEMI_:              0345 DEFINED AT LINE 398 IN MONDO.asm
                    > USED AT LINE 831 IN MONDO.asm
RET:                0345 DEFINED AT LINE 399 IN MONDO.asm
BANG_:              034C DEFINED AT LINE 406 IN MONDO.asm
ASSIGN:             034C DEFINED AT LINE 407 IN MONDO.asm
ASSIGN0:            034E DEFINED AT LINE 410 IN MONDO.asm
                    > USED AT LINE 360 IN MONDO.asm
                    > USED AT LINE 433 IN MONDO.asm
ASSIGN1:            0351 DEFINED AT LINE 412 IN MONDO.asm
MINUS_:             0356 DEFINED AT LINE 418 IN MONDO.asm
MINUS:              0356 DEFINED AT LINE 419 IN MONDO.asm
SUB:                0362 DEFINED AT LINE 427 IN MONDO.asm
                    > USED AT LINE 424 IN MONDO.asm
SUB1:               036C DEFINED AT LINE 434 IN MONDO.asm
                    > USED AT LINE 431 IN MONDO.asm
SUB2:               036E DEFINED AT LINE 437 IN MONDO.asm
EQ_:                0374 DEFINED AT LINE 444 IN MONDO.asm
GT_:                0380 DEFINED AT LINE 453 IN MONDO.asm
LT_:                0384 DEFINED AT LINE 458 IN MONDO.asm
CMP_:               0386 DEFINED AT LINE 462 IN MONDO.asm
                    > USED AT LINE 456 IN MONDO.asm
EQUAL:              0391 DEFINED AT LINE 468 IN MONDO.asm
                    > USED AT LINE 449 IN MONDO.asm
LESS:               0392 DEFINED AT LINE 470 IN MONDO.asm
                    > USED AT LINE 451 IN MONDO.asm
                    > USED AT LINE 465 IN MONDO.asm
                    > USED AT LINE 467 IN MONDO.asm
VAR_:               0395 DEFINED AT LINE 474 IN MONDO.asm
VAR1:               0399 DEFINED AT LINE 477 IN MONDO.asm
                    > USED AT LINE 388 IN MONDO.asm
                    > USED AT LINE 906 IN MONDO.asm
VAR2:               03A4 DEFINED AT LINE 485 IN MONDO.asm
                    > USED AT LINE 482 IN MONDO.asm
QUOTE_:             03A7 DEFINED AT LINE 489 IN MONDO.asm
STRDEF1:            03AF DEFINED AT LINE 494 IN MONDO.asm
                    > USED AT LINE 501 IN MONDO.asm
STRDEF2:            03B2 DEFINED AT LINE 498 IN MONDO.asm
                    > USED AT LINE 493 IN MONDO.asm
GRAVE_:             03BD DEFINED AT LINE 507 IN MONDO.asm
PRINTLITERAL:       03BD DEFINED AT LINE 508 IN MONDO.asm
PRINTLITERAL1:      03BE DEFINED AT LINE 511 IN MONDO.asm
                    > USED AT LINE 517 IN MONDO.asm
PRINTLITERAL2:      03C9 DEFINED AT LINE 519 IN MONDO.asm
                    > USED AT LINE 515 IN MONDO.asm
SLASH_:             03CC DEFINED AT LINE 523 IN MONDO.asm
SLASH:              03CC DEFINED AT LINE 524 IN MONDO.asm
CARET_:             03D7 DEFINED AT LINE 532 IN MONDO.asm
BACKSLASH_:         03DA DEFINED AT LINE 533 IN MONDO.asm
DOLLAR_:            03DD DEFINED AT LINE 534 IN MONDO.asm
DOT_:               03E0 DEFINED AT LINE 535 IN MONDO.asm
NUM_:               03E3 DEFINED AT LINE 536 IN MONDO.asm
RPAREN_:            03E6 DEFINED AT LINE 537 IN MONDO.asm
SHL_:               03E9 DEFINED AT LINE 538 IN MONDO.asm
SHR_:               03EC DEFINED AT LINE 539 IN MONDO.asm
TILDE_:             03EF DEFINED AT LINE 540 IN MONDO.asm
COLON_:             03F2 DEFINED AT LINE 542 IN MONDO.asm
LPAREN_:            03F4 DEFINED AT LINE 543 IN MONDO.asm
LBRACK_:            03F6 DEFINED AT LINE 546 IN MONDO.asm
ARRAYSTART:         03F6 DEFINED AT LINE 547 IN MONDO.asm
RBRACK_:            03FF DEFINED AT LINE 553 IN MONDO.asm
RBRACK:             03FF DEFINED AT LINE 560 IN MONDO.asm
ARRAYEND:           03FF DEFINED AT LINE 561 IN MONDO.asm
ARRAYEND1:          041C DEFINED AT LINE 578 IN MONDO.asm
                    > USED AT LINE 597 IN MONDO.asm
ARRAYEND2:          042C DEFINED AT LINE 592 IN MONDO.asm
                    > USED AT LINE 586 IN MONDO.asm
ARRAYEND3:          042D DEFINED AT LINE 594 IN MONDO.asm
                    > USED AT LINE 577 IN MONDO.asm
COLON:              0441 DEFINED AT LINE 606 IN MONDO.asm
                    > USED AT LINE 542 IN MONDO.asm
DEF:                0441 DEFINED AT LINE 607 IN MONDO.asm
DEF0:               0450 DEFINED AT LINE 616 IN MONDO.asm
                    > USED AT LINE 611 IN MONDO.asm
DEF1:               045B DEFINED AT LINE 623 IN MONDO.asm
                    > USED AT LINE 615 IN MONDO.asm
                    > USED AT LINE 630 IN MONDO.asm
DEF2:               0465 DEFINED AT LINE 631 IN MONDO.asm
                    > USED AT LINE 629 IN MONDO.asm
DEF3:               0466 DEFINED AT LINE 633 IN MONDO.asm
                    > USED AT LINE 505 IN MONDO.asm
LPAREN:             046C DEFINED AT LINE 637 IN MONDO.asm
                    > USED AT LINE 543 IN MONDO.asm
BEGIN:              046C DEFINED AT LINE 638 IN MONDO.asm
BEGIN1:             0498 DEFINED AT LINE 656 IN MONDO.asm
                    > USED AT LINE 642 IN MONDO.asm
                    > USED AT LINE 760 IN MONDO.asm
BEGIN2:             049A DEFINED AT LINE 658 IN MONDO.asm
                    > USED AT LINE 664 IN MONDO.asm
BEGIN3:             04A6 DEFINED AT LINE 666 IN MONDO.asm
                    > USED AT LINE 703 IN MONDO.asm
BEGIN4:             04AE DEFINED AT LINE 673 IN MONDO.asm
                    > USED AT LINE 671 IN MONDO.asm
RPAREN:             04B0 DEFINED AT LINE 676 IN MONDO.asm
                    > USED AT LINE 537 IN MONDO.asm
AGAIN:              04B0 DEFINED AT LINE 677 IN MONDO.asm
AGAIN1:             04CF DEFINED AT LINE 691 IN MONDO.asm
AGAIN2:             04D7 DEFINED AT LINE 695 IN MONDO.asm
                    > USED AT LINE 687 IN MONDO.asm
AGAIN3:             04DA DEFINED AT LINE 697 IN MONDO.asm
AGAIN4:             04DC DEFINED AT LINE 699 IN MONDO.asm
                    > USED AT LINE 694 IN MONDO.asm
SHL:                04E7 DEFINED AT LINE 706 IN MONDO.asm
                    > USED AT LINE 538 IN MONDO.asm
SHR:                04EC DEFINED AT LINE 713 IN MONDO.asm
                    > USED AT LINE 539 IN MONDO.asm
SHR1:               04ED DEFINED AT LINE 715 IN MONDO.asm
PAGE5:              0500 DEFINED AT LINE 725 IN MONDO.asm
                    > USED AT LINE 879 IN MONDO.asm
ARRAYLENGTH_:       0500 DEFINED AT LINE 728 IN MONDO.asm
TOGBYTEMODE_:       0508 DEFINED AT LINE 737 IN MONDO.asm
HEXADECIMAL_:       0511 DEFINED AT LINE 742 IN MONDO.asm
DECIMAL_:           0516 DEFINED AT LINE 745 IN MONDO.asm
DECIMAL2:           0519 DEFINED AT LINE 747 IN MONDO.asm
                    > USED AT LINE 744 IN MONDO.asm
WHILE_:             051E DEFINED AT LINE 751 IN MONDO.asm
WHILE1:             0525 DEFINED AT LINE 757 IN MONDO.asm
                    > USED AT LINE 755 IN MONDO.asm
COMMENT_:           052D DEFINED AT LINE 762 IN MONDO.asm
                    > USED AT LINE 766 IN MONDO.asm
                    > USED AT LINE 863 IN MONDO.asm
ANOP_:              0534 DEFINED AT LINE 768 IN MONDO.asm
PRNCHAR_:           0536 DEFINED AT LINE 771 IN MONDO.asm
GO_:                053D DEFINED AT LINE 777 IN MONDO.asm
GO1:                0542 DEFINED AT LINE 780 IN MONDO.asm
                    > USED AT LINE 778 IN MONDO.asm
PROMPT_:            0545 DEFINED AT LINE 785 IN MONDO.asm
INPORT_:            054A DEFINED AT LINE 789 IN MONDO.asm
KEY_:               0555 DEFINED AT LINE 799 IN MONDO.asm
NEWLN_:             055E DEFINED AT LINE 806 IN MONDO.asm
OUTPORT_:           0563 DEFINED AT LINE 810 IN MONDO.asm
PRNSTR_:            056C DEFINED AT LINE 819 IN MONDO.asm
PRNSTR:             056C DEFINED AT LINE 820 IN MONDO.asm
QUIT_:              0572 DEFINED AT LINE 827 IN MONDO.asm
XOR_:               057A DEFINED AT LINE 834 IN MONDO.asm
XOR1:               057B DEFINED AT LINE 836 IN MONDO.asm
DOTNEXT:            0584 DEFINED AT LINE 853 IN MONDO.asm
                    > USED AT LINE 997 IN MONDO.asm
                    > USED AT LINE 1001 IN MONDO.asm
ALT:                058D DEFINED AT LINE 859 IN MONDO.asm
                    > USED AT LINE 533 IN MONDO.asm
ALT1:               05AF DEFINED AT LINE 882 IN MONDO.asm
                    > USED AT LINE 866 IN MONDO.asm
                    > USED AT LINE 871 IN MONDO.asm
                    > USED AT LINE 873 IN MONDO.asm
ALTVAR:             05B1 DEFINED AT LINE 886 IN MONDO.asm
                    > USED AT LINE 868 IN MONDO.asm
ALTVAR1:            05BB DEFINED AT LINE 891 IN MONDO.asm
                    > USED AT LINE 889 IN MONDO.asm
ALTVAR2:            05C6 DEFINED AT LINE 897 IN MONDO.asm
                    > USED AT LINE 893 IN MONDO.asm
ALTVAR3:            05CF DEFINED AT LINE 904 IN MONDO.asm
                    > USED AT LINE 890 IN MONDO.asm
                    > USED AT LINE 896 IN MONDO.asm
EXEC:               05D5 DEFINED AT LINE 908 IN MONDO.asm
                    > USED AT LINE 532 IN MONDO.asm
EXEC1:              05D6 DEFINED AT LINE 910 IN MONDO.asm
EXEC2:              05E5 DEFINED AT LINE 920 IN MONDO.asm
                    > USED AT LINE 918 IN MONDO.asm
EXEC3:              05E8 DEFINED AT LINE 923 IN MONDO.asm
                    > USED AT LINE 913 IN MONDO.asm
NUM:                05EA DEFINED AT LINE 927 IN MONDO.asm
                    > USED AT LINE 426 IN MONDO.asm
                    > USED AT LINE 536 IN MONDO.asm
NUM0:               05F3 DEFINED AT LINE 933 IN MONDO.asm
                    > USED AT LINE 931 IN MONDO.asm
NUM1:               05F4 DEFINED AT LINE 935 IN MONDO.asm
                    > USED AT LINE 952 IN MONDO.asm
NUM2:               060C DEFINED AT LINE 953 IN MONDO.asm
                    > USED AT LINE 938 IN MONDO.asm
                    > USED AT LINE 940 IN MONDO.asm
                    > USED AT LINE 976 IN MONDO.asm
                    > USED AT LINE 978 IN MONDO.asm
NUM3:               0617 DEFINED AT LINE 961 IN MONDO.asm
                    > USED AT LINE 956 IN MONDO.asm
DOLLAR:             061A DEFINED AT LINE 965 IN MONDO.asm
                    > USED AT LINE 534 IN MONDO.asm
HEXNUM:             061A DEFINED AT LINE 966 IN MONDO.asm
HEXNUM1:            061D DEFINED AT LINE 968 IN MONDO.asm
                    > USED AT LINE 985 IN MONDO.asm
HEXNUM2:            0625 DEFINED AT LINE 974 IN MONDO.asm
                    > USED AT LINE 972 IN MONDO.asm
DOT:                0637 DEFINED AT LINE 989 IN MONDO.asm
                    > USED AT LINE 535 IN MONDO.asm
PRINTNUMBER:        0637 DEFINED AT LINE 990 IN MONDO.asm
PRINTHEX:           0646 DEFINED AT LINE 998 IN MONDO.asm
                    > USED AT LINE 993 IN MONDO.asm
TILDE:              064D DEFINED AT LINE 1005 IN MONDO.asm
                    > USED AT LINE 540 IN MONDO.asm
TOGGLE:             064D DEFINED AT LINE 1006 IN MONDO.asm
TOGGLE0:            064E DEFINED AT LINE 1008 IN MONDO.asm
                    > USED AT LINE 740 IN MONDO.asm
TOGGLE1:            0655 DEFINED AT LINE 1013 IN MONDO.asm
                    > USED AT LINE 1011 IN MONDO.asm
TOGGLE2:            065C DEFINED AT LINE 1019 IN MONDO.asm
PROMPT:             065E DEFINED AT LINE 1026 IN MONDO.asm
                    > USED AT LINE 125 IN MONDO.asm
                    > USED AT LINE 786 IN MONDO.asm
PUTSTR0:            0667 DEFINED AT LINE 1031 IN MONDO.asm
                    > USED AT LINE 1037 IN MONDO.asm
PUTSTR:             066B DEFINED AT LINE 1034 IN MONDO.asm
                    > USED AT LINE 294 IN MONDO.asm
                    > USED AT LINE 822 IN MONDO.asm
                    > USED AT LINE 1283 IN MONDO.asm
CRLF:               0671 DEFINED AT LINE 1040 IN MONDO.asm
                    > USED AT LINE 191 IN MONDO.asm
                    > USED AT LINE 807 IN MONDO.asm
FORMATDEC0:         0678 DEFINED AT LINE 1048 IN MONDO.asm
FORMATDEC:          067B DEFINED AT LINE 1055 IN MONDO.asm
                    > USED AT LINE 1258 IN MONDO.asm
FORMATDEC2:         068B DEFINED AT LINE 1069 IN MONDO.asm
                    > USED AT LINE 1057 IN MONDO.asm
FORMATDEC4:         06AB DEFINED AT LINE 1083 IN MONDO.asm
                    > USED AT LINE 1072 IN MONDO.asm
                    > USED AT LINE 1074 IN MONDO.asm
                    > USED AT LINE 1076 IN MONDO.asm
                    > USED AT LINE 1078 IN MONDO.asm
                    > USED AT LINE 1081 IN MONDO.asm
FORMATDEC5:         06AD DEFINED AT LINE 1085 IN MONDO.asm
                    > USED AT LINE 1088 IN MONDO.asm
FORMATDEC6:         06BD DEFINED AT LINE 1097 IN MONDO.asm
                    > USED AT LINE 1092 IN MONDO.asm
FORMATDEC7:         06BE DEFINED AT LINE 1099 IN MONDO.asm
                    > USED AT LINE 1096 IN MONDO.asm
DIV:                06C4 DEFINED AT LINE 1110 IN MONDO.asm
                    > USED AT LINE 527 IN MONDO.asm
DIV1:               06CC DEFINED AT LINE 1117 IN MONDO.asm
                    > USED AT LINE 1130 IN MONDO.asm
DIV2:               06D9 DEFINED AT LINE 1126 IN MONDO.asm
                    > USED AT LINE 1123 IN MONDO.asm
DIV3:               06DA DEFINED AT LINE 1128 IN MONDO.asm
                    > USED AT LINE 1125 IN MONDO.asm
DIV4:               06DF DEFINED AT LINE 1133 IN MONDO.asm
NESTING:            06E1 DEFINED AT LINE 1145 IN MONDO.asm
                    > USED AT LINE 141 IN MONDO.asm
                    > USED AT LINE 179 IN MONDO.asm
                    > USED AT LINE 661 IN MONDO.asm
NESTING1A:          06EC DEFINED AT LINE 1152 IN MONDO.asm
                    > USED AT LINE 1149 IN MONDO.asm
NESTING1:           06EF DEFINED AT LINE 1155 IN MONDO.asm
                    > USED AT LINE 1147 IN MONDO.asm
NESTING2:           06FE DEFINED AT LINE 1164 IN MONDO.asm
                    > USED AT LINE 1159 IN MONDO.asm
                    > USED AT LINE 1161 IN MONDO.asm
NESTING3:           0700 DEFINED AT LINE 1167 IN MONDO.asm
                    > USED AT LINE 1163 IN MONDO.asm
NESTING4:           070B DEFINED AT LINE 1174 IN MONDO.asm
                    > USED AT LINE 1169 IN MONDO.asm
                    > USED AT LINE 1171 IN MONDO.asm
LOOKUPREF:          070D DEFINED AT LINE 1182 IN MONDO.asm
                    > USED AT LINE 476 IN MONDO.asm
                    > USED AT LINE 617 IN MONDO.asm
LOOKUPREF0:         070F DEFINED AT LINE 1184 IN MONDO.asm
LOOKUPREF1:         071E DEFINED AT LINE 1192 IN MONDO.asm
                    > USED AT LINE 1188 IN MONDO.asm
LOOKUPREF3:         0728 DEFINED AT LINE 1197 IN MONDO.asm
                    > USED AT LINE 1191 IN MONDO.asm
PUTHEX:             0738 DEFINED AT LINE 1211 IN MONDO.asm
                    > USED AT LINE 1000 IN MONDO.asm
PUTHEX1:            0740 DEFINED AT LINE 1216 IN MONDO.asm
PUTHEX2:            074A DEFINED AT LINE 1222 IN MONDO.asm
                    > USED AT LINE 1219 IN MONDO.asm
PUTHEX3:            0757 DEFINED AT LINE 1230 IN MONDO.asm
                    > USED AT LINE 1221 IN MONDO.asm
                    > USED AT LINE 1224 IN MONDO.asm
PUTHEX4:            0760 DEFINED AT LINE 1238 IN MONDO.asm
                    > USED AT LINE 1236 IN MONDO.asm
PUTDEC:             076B DEFINED AT LINE 1249 IN MONDO.asm
                    > USED AT LINE 996 IN MONDO.asm
PRINTDEC1:          0779 DEFINED AT LINE 1257 IN MONDO.asm
                    > USED AT LINE 1255 IN MONDO.asm
ERROR:              0786 DEFINED AT LINE 1267 IN MONDO.asm
                    > USED AT LINE 1275 IN MONDO.asm
ERROR1:             0794 DEFINED AT LINE 1273 IN MONDO.asm
                    > USED AT LINE 1186 IN MONDO.asm
                    > USED AT LINE 1194 IN MONDO.asm
                    > USED AT LINE 1196 IN MONDO.asm
FLUSH:              079A DEFINED AT LINE 1277 IN MONDO.asm
                    > USED AT LINE 856 IN MONDO.asm
MUL:                07AB DEFINED AT LINE 1289 IN MONDO.asm
                    > USED AT LINE 394 IN MONDO.asm
MUL2:               07B3 DEFINED AT LINE 1295 IN MONDO.asm
                    > USED AT LINE 1304 IN MONDO.asm
TIBSIZE:            0100 DEFINED AT LINE 3 IN ram.asm
                    > USED AT LINE 10 IN ram.asm
BUFSIZE:            0100 DEFINED AT LINE 4 IN ram.asm
                    > USED AT LINE 12 IN ram.asm
DSIZE:              0080 DEFINED AT LINE 5 IN ram.asm
                    > USED AT LINE 17 IN ram.asm
RSIZE:              0080 DEFINED AT LINE 6 IN ram.asm
                    > USED AT LINE 14 IN ram.asm
LSIZE:              0080 DEFINED AT LINE 7 IN ram.asm
                    > USED AT LINE 20 IN ram.asm
VARS_SIZE:          0068 DEFINED AT LINE 8 IN ram.asm
                    > USED AT LINE 254 IN MONDO.asm
                    > USED AT LINE 81 IN ram.asm
TIB:                0800 DEFINED AT LINE 10 IN ram.asm
                    > USED AT LINE 134 IN MONDO.asm
                    > USED AT LINE 174 IN MONDO.asm
                    > USED AT LINE 183 IN MONDO.asm
                    > USED AT LINE 200 IN MONDO.asm
                    > USED AT LINE 247 IN MONDO.asm
BUFFER:             0900 DEFINED AT LINE 12 IN ram.asm
                    > USED AT LINE 243 IN MONDO.asm
                    > USED AT LINE 1278 IN MONDO.asm
RSTACK:             0A80 DEFINED AT LINE 15 IN ram.asm
                    > USED AT LINE 233 IN MONDO.asm
DSTACK:             0B00 DEFINED AT LINE 18 IN ram.asm
                    > USED AT LINE 119 IN MONDO.asm
                    > USED AT LINE 223 IN MONDO.asm
                    > USED AT LINE 226 IN MONDO.asm
STACK:              0B00 DEFINED AT LINE 19 IN ram.asm
                    > USED AT LINE 445 IN IOSerial.asm
LSTACK:             0B80 DEFINED AT LINE 21 IN ram.asm
                    > USED AT LINE 231 IN MONDO.asm
OPCODES:            0C00 DEFINED AT LINE 24 IN ram.asm
                    > USED AT LINE 259 IN MONDO.asm
ALTCODES:           0C5E DEFINED AT LINE 26 IN ram.asm
                    > USED AT LINE 875 IN MONDO.asm
MONDOVARS:          0D00 DEFINED AT LINE 30 IN ram.asm
VLOOPSP:            0D30 DEFINED AT LINE 32 IN ram.asm
                    > USED AT LINE 232 IN MONDO.asm
                    > USED AT LINE 644 IN MONDO.asm
                    > USED AT LINE 653 IN MONDO.asm
                    > USED AT LINE 679 IN MONDO.asm
                    > USED AT LINE 700 IN MONDO.asm
                    > USED AT LINE 887 IN MONDO.asm
TBPTR:              0D32 DEFINED AT LINE 33 IN ram.asm
RST08:              0D34 DEFINED AT LINE 35 IN ram.asm
                    > USED AT LINE 107 IN IOSerial.asm
                    > USED AT LINE 447 IN IOSerial.asm
RST10:              0D36 DEFINED AT LINE 36 IN ram.asm
                    > USED AT LINE 113 IN IOSerial.asm
                    > USED AT LINE 448 IN IOSerial.asm
RST18:              0D38 DEFINED AT LINE 37 IN ram.asm
                    > USED AT LINE 119 IN IOSerial.asm
                    > USED AT LINE 449 IN IOSerial.asm
RST20:              0D3A DEFINED AT LINE 38 IN ram.asm
                    > USED AT LINE 125 IN IOSerial.asm
                    > USED AT LINE 450 IN IOSerial.asm
RST28:              0D3C DEFINED AT LINE 39 IN ram.asm
                    > USED AT LINE 131 IN IOSerial.asm
                    > USED AT LINE 451 IN IOSerial.asm
RST30:              0D3E DEFINED AT LINE 40 IN ram.asm
                    > USED AT LINE 137 IN IOSerial.asm
                    > USED AT LINE 452 IN IOSerial.asm
BAUD:               0D40 DEFINED AT LINE 41 IN ram.asm
INTVEC:             0D42 DEFINED AT LINE 42 IN ram.asm
                    > USED AT LINE 143 IN IOSerial.asm
                    > USED AT LINE 453 IN IOSerial.asm
NMIVEC:             0D44 DEFINED AT LINE 43 IN ram.asm
                    > USED AT LINE 191 IN IOSerial.asm
                    > USED AT LINE 454 IN IOSerial.asm
GETCVEC:            0D46 DEFINED AT LINE 44 IN ram.asm
                    > USED AT LINE 435 IN IOSerial.asm
                    > USED AT LINE 457 IN IOSerial.asm
PUTCVEC:            0D48 DEFINED AT LINE 45 IN ram.asm
                    > USED AT LINE 440 IN IOSerial.asm
                    > USED AT LINE 459 IN IOSerial.asm
VTEMP1:             0D4A DEFINED AT LINE 47 IN ram.asm
                    > USED AT LINE 562 IN MONDO.asm
                    > USED AT LINE 603 IN MONDO.asm
VTEMP2:             0D4C DEFINED AT LINE 48 IN ram.asm
VTEMP3:             0D4E DEFINED AT LINE 49 IN ram.asm
ALTVARS:            0D50 DEFINED AT LINE 51 IN ram.asm
                    > USED AT LINE 236 IN MONDO.asm
                    > USED AT LINE 901 IN MONDO.asm
VBUFPTR:            0D50 DEFINED AT LINE 53 IN ram.asm
                    > USED AT LINE 244 IN MONDO.asm
                    > USED AT LINE 1212 IN MONDO.asm
                    > USED AT LINE 1228 IN MONDO.asm
                    > USED AT LINE 1251 IN MONDO.asm
                    > USED AT LINE 1263 IN MONDO.asm
                    > USED AT LINE 1279 IN MONDO.asm
                    > USED AT LINE 1281 IN MONDO.asm
VBYTEMODE:          0D52 DEFINED AT LINE 54 IN ram.asm
                    > USED AT LINE 381 IN MONDO.asm
                    > USED AT LINE 480 IN MONDO.asm
                    > USED AT LINE 584 IN MONDO.asm
                    > USED AT LINE 738 IN MONDO.asm
                    > USED AT LINE 1217 IN MONDO.asm
                    > USED AT LINE 1253 IN MONDO.asm
VCARRY:             0D54 DEFINED AT LINE 55 IN ram.asm
VECHOMODE:          0D58 DEFINED AT LINE 57 IN ram.asm
VHEAPPTR:           0D5E DEFINED AT LINE 60 IN ram.asm
                    > USED AT LINE 246 IN MONDO.asm
                    > USED AT LINE 490 IN MONDO.asm
                    > USED AT LINE 570 IN MONDO.asm
                    > USED AT LINE 598 IN MONDO.asm
                    > USED AT LINE 599 IN MONDO.asm
                    > USED AT LINE 613 IN MONDO.asm
                    > USED AT LINE 618 IN MONDO.asm
                    > USED AT LINE 634 IN MONDO.asm
VI:                 0D60 DEFINED AT LINE 61 IN ram.asm
VJ:                 0D62 DEFINED AT LINE 62 IN ram.asm
VPOINTER:           0D6E DEFINED AT LINE 68 IN ram.asm
                    > USED AT LINE 411 IN MONDO.asm
                    > USED AT LINE 739 IN MONDO.asm
                    > USED AT LINE 905 IN MONDO.asm
                    > USED AT LINE 1015 IN MONDO.asm
                    > USED AT LINE 1206 IN MONDO.asm
VREMAIN:            0D72 DEFINED AT LINE 70 IN ram.asm
                    > USED AT LINE 529 IN MONDO.asm
VSTRMODE:           0D74 DEFINED AT LINE 71 IN ram.asm
                    > USED AT LINE 854 IN MONDO.asm
VTIBPTR:            0D76 DEFINED AT LINE 72 IN ram.asm
                    > USED AT LINE 128 IN MONDO.asm
                    > USED AT LINE 162 IN MONDO.asm
                    > USED AT LINE 199 IN MONDO.asm
                    > USED AT LINE 248 IN MONDO.asm
VHEXMODE:           0D7E DEFINED AT LINE 76 IN ram.asm
                    > USED AT LINE 748 IN MONDO.asm
                    > USED AT LINE 991 IN MONDO.asm
VARIABLES:          0D84 DEFINED AT LINE 80 IN ram.asm
                    > USED AT LINE 250 IN MONDO.asm
                    > USED AT LINE 1200 IN MONDO.asm
HEAP:               0DEC DEFINED AT LINE 83 IN ram.asm
                    > USED AT LINE 245 IN MONDO.asm
